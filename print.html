<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Embedded Rust Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro/index.html"><strong aria-hidden="true">1.</strong> 導入</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/no-std.html"><strong aria-hidden="true">1.1.</strong> no_std</a></li><li class="chapter-item expanded "><a href="intro/tooling.html"><strong aria-hidden="true">1.2.</strong> ツール</a></li><li class="chapter-item expanded "><a href="intro/install.html"><strong aria-hidden="true">1.3.</strong> インストール</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/install/linux.html"><strong aria-hidden="true">1.3.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="intro/install/macos.html"><strong aria-hidden="true">1.3.2.</strong> MacOS</a></li><li class="chapter-item expanded "><a href="intro/install/windows.html"><strong aria-hidden="true">1.3.3.</strong> Windows</a></li><li class="chapter-item expanded "><a href="intro/install/verify.html"><strong aria-hidden="true">1.3.4.</strong> インストールの確認</a></li></ol></li><li class="chapter-item expanded "><a href="intro/hardware.html"><strong aria-hidden="true">1.4.</strong> ハードウェア</a></li></ol></li><li class="chapter-item expanded "><a href="start/index.html"><strong aria-hidden="true">2.</strong> 入門</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="start/qemu.html"><strong aria-hidden="true">2.1.</strong> QEMU</a></li><li class="chapter-item expanded "><a href="start/hardware.html"><strong aria-hidden="true">2.2.</strong> ハードウェア</a></li><li class="chapter-item expanded "><a href="start/registers.html"><strong aria-hidden="true">2.3.</strong> メモリマップドレジスタ</a></li><li class="chapter-item expanded "><a href="start/semihosting.html"><strong aria-hidden="true">2.4.</strong> セミホスティング</a></li><li class="chapter-item expanded "><a href="start/panicking.html"><strong aria-hidden="true">2.5.</strong> パニック</a></li><li class="chapter-item expanded "><a href="start/exceptions.html"><strong aria-hidden="true">2.6.</strong> 例外</a></li><li class="chapter-item expanded "><a href="start/interrupts.html"><strong aria-hidden="true">2.7.</strong> 割り込み</a></li><li class="chapter-item expanded "><a href="start/io.html"><strong aria-hidden="true">2.8.</strong> IO</a></li></ol></li><li class="chapter-item expanded "><a href="peripherals/index.html"><strong aria-hidden="true">3.</strong> ペリフェラル</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="peripherals/a-first-attempt.html"><strong aria-hidden="true">3.1.</strong> Rustでの最初の試み</a></li><li class="chapter-item expanded "><a href="peripherals/borrowck.html"><strong aria-hidden="true">3.2.</strong> 借用チェッカ</a></li><li class="chapter-item expanded "><a href="peripherals/singletons.html"><strong aria-hidden="true">3.3.</strong> シングルトン</a></li></ol></li><li class="chapter-item expanded "><a href="static-guarantees/index.html"><strong aria-hidden="true">4.</strong> 静的な保証</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="static-guarantees/typestate-programming.html"><strong aria-hidden="true">4.1.</strong> 型状態プログラミング</a></li><li class="chapter-item expanded "><a href="static-guarantees/state-machines.html"><strong aria-hidden="true">4.2.</strong> ステートマシンとしてのペリフェラル</a></li><li class="chapter-item expanded "><a href="static-guarantees/design-contracts.html"><strong aria-hidden="true">4.3.</strong> 設計契約</a></li><li class="chapter-item expanded "><a href="static-guarantees/zero-cost-abstractions.html"><strong aria-hidden="true">4.4.</strong> ゼロコスト抽象化</a></li></ol></li><li class="chapter-item expanded "><a href="portability/index.html"><strong aria-hidden="true">5.</strong> 移植性</a></li><li class="chapter-item expanded "><a href="concurrency/index.html"><strong aria-hidden="true">6.</strong> 並行性</a></li><li class="chapter-item expanded "><a href="collections/index.html"><strong aria-hidden="true">7.</strong> コレクション</a></li><li class="chapter-item expanded "><a href="c-tips/index.html"><strong aria-hidden="true">8.</strong> 組込みC開発者へのヒント</a></li><li class="chapter-item expanded "><a href="interoperability/index.html"><strong aria-hidden="true">9.</strong> 相互運用性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interoperability/c-with-rust.html"><strong aria-hidden="true">9.1.</strong> Rustと少しのC</a></li><li class="chapter-item expanded "><a href="interoperability/rust-with-c.html"><strong aria-hidden="true">9.2.</strong> Cと少しのRust</a></li></ol></li><li class="chapter-item expanded "><a href="unsorted/index.html"><strong aria-hidden="true">10.</strong> 未分類のトピック</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="unsorted/speed-vs-size.html"><strong aria-hidden="true">10.1.</strong> 最適化: 速度とサイズのトレードオフ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Embedded Rust Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- # Introduction -->
<h1><a class="header" href="#導入" id="導入">導入</a></h1>
<!-- Welcome to The Embedded Rust Book: An introductory book about using the Rust -->
<!-- Programming Language on "Bare Metal" embedded systems, such as Microcontrollers. -->
<p><em>The Embedded Rust Book</em>へようこそ。Rustをマイクロコントローラのような、「ベアメタル」の組込みシステムで使うための入門書です。</p>
<!-- ## Who Embedded Rust is For -->
<!-- Embedded Rust is for everyone who wants to do embedded programming backed by the higher-level concepts and safety guarantees the Rust language provides. -->
<!-- (See also [Who Rust Is For](https://doc.rust-lang.org/book/2018-edition/ch00-00-introduction.html)) -->
<h2><a class="header" href="#組込みrustは誰のためのもの" id="組込みrustは誰のためのもの">組込みRustは誰のためのもの</a></h2>
<p>組込みRustは、Rustの高い抽象度と安全性のもと、組込みプログラミングをしたい人のためのものです。
(<a href="https://doc.rust-lang.org/book/2018-edition/ch00-00-introduction.html">Rustは誰のためのもの</a>も合わせて見て下さい)</p>
<!-- ## Scope -->
<h2><a class="header" href="#スコープ" id="スコープ">スコープ</a></h2>
<!-- The goals of this book are: -->
<p>この本の目的は、以下の通りです。</p>
<!-- * Get developers up to speed with embedded Rust development. i.e. How to set -->
<!--   up a development environment. -->
<ul>
<li>組込みRustをできる限り速く開始できるようにします。すなわち、開発環境のセットアップ方法です。</li>
</ul>
<!-- * Share *current* best practices about using Rust for embedded development. i.e. -->
<!--   How to best use Rust language features to write more correct embedded -->
<!--   software. -->
<ul>
<li>組込み開発におけるRustの<em>現在</em>のベストプラクティスを共有します。つまり、より正しい組込みソフトウェアを書くための、Rustの最善な利用方法です。</li>
</ul>
<!-- * Serve as a cookbook in some cases. e.g. How do I do mix C and Rust in a single -->
<!--   project? -->
<ul>
<li>いくつかのケースに対するマニュアルを提供します。例えば、1つのプロジェクト内で、C言語とRustとを混在する方法です。</li>
</ul>
<!-- This book tries to be as general as possible but to make things easier for both -->
<!-- the readers and the writers it uses the ARM Cortex-M architecture in all its -->
<!-- examples. However, the book assumes that the reader is not familiar with this -->
<!-- particular architecture and explains details particular to this architecture -->
<!-- where required. -->
<p>本書は出来る限り一般的な事項を取り扱います。ただし、説明を簡単にするために、全ての例で、ARM Cortex-Mアーキテクチャを利用します。
読者は、このアーキテクチャに詳しい必要はありません。本書では、アーキテクチャ固有の詳細について、必要に応じて説明をします。</p>
<!-- ## Who This Book is For -->
<!-- This book caters towards people with either some embedded background or some Rust background, however we assume -->
<!-- everybody curious about embedded Rust programming can get something out of this book. For those without any prior knowledge -->
<!-- we suggest you read the "Assumptions and Prerequisites" section and catch up on missing knowledge to get more out of the book -->
<!-- and improve your reading experience. You can check out the "Other Resources" section to find resources on topics -->
<!-- you want to catch up on. -->
<h2><a class="header" href="#この本は誰のためのもの" id="この本は誰のためのもの">この本は誰のためのもの</a></h2>
<p>本書は、組込み開発か、Rustかのバックグラウンドを持つ人々に向けたものです。しかし、組込みRustに興味がある人なら、誰でも、この本から何かを得られると思います。本書による学習効果を高めるために、事前知識が不足している読者は、「仮定と前提条件」のセクションを読み、不足している知識を補うことをお勧めします。不足知識を補うリソースを見つけるために、「その他のリソース」セクションをチェックすることができます。</p>
<!-- ### Assumptions and Prerequisites -->
<h3><a class="header" href="#仮定と前提条件" id="仮定と前提条件">仮定と前提条件</a></h3>
<!-- * You are comfortable using the Rust Programming Language, and have written, -->
<!--   run, and debugged Rust applications on a desktop environment. You should also -->
<!--   be familiar with the idioms of the [2018 edition] as this book targets -->
<!--   Rust 2018. -->
<ul>
<li>Rustでのプログラミングを楽しんでおり、デスクトップ環境でRustアプリケーションを書いたり、実行したり、デバッグしたりしたことがあることを前提とします。また、本書ではRust 2018を対象とするため、2018 editionのイディオムに慣れ親しんでいる必要があります。</li>
</ul>
<!-- * You are comfortable developing and debugging embedded systems in another -->
<!--   language such as C, C++, or Ada, and are familiar with concepts such as: -->
<!--     * Cross Compilation -->
<!--     * Memory Mapped Peripherals -->
<!--     * Interrupts -->
<!--     * Common interfaces such as I2C, SPI, Serial, etc. -->
<ul>
<li>C, C++, Adaといった言語で組込みシステムを開発、デバッグすることに慣れており、次の概念になじみがあることを想定します。
<ul>
<li>クロスコンパイル</li>
<li>メモリマップ方式のペリフェラル</li>
<li>割り込み</li>
<li>I2C、SPI、シリアルといった一般的なインタフェース</li>
</ul>
</li>
</ul>
<!-- ### Other Resources -->
<!-- If you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful. -->
<h3><a class="header" href="#その他のリソース" id="その他のリソース">その他のリソース</a></h3>
<p>もしあなたが上述した何らかの事項をよく知らない場合、もしくは、本書内の特定トピックに関して、より詳細な情報を知りたい場合、これらのリソースが役に立つでしょう。</p>
<!--
| Topic        | Resource | Description |
|--------------|----------|-------------|
| Rust         | [Rust Book 2018 Edition](https://doc.rust-lang.org/book/2018-edition/index.html) | If you are not yet comfortable with Rust, we highly suggest reading the this book. |
| Rust, Embedded | [Embedded Rust Bookshelf](https://docs.rust-embedded.org) | Here you can find several other resources provided by Rust's Embedded Working Group. |
| Rust, Embedded | [Embedonomicon](https://docs.rust-embedded.org/embedonomicon/) | The nitty gritty details when doing embedded programming in Rust. |
| Rust, Embedded | [embedded FAQ](https://docs.rust-embedded.org/faq.html) | Frequently asked questions about Rust in an embedded context. |
| Interrupts | [Interrupt](https://en.wikipedia.org/wiki/Interrupt) | - |
| Memory-mapped IO/Peripherals | [Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O) | - |
| SPI, UART, RS232, USB, I2C, TTL | [Stack Exchange about SPI, UART, and other interfaces](https://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th) | - |
-->
<table><thead><tr><th>トピック</th><th>リソース</th><th>説明</th></tr></thead><tbody>
<tr><td>Rust</td><td><a href="https://doc.rust-lang.org/book/2018-edition/index.html">Rust Book 2018 Edition</a></td><td>もしRustに親しんでいない場合、この本を読むことを強くお勧めします。</td></tr>
<tr><td>Rust、組込み</td><td><a href="https://docs.rust-embedded.org">Embedded Rust Bookshelf</a></td><td>Rust組込みワーキンググループによるいくらかのリソースがあります。</td></tr>
<tr><td>Rust、組込み</td><td><a href="https://docs.rust-embedded.org/embedonomicon/">Embedonomicon</a></td><td>Rustで組込みプログラミングを行うときのより深い詳細が記載されています。</td></tr>
<tr><td>Rust、組込み</td><td><a href="https://docs.rust-embedded.org/faq.html">embedded FAQ</a></td><td>組込みでRustを使う際のよくある質問と回答です。</td></tr>
<tr><td>割り込み</td><td><a href="https://en.wikipedia.org/wiki/Interrupt">Interrupt</a></td><td>-</td></tr>
<tr><td>メモリマップドI/O／ペリフェラル</td><td><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-mapped I/O</a></td><td>-</td></tr>
<tr><td>SPI, UART, RS232, USB, I2C, TTL</td><td><a href="https://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th">Stack Exchange about SPI, UART, and other interfaces</a></td><td>-</td></tr>
</tbody></table>
<!-- ## How to Use This Book -->
<h2><a class="header" href="#この本はどう使う" id="この本はどう使う">この本はどう使う</a></h2>
<!-- This book generally assumes that you’re reading it front-to-back. Later -->
<!-- chapters build on concepts in earlier chapters, and earlier chapters may -->
<!-- not dig into details on a topic, revisiting the topic in a later chapter. -->
<p>この本は、前から順番に読んでいくことを想定しています。後半の章は、前半の章で説明する概念に基づいて成り立っています。前半の章では、トピックの詳細に深入りせず、後半の章で再訪問します。</p>
<!-- This book will be using the [STM32F3DISCOVERY] development board from -->
<!-- STMicroelectronics for the majority of the examples contained within. This board -->
<!-- is based on the ARM Cortex-M architecture, and while basic functionality is -->
<!-- common across most CPUs based on this architecture, peripherals and other -->
<!-- implementation details of Microcontrollers are different between different -->
<!-- vendors, and often even different between Microcontroller families from the same -->
<!-- vendor. -->
<p>この本は、ほとんどの例で、STマイクロエレクトロニクスの<a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>開発ボードを使用します。このボードは、ARM Cortex-Mアーキテクチャをベースとしています。基本機能はこのアーキテクチャベースのCPUでは共通です。一方、ペリフェラルとマイクロコントローラ実装の詳細は、他のベンダーと異なります。同じSTマイクロエレクトロニクスのマイクロコントローラファミリでも、違いがあります。</p>
<!-- For this reason, we suggest purchasing the [STM32F3DISCOVERY] development board -->
<!-- for the purpose of following the examples in this book. -->
<p>上記の理由から、本書内の例を理解するために、<a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>開発ボードを購入することをお勧めします。</p>
<!-- 日本語訳へのコントリビューション情報を代わりに掲載する？ -->
<!-- ## Contributing to This Book -->
<!-- The work on this book is coordinated in [this repository] and is mainly -->
<!-- developed by the [resources team]. -->
<!-- [this repository]: https://github.com/rust-embedded/book -->
<!-- [resources team]: https://github.com/rust-embedded/wg#the-resources-team -->
<!-- If you have trouble following the instructions in this book or find that some -->
<!-- section of the book is not clear enough or hard to follow then that's a bug and -->
<!-- it should be reported in [the issue tracker] of this book. -->
<!-- [the issue tracker]: https://github.com/rust-embedded/book/issues/ -->
<!-- Pull requests fixing typos and adding new content are very welcome! -->
<!-- # A `no_std` Rust Environment -->
<h1><a class="header" href="#rustのno_std環境" id="rustのno_std環境">Rustの<code>no_std</code>環境</a></h1>
<!--
The term Embedded Programming is used for a wide range of different classes of programming.
Ranging from programming 8-Bit MCUs (like the [ST72325xx](https://www.st.com/resource/en/datasheet/st72325j6.pdf))
with just a few KB of RAM and ROM, up to systems like the Raspberry Pi
([Model B 3+](https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit
4-core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations will apply when writing code
depending on what kind of target and use case you have.
-->
<p>組込みプログラミングという用語は、様々な分野のプログラミングに使用されます。
たった数キロバイトのRAMかROMが付随する8ビットMCU (例えば、<a href="https://www.st.com/resource/en/datasheet/st72325j6.pdf">ST72325xx</a>)から、32/64ビットの4コア Cortex-A53 @ 1.4GHzと1GBのRAMが搭載されたRaspberry Pi(<a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications">Model B 3+</a>)のようなシステムまで、幅広いです。
どのような種類の目的とユースケースがあるか、によって、コードを書くときに異なる制限/限界が課されます。</p>
<!-- There are two general Embedded Programming classifications: -->
<p>2つの一般的な組込みプログラミングの分類があります。</p>
<!-- 
## Hosted Environments
These kinds of environments are close to a normal PC environment.
What this means is you are provided with a System Interface [E.G. POSIX](https://en.wikipedia.org/wiki/POSIX)
that provides you with primitives to interact with various systems, such as file systems, networking, memory management, threads, etc.
Standard libraries in turn usually depend on these primitives to implement their functionality.
You may also have some sort of sysroot and restrictions on RAM/ROM-usage, and perhaps some
special HW or I/Os. Overall it feels like coding on a special-purpose PC environment.
 -->
<h2><a class="header" href="#ホストされた環境" id="ホストされた環境">ホストされた環境</a></h2>
<p>この分類の環境は、普通のPCの環境に近いです。
これの意味するところは、<a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>のようなシステムインタフェースが提供されている、ということです。システムインタフェースは、ファイルシステムやネットワーク、メモリ管理、スレッドといった多様なシステムとやりとりするための基本要素を提供します。
通常、標準ライブラリは、その機能を実装するために、これらの基本要素に依存します。
また、sysrootや、RAM/ROM利用の制限、そしておそらく特別なハードウェアやIOがあるかもしれません。
全体としては、特殊な用途のPC環境でコーディングをするようなものです。</p>
<!-- 
## Bare Metal Environments
In a bare metal environment there will be no high-level OS running and hosting our code.
This means there will be no primitives, which means there's also no standard library by default.
By marking our code with `no_std` we indicate that our code is capable of running in such an environment.
This means the rust [libstd](https://doc.rust-lang.org/std/) and dynamic memory allocation can't be used by such code.
However, such code can use [libcore](https://doc.rust-lang.org/core/), which can easily be made available
in any kind of environment by providing just a few symbols (for details see [libcore](https://doc.rust-lang.org/core/)).
 -->
<h2><a class="header" href="#ベアメタル環境" id="ベアメタル環境">ベアメタル環境</a></h2>
<p>ベアメタル環境では、高機能なOSが動作していて、私たちのコードをホスティングしてくれる、ということはありません。
これは、基本要素がないことを意味しており、それ故に、デフォルトでは標準ライブラリもありません。
コードに<code>no_std</code>のマーキングをすることで、そのコードが、ベアメタル環境で実行できることを示します。
no_stdなコードからは、Rustの<a href="https://doc.rust-lang.org/std/">libstd</a>とメモリの動的確保が使えません。
しかしながら、no_stdなコードでも<a href="https://doc.rust-lang.org/core/">libcore</a>を使うことができます。libcoreは、ほんの数種類のシンボルを提供することで、いかなる環境でも容易に利用することができます (詳細は、<a href="https://doc.rust-lang.org/core/">libcore</a>を参照して下さい)。</p>
<!-- 
### The libstd Runtime
As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires some sort of system integration, but this is not only because
[libstd](https://doc.rust-lang.org/std/) is just providing a common way of accessing OS abstractions, it also provides a runtime.
This runtime, among other things, takes care of setting up stack overflow protection, processing command line arguments,
and spawning the main thread before a program's main function is invoked. This runtime also won't be available in a `no_std` environment.
 -->
<h3><a class="header" href="#libstdランタイム" id="libstdランタイム">libstdランタイム</a></h3>
<p>上述の通り、<a href="https://doc.rust-lang.org/std/">libstd</a>の利用には、いくらかのシステムインテグレーションが必要です。しかし、これは<a href="https://doc.rust-lang.org/std/">libstd</a>がOSの抽象にアクセスするための共通の方法を提供しているだけでなく、ランタイムも提供しているためです。
ランタイムは、とりわけ、スタックオーバーフロープロテクションの準備、コマンドライン引数の処理、メインスレッドの生成、をプログラムのメイン関数が呼び出される前に処理します。
このランタイムも、<code>no_std</code>環境では利用できません。</p>
<!-- 
## Summary
`#![no_std]` is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.
The [libcore](https://doc.rust-lang.org/core/) crate in turn is a platform-agnostic subset of the std crate
which makes no assumptions about the system the program will run on.
As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features
like atomic operations and SIMD instructions. However it lacks APIs for anything that involves platform integration.
Because of these properties no\_std and [libcore](https://doc.rust-lang.org/core/) code can be used for any kind of
bootstrapping (stage 0) code like bootloaders, firmware or kernels.
 -->
<h2><a class="header" href="#まとめ" id="まとめ">まとめ</a></h2>
<p><code>#![no_std]</code>は、クレートレベルの属性で、そのクレートがstdクレートの代わりにcoreクレートとリンクすることを意味します。
<a href="https://doc.rust-lang.org/core/">libcore</a>クレートは、プラットフォームに依存しないstdクレートのサブセットです。libcoreクレートは、プログラムが動作するシステムについて前提を置きません。
libcoreクレートは、浮動小数点、文字列やスライスといった言語の基本要素となるAPIと、アトミック操作やSIMD命令といったプロセッサの機能を公開するAPIとを、提供します。一方、プラットフォームインテグレーションを伴うようなAPIは欠如しています。
これらの特性のため、no_stdと<a href="https://doc.rust-lang.org/core/">libcore</a>のコードは、ブートローダー、ファームウェア、カーネルといったあらゆるブートストラップ (ステージ0)のコードにも利用できます。</p>
<!-- 
### Overview

| feature                                                   | no\_std | std |
|-----------------------------------------------------------|--------|-----|
| heap (dynamic memory)                                     |   *    |  ✓  |
| collections (Vec, HashMap, etc)                           |  **    |  ✓  |
| stack overflow protection                                 |   ✘    |  ✓  |
| runs init code before main                                |   ✘    |  ✓  |
| libstd available                                          |   ✘    |  ✓  |
| libcore available                                         |   ✓    |  ✓  |
| writing firmware, kernel, or bootloader code              |   ✓    |  ✘  |

\* Only if you use the `alloc` crate and use a suitable allocator like [alloc-cortex-m].

\** Only if you use the `collections` crate and configure a global default allocator.

[alloc-cortex-m]: https://github.com/rust-embedded/alloc-cortex-m
 -->
<h3><a class="header" href="#概略" id="概略">概略</a></h3>
<table><thead><tr><th>機能</th><th>no_std</th><th>std</th></tr></thead><tbody>
<tr><td>ヒープ (動的メモリ)</td><td>*</td><td>✓</td></tr>
<tr><td>コレクション (Vec, HashMap, など)</td><td>**</td><td>✓</td></tr>
<tr><td>スタックオーバーフロープロテクション</td><td>✘</td><td>✓</td></tr>
<tr><td>main関数前の初期化コード実行</td><td>✘</td><td>✓</td></tr>
<tr><td>libstdの利用</td><td>✘</td><td>✓</td></tr>
<tr><td>libcoreの利用</td><td>✓</td><td>✓</td></tr>
<tr><td>ファームウェア、カーネル、ブートローダーのコードを書く</td><td>✓</td><td>✘</td></tr>
</tbody></table>
<p>* <code>alloc</code>クレートを使い、[alloc-cortex-m]のような適切なアロケータを使った場合のみ</p>
<p>** <code>collections</code>クレートを使い、グローバルなデフォルトアロケータを設定した場合のみ</p>
<!-- 
## See Also
* [FAQ](https://www.rust-lang.org/en-US/faq.html#does-rust-work-without-the-standard-library)
* [RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md)
 -->
<h2><a class="header" href="#参照" id="参照">参照</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/en-US/faq.html#does-rust-work-without-the-standard-library">FAQ</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md">RFC-1184</a></li>
</ul>
<!-- # Tooling -->
<h1><a class="header" href="#ツール" id="ツール">ツール</a></h1>
<!-- 
Dealing with microcontrollers involves using several different tools as we'll be
dealing with an architecture different than your laptop's and we'll have to run
and debug programs on a *remote* device.
 -->
<p>マイクロコントローラを扱う際は、いくつかの異なるツールを利用することになります。あなたのノートPCとは異なるアーキテクチャを扱うことになるでしょうし、<em>リモート</em>デバイス上でプログラムを実行しデバッグする必要があります。</p>
<!-- 
We'll use all the tools listed below. Any recent version should work when a
minimum version is not specified, but we have listed the versions we have
tested.
 -->
<p>下記リストのツールを利用します。最小バージョンが指定されていない場合、新しいバージョンであれば機能するはずです。私たちがテストしたバージョンをリストに示しています。</p>
<!-- 
- Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation
  support.
- [`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4
- [`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0
- OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0
- GDB with ARM support. Version 7.12 or newer highly recommended. Tested
  versions: 7.10, 7.11, 7.12 and 8.1
- [OPTIONAL] `git` OR
  [`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate). If you
  have neither installed then don't worry about installing either.
 -->
<ul>
<li>ARM Cortex-Mコンパイルサポートを追加したRust 1.31、1.31-beta以上のツールチェイン。</li>
<li><a href="https://github.com/rust-embedded/cargo-binutils"><code>cargo-binutils</code></a> ~0.1.4</li>
<li><a href="https://www.qemu.org/"><code>qemu-system-arm</code></a>。テストしたバージョン: 3.0.0</li>
<li>OpenOCD &gt;=0.8.テストしたバージョン: v0.9.0とv0.10.0</li>
<li>ARMサポートのGDB。バージョン7.12以上を強く推奨。テストしたバージョン: 7.10、7.11、7.12、8.1</li>
<li>[任意] <code>git</code>または<a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code></a>。どちらもインストールしていないのであれば、どちらをインストールしてもかまいません。</li>
</ul>
<!-- 
The text below explains why we are using these tools. Installation instructions
can be found on the next page.
 -->
<p>下記に、なぜこれらのツールを利用するのか、を説明します。インストール方法は、次のページにあります。</p>
<!-- ## `cargo-generate` OR `git` -->
<h2><a class="header" href="#cargo-generateかgit" id="cargo-generateかgit"><code>cargo-generate</code>か<code>git</code></a></h2>
<!-- 
Bare metal programs are non-standard (`no_std`) Rust programs that require some
fiddling with the linking process to get the memory layout of the program
right. All this requires unusual files (like linker scripts) and unusual
settings (like linker flags). We have packaged all that for you in a template
so that you only need to fill in the blanks such as the project name and the
characteristics of your target hardware.
 -->
<p>ベアメタルプログラムは、非標準 (<code>no_std</code>)なRustプログラムであり、プログラムのメモリレイアウトを正しくするために、リンクプロセスをいじる必要があります。
これには、独特なファイル(リンカスクリプトなど)と設定(リンカフラグ)が必要です。
プロジェクト名やターゲットハードウェアの特徴などを、空白に入力するだけで済むように、テンプレートを用意しています。</p>
<!-- 
Our template is compatible with `cargo-generate`: a Cargo subcommand for
creating new Cargo projects from templates. You can also download the
template using `git`, `curl`, `wget`, or your web browser.
 -->
<p>このテンプレートは、<code>cargo-generate</code>との互換性があります。<code>cargo-generate</code>は、テンプレートからCargoプロジェクトを作成するためのCargoのサブコマンドです。
このテンプレートは、<code>git</code>や<code>curl</code>、<code>wget</code>、ウェブブラウザを使ってダウンロードできます。</p>
<h2><a class="header" href="#cargo-binutils" id="cargo-binutils"><code>cargo-binutils</code></a></h2>
<!-- 
`cargo-binutils` is a collection of Cargo subcommands that make it easy to use
the LLVM tools that are shipped with the Rust toolchain. These tools include the
LLVM versions of `objdump`, `nm` and `size` and are used for inspecting
binaries.
 -->
<p><code>cargo-binutils</code>は、Rustツールチェインとともに配布されているLLVMツールを簡単に使うためのCargoサブコマンド一式です。
これらのツールは、LLVMの<code>objdump</code>や<code>nm</code>、<code>size</code>を含んでおり、バイナリを調査するために使われます。</p>
<!-- 
The advantage of using these tools over GNU binutils is that (a) installing the
LLVM tools is the same one-command installation (`rustup component add
llvm-tools-preview`) regardless of your OS and (b) tools like `objdump` support
all the architectures that `rustc` supports -- from ARM to x86_64 -- because
they both share the same LLVM backend.
 -->
<p>GNU binutilsではなく、これらのツールを利用する利点は次の通りです。
(a) LLVMツールのインストールは、OSに関わらず、共通のコマンド1つ(<code>rustup component add llvm-tools-preview</code>)で済みます。
(b) <code>objdump</code>などのツールは、<code>rustc</code>がサポートする全てのアーキテクチャ(ARMからx86_64まで)をサポートします。これは、同じLLVMバックエンドを共有しているためです。</p>
<h2><a class="header" href="#qemu-system-arm" id="qemu-system-arm"><code>qemu-system-arm</code></a></h2>
<!-- 
QEMU is an emulator. In this case we use the variant that can fully emulate ARM
systems. We use QEMU to run embedded programs on the host. Thanks to this you
can follow some parts of this book even if you don't have any hardware with you!
 -->
<p>QEMUはエミュレータです。今回は、ARMシステムを完全にエミュレートできるものを使います。
私たちは、ホスト上で組込みプログラムを実行するためにQEMUを利用します。
このおかげで、ハードウェアを持っていなくても、この本のいくつかの部分を試すことができます。</p>
<h2><a class="header" href="#gdb" id="gdb">GDB</a></h2>
<!-- 
A debugger is a very important component of embedded development as you may not
always have the luxury to log stuff to the host console. In some cases, you may
not have LEDs to blink on your hardware!
 -->
<p>デバッガは、組込み開発で非常に重要です。ホストコンソールにログを記録するような贅沢は、必ずしもできないからです。
場合によっては、ハードウェア上のLEDが点滅しないことがあります。</p>
<!-- 
In general, LLDB works as well as GDB when it comes to debugging but we haven't
found an LLDB counterpart to GDB's `load` command, which uploads the program to
the target hardware, so currently we recommend that you use GDB.
 -->
<p>通常のデバッグ機能に関しては、LLDBはGDBと同様に機能します。しかし、ターゲットハードウェアにプログラムをアップロードするGDBの<code>load</code>コマンド相当のものは、LLDBにはありません。
したがって、現在はGDBの使用をお勧めします。</p>
<h2><a class="header" href="#openocd" id="openocd">OpenOCD</a></h2>
<!-- 
GDB isn't able to communicate directly with the ST-Link debugging hardware on
your STM32F3DISCOVERY development board. It needs a translator and the Open
On-Chip Debugger, OpenOCD, is that translator. OpenOCD is a program that runs
on your laptop/PC and translates between GDB's TCP/IP based remote debug
protocol and ST-Link's USB based protocol.
 -->
<p>GDBは、STM32F3DISCOVERY開発ボード上のST-Linkデバッグハードウェアと直接通信することはできません。
翻訳プログラムが必要であり、OpenOCD (Open On-Chip Debugger)がその翻訳プログラムです。
OpenOCDは、ノートPCやPC上で動作するプログラムで、GDBのTCP/IPベースのリモートデバッグプロトコルとST-LinkのUSBベースのプロトコルとを翻訳します。</p>
<!-- 
OpenOCD also performs other important work as part of its translation for the
debugging of the ARM Cortex-M based microcontroller on your STM32F3DISCOVERY
development board:
-->
<p>STM32F3DISCOVERY開発ボード上のARM Cortex-Mベースのマイクロコントローラをデバッグするため、OpenOCDは、翻訳の一環として、他の重要な役割も果たします。</p>
<!-- 
* It knows how to interact with the memory mapped registers used by the ARM
  CoreSight debug peripheral. It is these CoreSight registers that allow for:
  * Breakpoint/Watchpoint manipulation
  * Reading and writing of the CPU registers
  * Detecting when the CPU has been halted for a debug event
  * Continuing CPU execution after a debug event has been encountered
  * etc.
* It also knows how to erase and write to the microcontroller's FLASH
 -->
<ul>
<li>ARM CoreSightデバッグ周辺機器で使用されるメモリマップドレジスタとの通信方法を知っています。CoreSightレジスタは、次のことをできるようにします。
<ul>
<li>ブレイクポイント/ウォッチポイント操作</li>
<li>CPUレジスタの読み込みと書き込み</li>
<li>CPUがデバッグイベントのために停止したことの検出</li>
<li>デバッグイベントが発生した後のCPU実行の継続</li>
<li>他</li>
</ul>
</li>
<li>マイクロコントローラのフラッシュの消去と書き込み方法を知っています。</li>
</ul>
<!-- # Installing the tools -->
<h1><a class="header" href="#ツールのインストール" id="ツールのインストール">ツールのインストール</a></h1>
<!-- This page contains OS-agnostic installation instructions for a few of the tools: -->
<p>このページには、いくつかのツールのOSに依存しないインストール手順を掲載します。</p>
<!-- ### Rust Toolchain -->
<h3><a class="header" href="#rustツールチェイン" id="rustツールチェイン">Rustツールチェイン</a></h3>
<!-- Install rustup by following the instructions at [https://rustup.rs](https://rustup.rs). -->
<p><a href="https://rustup.rs">https://rustup.rs</a>の手順に従って、rustupをインストールします。</p>
<!-- 
**NOTE** Make sure you have a compiler version equal to or newer than `1.31`. `rustc
-V` should return a date newer than the one shown below.
 -->
<p><strong>注意</strong> コンパイラのバージョンが<code>1.31</code>以上であることを確認して下さい。<code>rustc -v</code>は下記に示す日付より新しい日付を返すべきです。</p>
<pre><code class="language-console">$ rustc -V
rustc 1.31.1 (b6c32da9b 2018-12-18)
</code></pre>
<!-- 
For bandwidth and disk usage concerns the default installation only supports
native compilation. To add cross compilation support for the ARM Cortex-M
architecture install the following compilation targets.
 -->
<p>バンド幅とディスク使用量に関する懸念から、デフォルトインストールではネイティブコンパイルのみをサポートします。
ARM Cortex-Mアーキテクチャのクロスコンパイラを追加するために、下記のコンパイルターゲットをインストールします。</p>
<pre><code class="language-console">$ rustup target add thumbv6m-none-eabi thumbv7m-none-eabi thumbv7em-none-eabi thumbv7em-none-eabihf
</code></pre>
<h3><a class="header" href="#cargo-binutils-1" id="cargo-binutils-1"><code>cargo-binutils</code></a></h3>
<pre><code class="language-console">$ cargo install cargo-binutils

$ rustup component add llvm-tools-preview
</code></pre>
<!-- ### OS-Specific Instructions -->
<h3><a class="header" href="#os特有の手順" id="os特有の手順">OS特有の手順</a></h3>
<!-- Now follow the instructions specific to the OS you are using: -->
<p>使用しているOSに特有の手順に従って下さい。</p>
<ul>
<li><a href="intro/install/linux.html">Linux</a></li>
<li><a href="intro/install/windows.html">Windows</a></li>
<li><a href="intro/install/macos.html">macOS</a></li>
</ul>
<h1><a class="header" href="#linux" id="linux">Linux</a></h1>
<!-- Here are the installation commands for a few Linux distributions. -->
<p>いくつかのLinuxディストリビューションのインストールコマンドを示します。</p>
<h2><a class="header" href="#packages" id="packages">Packages</a></h2>
<!-- - Ubuntu 18.04 or newer / Debian stretch or newer -->
<ul>
<li>Ubuntu 18.04以上 / Debian stretch以降</li>
</ul>
<!-- 
> **NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>gdb-multiarch</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- QEMU 2.8.1 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.11.1 -->
<pre><code class="language-console">$ sudo apt install \
  gdb-multiarch \
  openocd \
  qemu-system-arm
</code></pre>
<!-- - Ubuntu 14.04 and 16.04 -->
<ul>
<li>Ubuntu 14.04と16.04</li>
</ul>
<!-- 
> **NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>arm-none-eabi-gdb</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.7.0 (?) -->
<!-- QEMU 2.0.0 (?) -->
<pre><code class="language-console">$ sudo apt install \
  gdb-arm-none-eabi \
  openocd \
  qemu-system-arm
</code></pre>
<!-- - Fedora 27 or newer -->
<ul>
<li>Fedora 27以上</li>
</ul>
<!-- 
> **NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>arm-none-eabi-gdb</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<!-- Fedora 27 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.10.2 -->
<pre><code class="language-console">$ sudo dnf install \
  arm-none-eabi-gdb \
  openocd \
  qemu-system-arm
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<!-- 
> **NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM
> Cortex-M programs
 -->
<p><strong>注記</strong> <code>arm-none-eabi-gdb</code>は、ARM Cortex-Mプログラムをデバッグするために使用するGDBのコマンドです。</p>
<pre><code class="language-console">$ sudo pacman -S \
  arm-none-eabi-gdb \
  qemu-arch-extra

$ # install openocd from the AUR -- https://aur.archlinux.org/packages/openocd/
</code></pre>
<!-- ## udev rules -->
<h2><a class="header" href="#udevルール" id="udevルール">udevルール</a></h2>
<!-- This rule lets you use OpenOCD with the Discovery board without root privilege. -->
<p>このルールにより、ルート権限なしで、OpenOCDをDiscoveryボードに対して使えるようにします。</p>
<!-- Create this file in `/etc/udev/rules.d` with the contents shown below. -->
<p>下記の内容で、<code>/etc/udev/rules.d</code>ディレクトリにファイルを作成します。</p>
<pre><code class="language-console">$ cat /etc/udev/rules.d/70-st-link.rules
</code></pre>
<pre><code class="language-text"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;3748&quot;, TAG+=&quot;uaccess&quot;

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}==&quot;0483&quot;, ATTRS{idProduct}==&quot;374b&quot;, TAG+=&quot;uaccess&quot;
</code></pre>
<!-- Then reload all the udev rules with: -->
<p>その後、全てのudevルールをリロードします。</p>
<pre><code class="language-console">$ sudo udevadm control --reload-rules
</code></pre>
<!-- If you had the board plugged to your laptop, unplug it and then plug it again. -->
<p>既にボードをノートPCに接続している場合、一度抜いてから、もう一度接続します。</p>
<!-- You can check the permissions by running these commands: -->
<p>これらのコマンド実行することで、パーミッションを確認できます。</p>
<pre><code class="language-console">$ lsusb
(..)
Bus 001 Device 018: ID 0483:374b STMicroelectronics ST-LINK/V2.1
(..)
</code></pre>
<!-- 
Take note of the bus and device numbers. Use those numbers in the following
command:
 -->
<p>バス番号とデバイス番号をメモします。それらの番号を、次のコマンドで使用します。</p>
<pre><code class="language-console">$ # the format of the path is /dev/bus/usb/&lt;bus&gt;/&lt;device&gt;
$ ls -l /dev/bus/usb/001/018
crw-------+ 1 root root 189, 17 Sep 13 12:34 /dev/bus/usb/001/018
$ getfacl /dev/bus/usb/001/018 | grep user
user::rw-
user:you:rw-
</code></pre>
<!-- 
The `+` appended to permissions indicates the existence of an extended
permission. The `getfacl` command tells the user `you` can make use of
this device.
 -->
<p>パーミッションに追加された<code>+</code>は、パーミッションが拡張されたことを意味しています。</p>
<!-- Now, go to the [next section]. -->
<p>それでは、<a href="intro/install/verify.html">次のセクション</a>に進んで下さい。</p>
<!-- [next section]: verify.md -->
<h1><a class="header" href="#macos" id="macos">macOS</a></h1>
<!-- All the tools can be install using [Homebrew]: -->
<p>全てのツールは、<a href="http://brew.sh/">Homebrew</a>を使ってインストールできます。</p>
<pre><code class="language-console">$ # GDB
$ brew tap armmbed/formulae
$ brew install armmbed/formulae/arm-none-eabi-gcc

$ # OpenOCD
$ brew install openocd

$ # QEMU
$ brew install qemu
</code></pre>
<!-- That's all! Go to the [next section]. -->
<p>以上です！<a href="intro/install/verify.html">次のセクション</a>に進んで下さい。</p>
<!-- [next section]: verify.md -->
<h1><a class="header" href="#windows" id="windows">Windows</a></h1>
<h2><a class="header" href="#arm-none-eabi-gdb" id="arm-none-eabi-gdb"><code>arm-none-eabi-gdb</code></a></h2>
<!-- 
ARM provides `.exe` installers for Windows. Grab one from [here][gcc], and follow the instructions.
Just before the installation process finishes tick/select the "Add path to environment variable"
option. Then verify that the tools are in your `%PATH%`:
 -->
<p>ARMはWindows向けに<code>.exe</code>インストーラを提供しています。<a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">here</a>から1つを入手して、手順に従って下さい。
インストールプロセスが終了する直前に&quot;環境変数にパスを追加&quot;オプションを選択します。
その後、ツールが<code>%PATH%</code>にあることを確認します。</p>
<pre><code class="language-console">$ arm-none-eabi-gdb -v
GNU gdb (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 8.1.0.20180315-git
(..)
</code></pre>
<h2><a class="header" href="#openocd-1" id="openocd-1">OpenOCD</a></h2>
<p>There's no official binary release of OpenOCD for Windows but there are unofficial releases
available <a href="https://github.com/gnu-mcu-eclipse/openocd/releases">here</a>. Grab the 0.10.x zipfile and extract it somewhere on your drive (I
recommend <code>C:\OpenOCD</code> but with the drive letter that makes sense to you) then update your <code>%PATH%</code>
environment variable to include the following path: <code>C:\OpenOCD\bin</code> (or the path that you used
before).</p>
<p>Windows用のOpenOCDの公式バイナリはありませんが、<a href="https://github.com/gnu-mcu-eclipse/openocd/releases">こちら</a>の非公式なリリースが利用可能です。
0.10.xのzipファイルを入手し、ハードディスクのどこかに展開して下さい(<code>C:\OpenOCD</code>をお勧めしますが、あなたが分かるドライブ名を使用してください)。
その後、<code>%PATH%</code>環境変数が<code>C:\OpenOCD\bin</code>(もしくはあなたがOpenOCDのzipファイルを展開したパス)を含むように更新します。</p>
<!-- Verify that OpenOCD is in your `%PATH%` with: -->
<p>OpenOCDが<code>%PATH%</code>にあることを確認します。</p>
<pre><code class="language-console">$ openocd -v
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<h2><a class="header" href="#qemu" id="qemu">QEMU</a></h2>
<!-- Grab QEMU from [the official website][qemu]. -->
<p><a href="https://www.qemu.org/download/#windows">QEMU公式サイト</a>からQEMUを入手します。</p>
<!-- ## ST-LINK USB driver -->
<h2><a class="header" href="#st-link-usbドライバ" id="st-link-usbドライバ">ST-LINK USBドライバ</a></h2>
<!-- 
You'll also need to install [this USB driver] or OpenOCD won't work. Follow the installer
instructions and make sure you install the right version (32-bit or 64-bit) of the driver.
 -->
<p><a href="http://www.st.com/en/embedded-software/stsw-link009.html">USBドライバ</a>もインストールする必要があります。そうでなければOpenOCDは動きません。インストーラの手順に従って下さい。
そして、正しいドライバのバージョン(32ビットか64ビット)をインストールすることを確認して下さい。</p>
<!-- That's all! Go to the [next section]. -->
<p>以上です！<a href="intro/install/verify.html">次のセクション</a>に進んで下さい。</p>
<!-- [next section]: verify.md -->
<!-- # Verify Installation -->
<h1><a class="header" href="#インストールの確認" id="インストールの確認">インストールの確認</a></h1>
<!-- 
In this section we check that some of the required tools / drivers have been
correctly installed and configured.
 -->
<p>このセクションでは、必要となるツールとドライバが正しくインストールされ、設定されていることを確認します。</p>
<!-- 
Connect your laptop / PC to the discovery board using a micro USB cable. The
discovery board has two USB connectors; use the one labeled "USB ST-LINK" that
sits on the center of the edge of the board.
 -->
<p>マイクロUSBケーブルを使って、ノートPC / PCをdiscoveryボードに接続して下さい。
discoveryボードは2つのUSBコネクタを搭載しています。
ボード端の中央にある&quot;USB ST-LINK&quot;とラベルが付いたものを使用して下さい。</p>
<!-- 
Also check that the ST-LINK header is populated. See the picture below; the
ST-LINK header is circled in red.
 -->
<p>ST-LINKヘッダが装着されていることも確認します。下の写真の赤丸で囲った部分がST-LINKヘッダです。</p>
<p align="center">
<img title="Connected discovery board" src="intro/install/../../assets/verify.jpeg">
</p>
<!-- 
Now run the following command:
 -->
<p>それでは、次のコマンドを実行して下さい。</p>
<pre><code class="language-console">$ openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg
</code></pre>
<!-- You should get the following output and the program should block the console: -->
<p>次の出力が得られ、プログラムはコンソールをブロックするはずです。</p>
<pre><code class="language-text">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919881
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<!-- 
The contents may not match exactly but you should get the last line about
breakpoints and watchpoints. If you got it then terminate the OpenOCD process
and move to the [next section].
 -->
<p>確認作業とは直接関係しませんが、ブレイクポイントとウォッチポイントに関する最後の行を取得したはずです。
取得できた場合、OpenOCDプロセスを停止し、<a href="intro/install/../hardware.html">次のセクション</a>へ進んで下さい。</p>
<!-- [next section]: ../hardware.md -->
<!-- If you didn't get the "breakpoints" line then try the following command. -->
<p>&quot;breakpoints&quot;の行が取得できなかった場合、次のコマンドを試してく下さい。</p>
<pre><code class="language-console">$ openocd -f interface/stlink-v2.cfg -f target/stm32f3x.cfg
</code></pre>
<!-- 
If that command works that means you got an old hardware revision of the
discovery board. That won't be a problem but commit that fact to memory as
you'll need to configure things a bit differently later on. You can move to the
[next section].
 -->
<p>このコマンドが機能した場合、古いハードウェアリビジョンのdiscoveryボードを入手したことを意味します。
これは問題になりませんが、後で少し設定を変える必要があるので、そのことを覚えておいて下さい。
<a href="intro/install/../hardware.html">次のセクション</a>に進むことができます。</p>
<!-- 
If neither command worked as a normal user then try to run them with root
permission (e.g. `sudo openocd ..`). If the commands do work with root
permission then check that the [udev rules] has been correctly set.
 -->
<p>どちらのコマンドも通常ユーザとしてうまく動かなかった場合、rootパーミッションで実行してみて下さい(例えば、<code>sudo openocd ..</code>)。
コマンドがrootパーミッションで機能した場合、<a href="intro/install/linux.html#udev-rules">udevルール</a>が正しく設定されているか確認して下さい。</p>
<!-- [udev rules]: linux.md#udev-rules -->
<!-- 
If you have reached this point and OpenOCD is not working please open [an issue]
and we'll help you out!
 -->
<p>ここまで到着していまい、OpenOCDが動いていないならば、<a href="https://github.com/rust-embedded/book/issues">issue</a>を作って下さい。私たちがあなたを支援します。</p>
<!-- [an issue]: https://github.com/rust-embedded/book/issues -->
<!-- # Meet Your Hardware -->
<h1><a class="header" href="#ハードウェアとの出会い" id="ハードウェアとの出会い">ハードウェアとの出会い</a></h1>
<!-- Let's get familiar with the hardware we'll be working with. -->
<p>これから作業するハードウェアに詳しくなりましょう。</p>
<!-- ## STM32F3DISCOVERY (the "F3") -->
<h2><a class="header" href="#stm32f3discovery-f3" id="stm32f3discovery-f3">STM32F3DISCOVERY (&quot;F3&quot;)</a></h2>
<p align="center">
<img title="F3" src="intro/../assets/f3.jpg">
</p>
<!-- We'll refer to this board as "F3" throughout this book. -->
<p>私たちは、本書内でこのボードを&quot;F3&quot;と呼びます。</p>
<!-- What does this board contain? -->
<p>このボードには何が搭載されているか見てみましょう。</p>
<!-- 
- A STM32F303VCT6 microcontroller. This microcontroller has
  - A single-core ARM Cortex-M4F processor with hardware support for single-precision floating point
    operations and a maximum clock frequency of 72 MHz.

  - 256 KiB of "Flash" memory. (1 KiB = 10**24** bytes)

  - 48 KiB of RAM.

  - many "peripherals": timers, GPIO, I2C, SPI, USART, etc.

  - lots of "pins" that are exposed in the two lateral "headers".

  - **IMPORTANT** This microcontroller operates at (around) 3.3V.
 -->
<ul>
<li>STM32F303VCT6マイクロコントローラが1つ。このマイクロコントローラは、次のものを搭載しています。
<ul>
<li>
<p>単精度浮動小数点演算をハードウェアサポートし、最大72MHzのクロック周波数で動作するシングルコアのARM Cortex-M4Fプロセッサ</p>
</li>
<li>
<p>256 KiBの&quot;フラッシュ&quot;メモリ (1 KiB = 10<strong>24</strong> bytes)</p>
</li>
<li>
<p>48 KiBのRAM</p>
</li>
<li>
<p>多くの&quot;ペリフェラル&quot;: タイマ、GPIO、I2C、SPI、USART、他</p>
</li>
<li>
<p>両側面の&quot;ヘッダ&quot;に配置された多数の&quot;ピン&quot;</p>
</li>
<li>
<p><strong>重要</strong> このマイクロコントローラは、約3.3ボルトで動作します。</p>
</li>
</ul>
</li>
</ul>
<!-- 
- An [accelerometer] and a [magnetometer][] (in a single package).

[accelerometer]: https://en.wikipedia.org/wiki/Accelerometer
[magnetometer]: https://en.wikipedia.org/wiki/Magnetometer
 -->
<ul>
<li><a href="https://en.wikipedia.org/wiki/Accelerometer">加速度センサ</a>と<a href="https://en.wikipedia.org/wiki/Magnetometer">磁気センサ</a>が1つずつ (1つのパッケージにまとめられています)</li>
</ul>
<!-- 
- A [gyroscope].

[gyroscope]: https://en.wikipedia.org/wiki/Gyroscope
 -->
<ul>
<li><a href="https://en.wikipedia.org/wiki/Gyroscope">ジャイロセンサ</a>が1つ</li>
</ul>
<!-- - 8 user LEDs arranged in the shape of a compass -->
<ul>
<li>円形に配置された8個のユーザLED</li>
</ul>
<!-- 
- A second microcontroller: a STM32F103CBT. This microcontroller is actually part of an on-board
  programmer and debugger named ST-LINK and is connected to the USB port named "USB ST-LINK".
 -->
<ul>
<li>第2のマイクロコントローラ: STM32F103CBT。このマイクロコントローラは、実際には、ST-LINKというオンボードプログラマおよびデバッガの一部であり、&quot;USB ST-LINK&quot;という名前のUSBポートに接続されています。</li>
</ul>
<!-- 
- There's a second USB port, labeled "USB USER" that is connected to the main microcontroller, the
  STM32F303VCT6, and can be used in applications.
 -->
<ul>
<li>&quot;USB USER&quot;というラベルが付いている第2のUSBポート。このUSBポートは、メインマイクロコントローラ (STM32F303VCT6)に接続されており、アプリケーションで利用できます。</li>
</ul>
<!-- # Getting Started -->
<h1><a class="header" href="#入門" id="入門">入門</a></h1>
<!-- 
In this section we'll walk you through the process of writing, building,
flashing and debugging embedded programs. You will be able to try most of the
examples without any special hardware as we will show you the basics using
QEMU, a popular open-source hardware emulator. The only section where hardware
is required is, naturally enough, the [Hardware](./hardware.md) section,
where we use OpenOCD to program an [STM32F3DISCOVERY].
 -->
<p>このセクションでは、組込みプログラムを書いて、ビルドして、フラッシュに書き込み、デバッグする、という一連のプロセスを説明します。
ほとんどの例を特別なハードウェアなしで試すことができます。有名なオープンソースハードウェアエミュレータであるQEMUを使うからです。
ハードウェアが必要となる唯一のセクションは、当然ながら、OpenOCDを使って<a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>にプログラムする<a href="start/./hardware.html">Hardware</a>セクションです。</p>
<h1><a class="header" href="#qemu-1" id="qemu-1">QEMU</a></h1>
<!-- 
We'll start writing a program for the [LM3S6965], a Cortex-M3 microcontroller.
We have chosen this as our initial target because it can be emulated using QEMU
so you don't need to fiddle with hardware in this section and we can focus on
the tooling and the development process.
 -->
<p>Cortex-M3マイクロコントローラの<a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>用にプログラムを書くところから始めましょう。
このLM3S6965を最初のターゲットとして選んだ理由は、QEMUを使ってエミュレーションできるからです。
このセクションでは、ハードウェアをいじる必要がなく、ツールと開発プロセスに集中できます。</p>
<!-- ## A non standard Rust program -->
<h2><a class="header" href="#標準ライブラリを使わないrustプログラム" id="標準ライブラリを使わないrustプログラム">標準ライブラリを使わないRustプログラム</a></h2>
<!-- 
We'll use the [`cortex-m-quickstart`] project template so go generate a new
project from it.
 -->
<p><a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a>プロジェクトテンプレートを使用し、新しいプロジェクトを生成します。</p>
<!-- - Using `cargo-generate` -->
<ul>
<li><code>cargo-generate</code>を利用する場合</li>
</ul>
<pre><code class="language-console">$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
 Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app

$ cd app
</code></pre>
<!-- - Using `git` -->
<ul>
<li><code>git</code>を利用する場合</li>
</ul>
<!-- Clone the repository -->
<p>レポジトリをクローンします。</p>
<pre><code class="language-console">$ git clone https://github.com/rust-embedded/cortex-m-quickstart app

$ cd app
</code></pre>
<!-- And then fill in the placeholders in the `Cargo.toml` file -->
<p><code>Cargo.toml</code>のプレースホルダを埋めます。</p>
<pre><code class="language-console">$ cat Cargo.toml
</code></pre>
<pre><code class="language-toml">[package]
authors = [&quot;{{authors}}&quot;] # &quot;{{authors}}&quot; -&gt; &quot;John Smith&quot;
edition = &quot;2018&quot;
name = &quot;{{project-name}}&quot; # &quot;{{project-name}}&quot; -&gt; &quot;awesome-app&quot;
version = &quot;0.1.0&quot;

# ..

[[bin]]
name = &quot;{{project-name}}&quot; # &quot;{{project-name}}&quot; -&gt; &quot;awesome-app&quot;
test = false
bench = false
</code></pre>
<!-- - Using neither -->
<ul>
<li>どちらも使わない場合</li>
</ul>
<!-- Grab the latest snapshot of the `cortex-m-quickstart` template and extract it. -->
<p><code>cortex-m-quickstart</code>テンプレートの最新スナップショットを入手し、展開します。</p>
<!-- Using the command line: -->
<p>コマンドラインを利用する場合:</p>
<pre><code class="language-console">$ # 注記 tar形式でも入手可能です: archive/master.tar.gz
$ curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master.zip

$ unzip master.zip

$ mv cortex-m-quickstart-master app

$ cd app
</code></pre>
<!-- 
OR you can browse to [`cortex-m-quickstart`], click the green "Clone or
download" button and then click "Download ZIP".
 -->
<p>もしくは、<a href="https://github.com/rust-embedded/cortex-m-quickstart"><code>cortex-m-quickstart</code></a>をウェブブラウザで開いて、緑色の「Clone or download」ボタンをクリックして、
「Download ZIP」をクリックします。</p>
<!-- 
Then fill in the placeholders in the `Cargo.toml` file as done in the second
part of the "Using `git`" version.
 -->
<p>次に、<code>Cargo.toml</code>ファイルのプレースホルダを「<code>git</code>を利用する場合」の2つ目のパートにある通り埋めます。</p>
<!-- 
**IMPORTANT** We'll use the name "app" for the project name in this tutorial.
Whenever you see the word "app" you should replace it with the name you selected
for your project. Or, you could also name your project "app" and avoid the
substitutions.
 -->
<p><strong>重要</strong> このチュートリアルでは、「app」という名前をプロジェクト名に使います。
「app」という単語が出てきた場合、それをあなたのプロジェクトにつけた名前に置き替えなければなりません。
または、プロジェクトに「app」という名前をつけると、置き替える必要がなくなります。</p>
<!-- For convenience here's the source code of `src/main.rs`: -->
<p>これは、<code>src/main.rs</code>のソースコードです。</p>
<pre><code class="language-console">$ cat src/main.rs
</code></pre>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

<span class="boring">// pick a panicking behavior
</span>// パニック発生時の挙動を選びます
<span class="boring">// extern crate panic_halt; // you can put a breakpoint on `rust_begin_unwind` to catch panics
</span>extern crate panic_halt; // パニックをキャッチするため、`rust_begin_unwind`にブレイクポイントを設定できます
<span class="boring">// extern crate panic_abort; // requires nightly
</span>// extern crate panic_abort; // nightlyが必要です
<span class="boring">// extern crate panic_itm; // logs messages over ITM; requires ITM support
</span>// extern crate panic_itm; // ITMを介してメッセージをログ出力します; ITMサポートが必要です
<span class="boring">// extern crate panic_semihosting; // logs messages to the host stderr; requires a debugger
</span>// extern crate panic_semihosting; // ホストの標準エラーにメッセージをログ出力します; デバッガが必要です。

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    loop {
<span class="boring">        // your code goes here
</span>        // あなたのコードはここに書きます
    }
}
</code></pre></pre>
<!-- 
This program is a bit different from a standard Rust program so let's take a
closer look.
 -->
<p>このプログラムは、標準的なRustプログラムとは少し異なりますので、もう少し詳しく見てみましょう。</p>
<!-- 
`#![no_std]` indicates that this program will *not* link to the standard crate,
`std`. Instead it will link to its subset: the `core` crate.
 -->
<p><code>#![no_std]</code>はこのプログラムが、標準クレートである<code>std</code>にリンク<em>しない</em>ことを意味します。
代わりに、そのサブセットである<code>core</code>クレートにリンクします。</p>
<!--
`#![no_main]` indicates that this program won't use the standard `main`
interface that most Rust programs use. The main (no pun intended) reason to go
with `no_main` is that using the `main` interface in `no_std` context requires
nightly.
-->
<p><code>#![no_main]</code>は、ほとんどのRustプログラムが使用する標準の<code>main</code>インタフェースを、
このプログラムでは使用しないことを示します。
<code>no_main</code>を利用する主な理由は、<code>no_std</code>の状況で<code>main</code>インタフェースを使用するにはnightlyが必要だからです。</p>
<!-- 
`extern crate panic_halt;`. This crate provides a `panic_handler` that defines
the panicking behavior of the program. More on this later on.
 -->
<p><code>extern crate panic_halt;</code>。このクレートは、プログラムのパニック発生時の挙動を定義する<code>panic_handler</code>を提供します。
後ほど、より詳しく説明します。</p>
<!--
[`#[entry]`] is an attribute provided by the [`cortex-m-rt`] crate that's used
to mark the entry point of the program. As we are not using the standard `main`
interface we need another way to indicate the entry point of the program and
that'd be `#[entry]`.
-->
<p>[<code>#[entry]</code>]は、<a href="https://crates.io/crates/cortex-m-rt"><code>cortex-m-rt</code></a>クレートが提供するアトリビュートで、プログラムのエントリポイントを示すために使用します。
標準の<code>main</code>インタフェースを使用しないので、プログラムのエントリポイントを示す別の方法が必要です。それが、<code>#[entry]</code>です。</p>
<p>[<code>#[entry]</code>]: https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html</p>
<!--
`fn main() -> !`. Our program will be the *only* process running on the target
hardware so we don't want it to end! We use a divergent function (the `-> !`
bit in the function signature) to ensure at compile time that'll be the case.
-->
<p><code>fn main() -&gt; !</code>。ターゲットハードウェア上で動作しているのは私たちのプログラム<em>だけ</em>なので、
終了させたくありません。
コンパイル時、確実にそうなるように、発散する関数を使います（関数シグネチャの<code>-&gt; !</code>部分）。</p>
<!-- ### Cross compiling -->
<h3><a class="header" href="#クロスコンパイル" id="クロスコンパイル">クロスコンパイル</a></h3>
<!--
The next step is to *cross* compile the program for the Cortex-M3 architecture.
That's as simple as running `cargo build --target $TRIPLE` if you know what the
compilation target (`$TRIPLE`) should be. Luckily, the `.cargo/config` in the
template has the answer:
-->
<p>次のステップは、プログラムをCortex-M3アーキテクチャ向けに<em>クロス</em>コンパイルすることです。
これはコンパイルターゲット（<code>$TRIPLE</code>）が何かわかっていれば、<code>cargo build --target $TRIPLE</code>を実行するだけで簡単にできます。
コンパイルターゲットが何かは、テンプレート中の<code>.cargo/config</code>を見ればわかります。</p>
<pre><code class="language-console">$ tail -n6 .cargo/config
</code></pre>
<pre><code class="language-toml">[build]
# 以下のコンパイルターゲットから1つを選びます
# target = &quot;thumbv6m-none-eabi&quot;    # Cortex-M0およびCortex-M0+
target = &quot;thumbv7m-none-eabi&quot;    # Cortex-M3
# target = &quot;thumbv7em-none-eabi&quot;   # Cortex-M4およびCortex-M7 (no FPU)
# target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4FおよびCortex-M7F (with FPU)
</code></pre>
<!-- 
To cross compile for the Cortex-M3 architecture we have to use
`thumbv7m-none-eabi`. This compilation target has been set as the default so the
two commands below do the same:
 -->
<p>Cortex-M3アーキテクチャ向けにクロスコンパイルするためには、<code>thumbv7m-none-eabi</code>を使う必要があります。
このコンパイルターゲットは、デフォルトとして設定されているため、下記2つのコマンドは同じ意味になります。</p>
<pre><code class="language-console">$ cargo build --target thumbv7m-none-eabi

$ cargo build
</code></pre>
<!-- ### Inspecting -->
<h3><a class="header" href="#確認" id="確認">確認</a></h3>
<!-- 
Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/app`. We
can inspect it using `cargo-binutils`.
 -->
<p>今、<code>target/thumbv7m-none-eabi/debug/app</code>に、非ネイティブなバイナリがあります。
<code>cargo-binutils</code>を使って、このバイナリを確認することができます。</p>
<!-- 
With `cargo-readobj` we can print the ELF headers to confirm that this is an ARM
binary.
 -->
<p>このバイナリがARMバイナリであることを確かめるために、<code>cargo-readobj</code>でELFヘッダを表示できます。</p>
<pre><code class="language-console">$ # `--bin app`は`target/$TRIPLE/debug/app`のバイナリを確認するためのシンタックスシュガーです
$ # `--bin app`は必要に応じて、バイナリを（再）コンパイルもします

$ cargo readobj --bin app -- -file-headers
</code></pre>
<pre><code class="language-text">ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x405
  Start of program headers:          52 (bytes into file)
  Start of section headers:          153204 (bytes into file)
  Flags:                             0x5000200
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         19
  Section header string table index: 18
</code></pre>
<!-- 
`cargo-size` can print the size of the linker sections of the binary.
 -->
<p><code>cargo-size</code>はバイナリのリンカセクションのサイズを表示できます。</p>
<!-- 
> **NOTE** this output assumes that rust-embedded/cortex-m-rt#111 has been
> merged
 -->
<blockquote>
<p><strong>注記</strong> この出力は、rust-embedded/cortex-m-rt#111がマージされていることを前提とします</p>
</blockquote>
<pre><code class="language-console">$ # 最適化されたバイナリを確認するために`--release`を使います。

$ cargo size --bin app --release -- -A
</code></pre>
<pre><code class="language-text">app  :
section             size        addr
.vector_table       1024         0x0
.text                 92       0x400
.rodata                0       0x45c
.data                  0  0x20000000
.bss                   0  0x20000000
.debug_str          2958         0x0
.debug_loc            19         0x0
.debug_abbrev        567         0x0
.debug_info         4929         0x0
.debug_ranges         40         0x0
.debug_macinfo         1         0x0
.debug_pubnames     2035         0x0
.debug_pubtypes     1892         0x0
.ARM.attributes       46         0x0
.debug_frame         100         0x0
.debug_line          867         0x0
Total              14570
</code></pre>
<!--
> A refresher on ELF linker sections
>
> - `.text` contains the program instructions
> - `.rodata` contains constant values like strings
> - `.data` contains statically allocated variables whose initial values are
>   *not* zero
> - `.bss` also contains statically allocated variables whose initial values
>   *are* zero
> - `.vector_table` is a *non*-standard section that we use to store the vector
>   (interrupt) table
> - `.ARM.attributes` and the `.debug_*` sections contain metadata and will
>   *not* be loaded onto the target when flashing the binary.
-->
<blockquote>
<p>ELFリンカセクションの補足</p>
<ul>
<li><code>.text</code>は、プログラムの実行コードを含んでいます</li>
<li><code>.rodata</code>は、文字列のような定数を含んでいます</li>
<li><code>.data</code>は、初期値が0<em>ではない</em>静的に割り当てられた変数が格納されています</li>
<li><code>.bss</code>も静的に割り当てられた変数が格納されますが、その<em>初期値は0です</em></li>
<li><code>.vector_table</code>は、<em>非</em>標準のセクションです。（割り込み）ベクタテーブルを格納するために使用します</li>
<li><code>.ARM.attributes</code>と<code>.debug_*</code>セクションはメタデータを含んでおり、バイナリをフラッシュに書き込む際、
ターゲットボード上にロード<em>されません</em></li>
</ul>
</blockquote>
<!--
**IMPORTANT**: ELF files contain metadata like debug information so their *size
on disk* does *not* accurately reflect the space the program will occupy when
flashed on a device. *Always* use `cargo-size` to check how big a binary really
is.
-->
<p><strong>重要</strong>: ELFファイルは、デバッグ情報といったメタデータを含んでいるため、<em>そのディスク上のサイズ</em>は、
プログラムがデバイスに書き込まれた時に専有するスペースを正確に反映して<em>いません</em>。
実際のバイナリサイズを確認するために、<em>常に</em><code>cargo-size</code>を使用して下さい。</p>
<!-- `cargo-objdump` can be used to disassemble the binary. -->
<p><code>cargo-objdump</code>は、バイナリをディスアセンブルするために使用できます。</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -disassemble -no-show-raw-insn -print-imm-hex
</code></pre>
<!--
> **NOTE** this output assumes that rust-embedded/cortex-m-rt#111 has been
> merged
-->
<blockquote>
<p><strong>注記</strong> この出力は、rust-embedded/cortex-m-rt#111がマージされていることを前提とします</p>
</blockquote>
<pre><code class="language-text">app:    file format ELF32-arm-little

Disassembly of section .text:
Reset:
     400:       bl      #0x36
     404:       movw    r0, #0x0
     408:       movw    r1, #0x0
     40c:       movt    r0, #0x2000
     410:       movt    r1, #0x2000
     414:       bl      #0x2c
     418:       movw    r0, #0x0
     41c:       movw    r1, #0x45c
     420:       movw    r2, #0x0
     424:       movt    r0, #0x2000
     428:       movt    r1, #0x0
     42c:       movt    r2, #0x2000
     430:       bl      #0x1c
     434:       b       #-0x4 &lt;Reset+0x34&gt;

HardFault_:
     436:       b       #-0x4 &lt;HardFault_&gt;

UsageFault:
     438:       b       #-0x4 &lt;UsageFault&gt;

__pre_init:
     43a:       bx      lr

HardFault:
     43c:       mrs     r0, msp
     440:       bl      #-0xe

__zero_bss:
     444:       movs    r2, #0x0
     446:       b       #0x0 &lt;__zero_bss+0x6&gt;
     448:       stm     r0!, {r2}
     44a:       cmp     r0, r1
     44c:       blo     #-0x8 &lt;__zero_bss+0x4&gt;
     44e:       bx      lr

__init_data:
     450:       b       #0x2 &lt;__init_data+0x6&gt;
     452:       ldm     r1!, {r3}
     454:       stm     r0!, {r3}
     456:       cmp     r0, r2
     458:       blo     #-0xa &lt;__init_data+0x2&gt;
     45a:       bx      lr
</code></pre>
<!-- ### Running -->
<h3><a class="header" href="#実行" id="実行">実行</a></h3>
<!--
Next, let's see how to run an embedded program on QEMU! This time we'll use the
`hello` example which actually does something.
-->
<p>次は、QEMUで組込みプログラムを実行する方法を見ていきましょう。
今回は、実際に何かを行う<code>hello</code>の例を使います。</p>
<!-- For convenience here's the source code of `src/main.rs`: -->
<p>便宜上の<code>src/main.rs</code>のソースコードです:</p>
<pre><code class="language-console">$ cat examples/hello.rs
</code></pre>
<!--
下から4行目のコメント`debugger section`は、`debugger session`の誤記と考えられるため、
翻訳もデバッガセッションとしています。
-->
<pre><pre class="playground"><code class="language-rust"><span class="boring">//! Prints &quot;Hello, world!&quot; on the host console using semihosting
</span>//! セミホスティングを使って&quot;Hello, world!&quot;をホストのコンソールに表示します

#![no_main]
#![no_std]

extern crate panic_halt;

use core::fmt::Write;

use cortex_m_rt::entry;
use cortex_m_semihosting::{debug, hio};

#[entry]
fn main() -&gt; ! {
    let mut stdout = hio::hstdout().unwrap();
    writeln!(stdout, &quot;Hello, world!&quot;).unwrap();

<span class="boring">    // exit QEMU or the debugger section
</span>    // QEMUもしくはデバッガセッションを終了します
    debug::exit(debug::EXIT_SUCCESS);

    loop {}
}
</code></pre></pre>
<!--
This program uses something called semihosting to print text to the *host*
console. When using real hardware this requires a debug session but when using
QEMU this Just Works.
-->
<p>このプログラムは、<em>ホスト</em>コンソールにテキストを表示するために、セミホスティングと呼ばれるものを使います。
実際のハードウェアを使用する場合、セミホスティングはデバッグセッションを必要としますが、
QEMUを使う場合、これで機能します。</p>
<!-- Let's start by compiling the example: -->
<p>例をコンパイルすることから始めましょう。</p>
<pre><code class="language-console">$ cargo build --example hello
</code></pre>
<!--
The output binary will be located at
`target/thumbv7m-none-eabi/debug/examples/hello`.
-->
<p><code>target/thumbv7m-none-eabi/debug/examples/hello</code>に出力バイナリがあります。</p>
<!-- To run this binary on QEMU run the following command: -->
<p>QEMU上でこのバイナリを動かすために、次のコマンドを実行して下さい。</p>
<pre><code class="language-console">$ qemu-system-arm \
      -cpu cortex-m3 \
      -machine lm3s6965evb \
      -nographic \
      -semihosting-config enable=on,target=native \
      -kernel target/thumbv7m-none-eabi/debug/examples/hello
Hello, world!
</code></pre>
<!--
The command should successfully exit (exit code = 0) after printing the text. On
*nix you can check that with the following command:
-->
<p>上記コマンドは、テキストを表示したあと、正常終了（終了コードが0）するはずです。
*nixでは、次のコマンドで正常終了したことを確認できます。</p>
<pre><code class="language-console">$ echo $?
0
</code></pre>
<!-- Let me break down that long QEMU command for you: -->
<p>この長いQEMUコマンドを分解して説明します。</p>
<!--
- `qemu-system-arm`. This is the QEMU emulator. There are a few variants of
  these QEMU binaries; this one does full *system* emulation of *ARM* machines
  hence the name.
-->
<ul>
<li><code>qemu-system-arm</code>。これはQEMUエミュレータです。QEMUにはいくつかのバイナリがあります。
このバイナリは、<em>ARM</em>マシンのフル<em>システム</em>をエミュレーションするので、この名前になっています。</li>
</ul>
<!--
- `-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the
  CPU model lets us catch some miscompilation errors: for example, running a
  program compiled for the Cortex-M4F, which has a hardware FPU, will make QEMU
  error during its execution.
-->
<ul>
<li><code>-cpu cortex-m3</code>。QEMUに、Cortex-M3 CPUをエミュレーションするように伝えます。
CPUモデルを指定すると、いくつかのコンパイルミスのエラーを検出できます。例えば、
ハードウェアFPUを搭載しているCortex-M4F用にコンパイルしたプログラムを実行すると、
実行中にQEMUがエラーを発生させるでしょう。</li>
</ul>
<!--
- `-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, a
  evaluation board that contains a LM3S6965 microcontroller.
-->
<ul>
<li><code>-machine lm3s6965evb</code>。QEMUに、LM3S6965EVBをエミュレーションするように伝えます。
LM3S6965EVBは、LM3S6965マイクロコントローラを搭載している評価ボードです。</li>
</ul>
<!-- - `-nographic`. This tells QEMU to not launch its GUI. -->
<ul>
<li><code>-nographic</code>。QEMUがGUIを起動しないようにします。</li>
</ul>
<!--
- `-semihosting-config (..)`. This tells QEMU to enable semihosting. Semihosting
  lets the emulated device, among other things, use the host stdout, stderr and
  stdin and create files on the host.
-->
<ul>
<li><code>-semihosting-config (..)</code>。QEMUのセミホスティングを有効にします。セミホスティングにより、
エミュレーションされたデバイスは、ホストの標準出力、標準エラー、標準入力を使用できるようになり、
ホスト上にファイルを作成することができます。</li>
</ul>
<!--
- `-kernel $file`. This tells QEMU which binary to load and run on the emulated
  machine.
-->
<ul>
<li><code>-kernel $file</code>。QEMUに、エミュレーションしたマシン上にロードして、実行するバイナリを教えます。</li>
</ul>
<!--
Typing out that long QEMU command is too much work! We can set a custom runner
to simplify the process. `.cargo/config` has a commented out runner that invokes
QEMU; let's uncomment it:
-->
<p>この長いQEMUコマンドを入力するのは大変過ぎます。このプロセスを簡略化するために、
カスタムランナーを設定できます。<code>.cargo/config</code>には、QEMUを起動するランナーが、
コメントアウトされた状態であります。コメントアウトを外して下さい。</p>
<pre><code class="language-console">$ head -n3 .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
# `cargo run`で、プログラムをQEMUで実行するため、コメントアウトを外して下さい。
runner = &quot;qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel&quot;
</code></pre>
<!--
This runner only applies to the `thumbv7m-none-eabi` target, which is our
default compilation target. Now `cargo run` will compile the program and run it
on QEMU:
-->
<p>このランナーは、デフォルトのコンパイルターゲットである<code>thumbv7m-none-eabi</code>のみに適用されます。
これで、<code>cargo run</code>はプログラムをコンパイルしてQEMUで実行します。</p>
<pre><code class="language-console">$ cargo run --example hello --release
   Compiling app v0.1.0 (file:///tmp/app)
    Finished release [optimized + debuginfo] target(s) in 0.26s
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel target/thumbv7m-none-eabi/release/examples/hello`
Hello, world!
</code></pre>
<!-- ### Debugging -->
<h3><a class="header" href="#デバッグ" id="デバッグ">デバッグ</a></h3>
<!-- Debugging is critical to embedded development. Let's see how it's done. -->
<p>デバッグは組込み開発にとって非常に重要です。どのように行うのか、見てみましょう。</p>
<!--
Debugging an embedded device involves *remote* debugging as the program that we
want to debug won't be running on the machine that's running the debugger
program (GDB or LLDB).
-->
<p>組込みデバイスのデバッグは、<em>リモート</em>デバッグを伴います。デバッグしたいプログラムは、
デバッガプログラム（GDBまたはLLDB）を実行しているマシン上で実行されないためです。</p>
<!--
Remote debugging involves a client and a server. In a QEMU setup, the client
will be a GDB (or LLDB) process and the server will be the QEMU process that's
also running the embedded program.
-->
<p>リモートデバッグは、クライアントとサーバからなります。QEMUのセットアップで、
クライアントはGDB（またはLLDB）プロセスとなり、サーバは組込みプログラムを実行しているQEMUプロセスとなります。</p>
<!-- In this section we'll use the `hello` example we already compiled. -->
<p>このセクションでは、コンパイル済みの<code>hello</code>の例を使用します。</p>
<!-- The first debugging step is to launch QEMU in debugging mode: -->
<p>最初のデバッグステップは、QEMUをデバッグモードで起動することです。</p>
<pre><code class="language-console">$ qemu-system-arm \
      -cpu cortex-m3 \
      -machine lm3s6965evb \
      -nographic \
      -semihosting-config enable=on,target=native \
      -gdb tcp::3333 \
      -S \
      -kernel target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<!--
This command won't print anything to the console and will block the terminal. We
have passed two extra flags this time:
-->
<p>このコマンドは、コンソールに何も表示せず、端末をブロックします。
ここでは2つの追加フラグを渡しています。</p>
<!--
- `-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP
  port 3333.
-->
<ul>
<li><code>-gdb tcp::3333</code>。QEMUがTCPポート3333番で、GDBコネクションを待つようにします。</li>
</ul>
<!--
- `-S`. This tells QEMU to freeze the machine at startup. Without this the
  program would have reached the end of main before we had a chance to launch
  the debugger!
-->
<ul>
<li><code>-S</code>。QEMUが、起動時に、マシンをフリーズします。このフラグがないと、
デバッガを起動する前に、プログラムがmain関数の終わりに到達してしまいます。</li>
</ul>
<!--
Next we launch GDB in another terminal and tell it to load the debug symbols of
the example:
-->
<p>次に別の端末でGDBを起動し、<code>hello</code>の例のデバッグシンボルをロードします。</p>
<pre><code class="language-console">$ &lt;gdb&gt; -q target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<!--
**NOTE**: `<gdb>` represents a GDB program capable of debugging ARM binaries.
This could be `arm-none-eabi-gdb`, `gdb-multiarch` or `gdb` depending on your
system -- you may have to try all three.
-->
<p><strong>注記</strong>: <code>&lt;gdb&gt;</code>はARMバイナリをデバッグ可能なGDBを意味します。
あなたが利用しているシステムに依存して、<code>arm-none-eabi-gdb</code>か、<code>gdb-multiarch</code>、<code>gdb</code>になります。
3つ全てを試してみる必要があるかもしれません。</p>
<!--
Then within the GDB shell we connect to QEMU, which is waiting for a connection
on TCP port 3333.
-->
<p>すると、GDBシェルは、TCPポート3333番で接続を待っていたQEMUに接続します。</p>
<pre><code class="language-console">(gdb) target remote :3333
Remote debugging using :3333
Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473
473     pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
</code></pre>
<!--
You'll see that the process is halted and that the program counter is pointing
to a function named `Reset`. That is the reset handler: what Cortex-M cores
execute upon booting.
-->
<p>プロセスは停止しており、プログラムカウンタが<code>Reset</code>という名前の関数を指していることがわかります。
<code>Reset</code>関数は、Cortex-Mコアが起動時に実行するリセットハンドラです。</p>
<!--
This reset handler will eventually call our main function. Let's skip all the
way there using a breakpoint and the `continue` command:
-->
<p>このリセットハンドラは、最終的に、私たちのメイン関数を呼び出します。
ブレイクポイントと<code>continue</code>コマンドを使って、メイン関数呼び出しまでスキップしましょう。</p>
<pre><code class="language-console">(gdb) break main
Breakpoint 1 at 0x400: file examples/panic.rs, line 29.

(gdb) continue
Continuing.

Breakpoint 1, main () at examples/hello.rs:17
17          let mut stdout = hio::hstdout().unwrap();
</code></pre>
<!--
We are now close to the code that prints "Hello, world!". Let's move forward
using the `next` command.
-->
<p>「Hello, world!」を表示するコードに近づいてきました。
<code>next</code>コマンドを使って、先へ進みましょう。</p>
<pre><code class="language-console">(gdb) next
18          writeln!(stdout, &quot;Hello, world!&quot;).unwrap();

(gdb) next
20          debug::exit(debug::EXIT_SUCCESS);
</code></pre>
<!--
At this point you should see "Hello, world!" printed on the terminal that's
running `qemu-system-arm`.
-->
<p>この時点で、<code>qemu-system-arm</code>を実行している端末に「Hello, world」が表示されるはずです。</p>
<pre><code class="language-console">$ qemu-system-arm (..)
Hello, world!
</code></pre>
<!--
Calling `next` again will terminate the QEMU process.
-->
<p>もう1度<code>next</code>を実行すると、QEMUプロセスが終了します。</p>
<pre><code class="language-console">(gdb) next
[Inferior 1 (Remote target) exited normally]
</code></pre>
<!--
You can now exit the GDB session.
-->
<p>これでGDBセッションを終了できます。</p>
<pre><code class="language-console">(gdb) quit
</code></pre>
<!-- # Hardware -->
<h1><a class="header" href="#ハードウェア" id="ハードウェア">ハードウェア</a></h1>
<!--
By now you should be somewhat familiar with the tooling and the development
process. In this section we'll switch to real hardware; the process will remain
largely the same. Let's dive in.
-->
<p>ここまでで、ツールと開発プロセスにある程度慣れたはずです。このセクションでは、実際のハードウェアに切り替えます。
開発プロセスは、ほとんど同じままです。飛び込みましょう。</p>
<!-- ## Know your hardware -->
<h2><a class="header" href="#ハードウェアを知る" id="ハードウェアを知る">ハードウェアを知る</a></h2>
<!--
Before we begin you need to identify some characteristics of the target device
as these will be used to configure the project:
-->
<p>始める前に、プロジェクトの設定に利用するターゲットデバイスのいくつかの特徴を確認する必要があります。</p>
<!-- - The ARM core. e.g. Cortex-M3. -->
<ul>
<li>ARMコア、例えばCortex-M3です。</li>
</ul>
<!-- - Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do. -->
<ul>
<li>そのARMコアはFPUを搭載していますか？Cortex-M4<strong>F</strong>とCortex-M7<strong>F</strong>は、搭載しています。</li>
</ul>
<!--
- How much Flash memory and RAM does the target device have? e.g. 256 KiB of
  Flash and 32 KiB of RAM.
-->
<ul>
<li>ターゲットデバイスに搭載されているフラッシュメモリとRAMの容量はいくらですか？
例えば、フラッシュは256KiBでRAMは32KiBです。</li>
</ul>
<!--
- Where are Flash memory and RAM mapped in the address space? e.g. RAM is
  commonly located at address `0x2000_0000`.
-->
<ul>
<li>フラッシュメモリとRAMは、アドレス空間のどこにマッピングされていますか？
例えば、RAMは、通常<code>0x2000_0000</code>番地に位置します。</li>
</ul>
<!--
You can find this information in the data sheet or the reference manual of your
device.
-->
<p>これらの情報は、デバイスのデータシートかリファレンスマニュアルに掲載されています。</p>
<!--
In this section we'll be using our reference hardware, the STM32F3DISCOVERY.
This board contains an STM32F303VCT6 microcontroller. This microcontroller has:
-->
<p>このセクションでは、私たちのリファレンスハードウェアであるSTM32F3DISCOVERYを使用します。
このボードは、STM32F303VCT6マイクロコントローラを1つ搭載しています。このマイクロコントローラは以下のものを持っています。</p>
<!-- - A Cortex-M4F core that includes a single precision FPU -->
<ul>
<li>単精度FPUを含むCortex-M4Fコアが1つ</li>
</ul>
<!-- - 256 KiB of Flash located at address 0x0800_0000. -->
<ul>
<li>0x0800_0000番地に配置された256KiBのフラッシュメモリ</li>
</ul>
<!--
- 40 KiB of RAM located at address 0x2000_0000. (There's another RAM region but
  for simplicity we'll ignore it).
-->
<ul>
<li>0x2000_0000番地に配置された40KiBのRAM。（別のRAM領域もありますが、説明の簡単化のため、取り扱いません）</li>
</ul>
<!-- ## Configuring -->
<h2><a class="header" href="#設定" id="設定">設定</a></h2>
<!--
We'll start from scratch with a fresh template instance. Refer to the
[previous section on QEMU] for a refresher on how to do this without
`cargo-generate`.
-->
<p>テンプレートの新しいインスタンスを使って、スクラッチから書いていきましょう。
<code>cargo-generate</code>を使用しない方法については、<a href="start/qemu.html">前セクションのQEMU</a>を参照して下さい。</p>
<!-- [previous section on QEMU]: qemu.md -->
<pre><code class="language-console">$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
 Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app

 $ cd app
</code></pre>
<!-- Step number one is to set a default compilation target in `.cargo/config`. -->
<p>第一ステップは、<code>.cargo/config</code>にデフォルトコンパイルターゲットを設定することです。</p>
<pre><code class="language-console">$ tail -n5 .cargo/config
</code></pre>
<pre><code class="language-toml">[build]
# 以下のコンパイルターゲットから1つを選びます
# target = &quot;thumbv6m-none-eabi&quot;    # Cortex-M0およびCortex-M0+
# target = &quot;thumbv7m-none-eabi&quot;    # Cortex-M3
# target = &quot;thumbv7em-none-eabi&quot;   # Cortex-M4およびCortex-M7 (no FPU)
target = &quot;thumbv7em-none-eabihf&quot; # Cortex-M4FおよびCortex-M7F (with FPU)
</code></pre>
<!-- We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core. -->
<p>Cortex-M4Fコアを対象とするものとして、<code>thumbv7em-none-eabihf</code>を使います。</p>
<!--
The second step is to enter the memory region information into the `memory.x`
file.
-->
<p>第二ステップは、<code>memory.x</code>ファイルにメモリ領域の情報を入力することです。</p>
<pre><code class="language-console">$ cat memory.x
/* STM32F303VCT6用のリンカスクリプト */
MEMORY
{
  /* 注記 1 K = 1 KiBi = 1024バイト */
  FLASH : ORIGIN = 0x08000000, LENGTH = 256K
  RAM : ORIGIN = 0x20000000, LENGTH = 40K
}
</code></pre>
<!--
Make sure the `debug::exit()` call is commented out or removed, it is used
only for running in QEMU.
-->
<p><code>debug::exit()</code>の呼び出しが、コメントアウトされているか削除されていることを確認して下さい。
これは、QEMUで実行する時のみ、使用します。</p>
<pre><pre class="playground"><code class="language-rust">#[entry]
fn main() -&gt; ! {
    hprintln!(&quot;Hello, world!&quot;).unwrap();

<span class="boring">    // exit QEMU
</span><span class="boring">    // NOTE do not run this on hardware; it can corrupt OpenOCD state
</span><span class="boring">    // debug::exit(debug::EXIT_SUCCESS);
</span>    // QEMUを終了する
    // 注記、ハードウェア上で実行しないで下さい。OpenOCDの状態を破壊する可能性があります。
    // debug::exit(debug::EXIT_SUCCESS);

    loop {}
}
</code></pre></pre>
<!--
You can now cross compile programs using `cargo build`
and inspect the binaries using `cargo-binutils` as you did before. The
`cortex-m-rt` crate handles all the magic required to get your chip running,
as helpfully, pretty much all Cortex-M CPUs boot in the same fashion.
-->
<p>これまでやってきた通り、<code>cargo build</code>でプログラムをクロスコンパイルし、
<code>cargo-binutils</code>でバイナリを調べることができます。
<code>cortex-m-rt</code>クレートは、チップを動作させるために必要な、全てのおまじないを処理します。
便利なことに、ほとんど全てのCortex-M CPUが同じ方法で起動します。</p>
<pre><code class="language-console">$ cargo build --example hello
</code></pre>
<!-- ## Debugging -->
<h2><a class="header" href="#デバッグ-1" id="デバッグ-1">デバッグ</a></h2>
<!--
Debugging will look a bit different. In fact, the first steps can look different
depending on the target device. In this section we'll show the steps required to
debug a program running on the STM32F3DISCOVERY. This is meant to serve as a
reference; for device specific information about debugging check out [the
Debugonomicon](https://github.com/rust-embedded/debugonomicon).
-->
<p>デバッグ方法は少し違います。実際、最初のステップは、ターゲットデバイスによって異なります。
このセクションでは、STM32F3DISCOVERY上で実行しているプログラムをデバッグするために必要となる手順を説明します。
これは、参考の役目を果たします。デバイス固有のデバッグ情報は、
<a href="https://github.com/rust-embedded/debugonomicon">the Debugonomicon</a>を参照して下さい。</p>
<!--
As before we'll do remote debugging and the client will be a GDB process. This
time, however, the server will be OpenOCD.
-->
<p>以前と同様に、リモートデバッグを行います。クライアントがGDBプロセスであることも同様です。
しかし、今回、サーバはOpenOCDになります。</p>
<!--
As done during the [verify] section connect the discovery board to your laptop /
PC and check that the ST-LINK header is populated.
-->
<p><a href="start/../intro/install/verify.html">インストールの確認</a>セクションでやったように、ノートPCまたはPCをdiscoveryボードに接続し、
ST-LINKヘッダが設定されていることを確認して下さい。</p>
<!-- [verify]: ../intro/install/verify.md -->
<!--
On a terminal run `openocd` to connect to the ST-LINK on the discovery board.
Run this command from the root of the template; `openocd` will pick up the
`openocd.cfg` file which indicates which interface file and target file to use.
-->
<p>discoveryボードのST-LINKに接続するために、端末で<code>openocd</code>を実行して下さい。
このコマンドは、テンプレートプロジェクトのルートディレクトリから実行して下さい。
<code>openocd</code>は、どのインタフェースファイルとターゲットファイルを使うか、が記述されている<code>openocd.cfg</code>ファイルを見つけます。</p>
<pre><code class="language-console">$ cat openocd.cfg
</code></pre>
<pre><code class="language-text"># STM32F3DISCOVERY開発ボード用のOpenOCD設定サンプル

# 持っているハードウェアのリビジョンに応じて、これらのインタフェースのうち、1つを選んで下さい。
# 常に、1つのインタフェースがコメントアウトされているべきです。

# Revision C (newer revision)
# リビジョンC （新しいリビジョン）
source [find interface/stlink-v2-1.cfg]

# リビジョンAとB（古いリビジョン）
# source [find interface/stlink-v2.cfg]

source [find target/stm32f3x.cfg]
</code></pre>
<!--
> **NOTE** If you found out that you have an older revision of the discovery
> board during the [verify] section then you should modify the `openocd.cfg`
> file at this point to use `interface/stlink-v2.cfg`.
-->
<blockquote>
<p><strong>注記</strong> <a href="start/../intro/install/verify.html">インストールの確認</a>セクションで、古いバージョンのdiscoveryボードを持っていることが判明している場合、
<code>interface/stlink-v2.cfg</code>を使うように<code>openocd.cfg</code>ファイルを修正する必要があります。</p>
</blockquote>
<pre><code class="language-console">$ openocd
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport &quot;hla_swd&quot;. To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.913879
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<!-- On another terminal run GDB, also from the root of the template. -->
<p>別の端末で、GDBを実行します。こちらも、テンプレートプロジェクトのルートディレクトから実行して下さい。</p>
<pre><code class="language-console">$ &lt;gdb&gt; -q target/thumbv7em-none-eabihf/debug/examples/hello
</code></pre>
<!-- Next connect GDB to OpenOCD, which is waiting for a TCP connection on port 3333. -->
<p>次に、TCP 3333ポートで接続待ちしているOpenOCDに、GDBを接続します。</p>
<pre><code class="language-console">(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<!--
Now proceed to *flash* (load) the program onto the microcontroller using the
`load` command.
-->
<p>それでは、<code>load</code>コマンドを使って、マイクロコントローラにプログラムを<em>書き込んで</em>下さい。</p>
<pre><code class="language-console">(gdb) load
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1e70 lma 0x8000400
Loading section .rodata, size 0x61c lma 0x8002270
Start address 0x800144e, load size 10380
Transfer rate: 17 KB/sec, 3460 bytes/write.
</code></pre>
<!--
The program is now loaded. This program uses semihosting so before we do any
semihosting call we have to tell OpenOCD to enable semihosting. You can send
commands to OpenOCD using the `monitor` command.
-->
<p>プログラムがロードされました。このプログラムはセミホスティングを使用します。そこで、
セミホスティングを呼び出して何かを行う前に、OpenOCDにセミホスティングを有効にするように、
指示する必要があります。</p>
<pre><code class="language-console">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<!-- > You can see all the OpenOCD commands by invoking the `monitor help` command. -->
<blockquote>
<p><code>monitor help</code>コマンドを実行することで、全てのOpenOCDコマンドを見ることができます。</p>
</blockquote>
<!--
Like before we can skip all the way to `main` using a breakpoint and the
`continue` command.
-->
<p>以前のように、ブレイクポイントと<code>continue</code>コマンドを使用することで、<code>main</code>までスキップすることができます。</p>
<pre><code class="language-console">(gdb) break main
Breakpoint 1 at 0x8000d18: file examples/hello.rs, line 15.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at examples/hello.rs:15
15          let mut stdout = hio::hstdout().unwrap();
</code></pre>
<!-- Advancing the program with `next` should produce the same results as before. -->
<p><code>next</code>でプログラムを先に進めると、以前と同じ結果になるはずです。</p>
<pre><code class="language-console">(gdb) next
16          writeln!(stdout, &quot;Hello, world!&quot;).unwrap();

(gdb) next
19          debug::exit(debug::EXIT_SUCCESS);
</code></pre>
<!--
At this point you should see "Hello, world!" printed on the OpenOCD console,
among other stuff.
-->
<p>この時点で、OpenOCDコンソールに、他のものと入り混じって「Hello, world!」と表示されるはずです。</p>
<pre><code class="language-console">$ openocd
(..)
Info : halted: PC: 0x08000e6c
Hello, world!
Info : halted: PC: 0x08000d62
Info : halted: PC: 0x08000d64
Info : halted: PC: 0x08000d66
Info : halted: PC: 0x08000d6a
Info : halted: PC: 0x08000a0c
Info : halted: PC: 0x08000d70
Info : halted: PC: 0x08000d72
</code></pre>
<!--
Issuing another `next` will make the processor execute `debug::exit`. This acts
as a breakpoint and halts the process:
-->
<p>もう一度<code>next</code>を実行して、プロセッサに<code>debug::exit</code>を実行させます。
これはブレイクポイントとして動作し、プロセスを停止します。</p>
<pre><code class="language-console">(gdb) next

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0800141a in __syscall ()
</code></pre>
<!-- It also causes this to be printed to the OpenOCD console: -->
<p>また、OpenOCDコンソールに次のものが表示されます。</p>
<pre><code class="language-console">$ openocd
(..)
Info : halted: PC: 0x08001188
semihosting: *** application exited ***
Warn : target not halted
Warn : target not halted
target halted due to breakpoint, current mode: Thread
xPSR: 0x21000000 pc: 0x08000d76 msp: 0x20009fc0, semihosting
</code></pre>
<!--
However, the process running on the microcontroller has not terminated and you
can resume it using `continue` or a similar command.
-->
<p>しかし、マイクロコントローラ上で動作しているプロセスは終了していないため、
<code>continue</code>もしくは同様のコマンドを使って、プログラムを再開することができます。</p>
<!-- You can now exit GDB using the `quit` command. -->
<p>ここで、<code>quit</code>コマンドを使うことで、GDBを終了できます。</p>
<pre><code class="language-console">(gdb) quit
</code></pre>
<!--
Debugging now requires a few more steps so we have packed all those steps into a
single GDB script named `openocd.gdb`.
-->
<p>デバッグにはもう少しステップが必要なので、これらのステップを<code>openocd.gdb</code>というGDBスクリプトにまとめました。</p>
<pre><code class="language-console">$ cat openocd.gdb
</code></pre>
<pre><code class="language-text">target remote :3333

# デマングルされたシンボルを表示します
set print asm-demangle on

# 未処理の例外、ハードフォールト、パニックを検出します
break DefaultHandler
break HardFault
break rust_begin_unwind

monitor arm semihosting enable

load

# プロセスを開始しますが、すぐにプロセッサを停止します
stepi
</code></pre>
<!--
Now running `<gdb> -x openocd.gdb $program` will immediately connect GDB to
OpenOCD, enable semihosting, load the program and start the process.
-->
<p><code>&lt;gdb&gt; -x openocd.gdb $program</code>を実行することで、GDBはすぐにOpenOCDに接続し、
セミホスティングを有効化し、プログラムをロードした上で、プロセスを開始します。</p>
<!--
Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to make
`cargo run` build a program *and* start a GDB session. This runner is included
in `.cargo/config` but it's commented out.
-->
<p>別の方法として、<code>&lt;gdb&gt; -x openocd.gdb</code>をカスタムランナーにして、<code>cargo run</code>でプログラムをビルドし、
<em>さらに</em>GDBセッションを開始することもできます。このランナーは、<code>.cargo/config</code>に含まれていますが、
コメントアウトされています。</p>
<pre><code class="language-console">$ head -n10 .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
# ここのコメントアウトを外すと、`cargo run`はQEMUでプログラムを実行します
# runner = &quot;qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel&quot;

[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
# 3つの選択肢のうち、1つのコメントアウトを外すと、`cargo run`はGDBセッションを開始します。
# どの選択肢を使うか、は対象システムによって異なります。
runner = &quot;arm-none-eabi-gdb -x openocd.gdb&quot;
# runner = &quot;gdb-multiarch -x openocd.gdb&quot;
# runner = &quot;gdb -x openocd.gdb&quot;
</code></pre>
<pre><code class="language-console">$ cargo run --example hello
(..)
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1e70 lma 0x8000400
Loading section .rodata, size 0x61c lma 0x8002270
Start address 0x800144e, load size 10380
Transfer rate: 17 KB/sec, 3460 bytes/write.
(gdb)
</code></pre>
<!-- # Memory Mapped Registers -->
<h1><a class="header" href="#メモリマップドレジスタ" id="メモリマップドレジスタ">メモリマップドレジスタ</a></h1>
<!--
Embedded systems can only get so far by executing normal Rust code and moving data around in RAM. If we want to get any information into or out of our system (be that blinking an LED, detecting a button press or communicating with an off-chip peripheral on some sort of bus) we're going to have to dip into the world of Peripherals and their 'memory mapped registers'.
-->
<p>組込みシステムでは、通常のRustコードを実行し、データをRAM内で移動させるだけではたいしたことはできません。
LEDの点滅やボタンの押下検出、もしくは、バス上のオフチップペリフェラルとの通信など、
システムが情報を入出力するには、ペリフェラルとその「メモリマップドレジスタ」の世界に足を踏み入れる必要があります。</p>
<!--
You may well find that the code you need to access the peripherals in your micro-controller has already been written, at one of the following levels:
-->
<p>マイクロコントローラのペリフェラルにアクセスするためのコードが、次のいずれかのレベルで、既に書かれています。</p>
<!--
* Micro-architecture Crate - This sort of crate handles any useful routines common to the processor core your microcontroller is using, as well as any peripherals that are common to all micro-controllers that use that particular type of processor core. For example the [cortex-m] crate gives you functions to enable and disable interrupts, which are the same for all Cortex-M based micro-controllers. It also gives you access to the 'SysTick' peripheral included with all Cortex-M based micro-controllers.
-->
<ul>
<li>マイクロアーキテクチャクレート。この種のクレートは、マイクロコントローラに搭載されているプロセッサコアで共通となる便利なルーチンを扱っています。
また、特定のプロセッサコアを使用する全てのマイクロコントローラに共通のペリフェラルも取り扱います。
例えば、<a href="https://crates.io/crates/cortex-m">cortex-m</a>クレートは、割り込みの有効化と無効化を行う関数を提供しています。これは全てのCortex-Mベースマイクロコントローラで同じものです。
<a href="https://crates.io/crates/cortex-m">cortex-m</a>クレートは、「SysTick」ペリフェラルへのアクセスも提供しています。このペリフェラルは、全てのCortex-Mベースマイクロコントローラに搭載されています。</li>
</ul>
<!--
* Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over the various memory-wrapper registers defined for your particular part-number of micro-controller you are using. For example, [tm4c123x] for the Texas Instruments Tiva-C TM4C123 series, or [stm32f30x] for the ST-Micro STM32F30x series. Here, you'll be interacting with the registers directly, following each peripheral's operating instructions given in your micro-controller's Technical Reference Manual.
-->
<!-- `memory-wrapper registers`は`memory-mapped registers`と解釈した方が自然な日本語になると考え、メモリマップドレジスタと翻訳しました。 -->
<ul>
<li>ペリフェラルアクセスクレート（PAC）。この種のクレートは、薄いラッパーです。特定の型番のマイクロコントローラに対して定義されている、
様々なメモリマップドレジスタのラッパーを提供します。例えば、テキサスインスツルメンツのTiva-C TM4C123シリーズ向けの<a href="https://crates.io/crates/tm4c123x">tm4c123x</a>クレートや、
STマイクロのSTM32F30xシリーズ向けの<a href="https://crates.io/crates/stm32f30x">stm32f30x</a>クレートです。マイクロコントローラのテクニカルリファレンスマニュアルに記載されている各ペリフェラルの操作手順に従って、
レジスタと直接やり取りします。</li>
</ul>
<!--
* HAL Crate - These crates offer a more user-friendly API for your particular processor, often by implementing some common traits defined in [embedded-hal]. For example, this crate might offer a `Serial` struct, with a constructor that takes an appropriate set of GPIO pins and a baud rate, and offers some sort of `write_byte` function for sending data. See the chapter on [Portability] for more information on [embedded-hal].
-->
<ul>
<li>HALクレート。これらのクレートは、特定のプロセッサに対して、よりユーザフレンドリなAPIを提供しています。<a href="https://crates.io/crates/embedded-hal">embedded-hal</a>で定義されている共通のトレイトを使って実装されていることが多いです。
例えば、このクレートは、<code>Serial</code>構造体を提供しているでしょう。そのコンストラクタは、適切なGPIOピンの一式とボーレートを引数に取ります。そして、データを送信するための<code>write_byte</code>関数一式を提供します。
<a href="https://crates.io/crates/embedded-hal">embedded-hal</a>に関する詳細は、<a href="start/../portability/index.html">移植性</a>の章を参照して下さい。</li>
</ul>
<!--
* Board Crate - These crates go one step further than a HAL Crate by pre-configuring various peripherals and GPIO pins to suit the specific developer kit or board you are using, such as [F3] for the STM32F3DISCOVERY board.
-->
<ul>
<li>ボードクレート。これらのクレートは、HALクレートのさらに一歩先を進んでいます。これらは、STM32F3DISCOVERYボード向けの<a href="https://crates.io/crates/f3">F3</a>のように、
特定の開発キットやボード向けに、様々なペリフェラルとGPIOピンを事前に設定してあります。</li>
</ul>
<!-- [Portability]: ../portability/index.md -->
<!-- ## Starting at the bottom -->
<h2><a class="header" href="#最下層から始める" id="最下層から始める">最下層から始める</a></h2>
<!--
Let's look at the SysTick peripheral that's common to all Cortex-M based micro-controllers. We can find a pretty low-level API in the [cortex-m] crate, and we can use it like this:
-->
<p>全てのCortex-Mマイクロコントローラで共通のSysTickペリフェラルから見ていきましょう。
<a href="https://crates.io/crates/cortex-m">cortex-m</a>クレートにはかなり低レベルなAPIがあり、次のように使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">use cortex_m::peripheral::{syst, Peripherals};
use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let mut peripherals = Peripherals::take().unwrap();
    let mut systick = peripherals.SYST;
    systick.set_clock_source(syst::SystClkSource::Core);
    systick.set_reload(1_000);
    systick.clear_current();
    systick.enable_counter();
    while !systick.has_wrapped() {
<span class="boring">       // Loop
</span>        // ループ
    }

    loop {}
}
</code></pre></pre>
<!--
The functions on the `SYST` struct map pretty closely to the functionality defined by the ARM Technical Reference Manual for this peripheral. There's nothing in this API about 'delaying for X milliseconds' - we have to crudely implement that ourselves using a `while` loop. Note that we can't access our `SYST` struct until we have called `Peripherals::take()` - this is a special routine that guarantees that there is only one `SYST` structure in our entire program. For more on that, see the [Peripherals] section.
-->
<p><code>SYST</code>構造体の関数は、ARMテクニカルリファレンスマニュアルにおいて、このペリフェラルに定義されている機能と非常によく似ています。
「Xミリ秒遅延」といった具合のAPIはありません。<code>while</code>ループを使って愚直に実装する必要があります。<code>Peripherals::take()</code>を呼び出すまでは、
<code>SYST</code>構造体にアクセスできないことに注意して下さい。これは、プログラム全体で唯一の<code>SYST</code>構造体が存在することを保証する特別な手順です。
詳しくは、<a href="start/../peripherals/index.html">ペリフェラル</a>セクションをご覧下さい。</p>
<!-- ## Using a Peripheral Access Crate (PAC) -->
<h2><a class="header" href="#ペリフェラルアクセスクレートpacの使用" id="ペリフェラルアクセスクレートpacの使用">ペリフェラルアクセスクレート（PAC）の使用</a></h2>
<!--
We won't get very far with our embedded software development if we restrict ourselves to only the basic peripherals included with every Cortex-M. At some point, we're going to need to write some code that's specific to the particular micro-controller we're using. In this example, let's assume we have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB of Flash. We're going to pull in the [tm4c123x] crate to make use of this chip.
-->
<p>全てのCortex−Mに搭載されている基本的なペリフェラルのみに限定するのであれば、組込みソフトウェア開発はあまり進まないでしょう。
どこかの時点で、使用している特定のマイクロコントローラ固有のコードを書く必要があります。今回の例では、テキサスインスツルメンツのTM4C123があるとしましょう。
TM4C123はミドルレンジのマイクロコントローラで、80MHzのCortex-M4と256 KiBのフラッシュメモリが搭載されています。
このチップを利用するために、<a href="https://crates.io/crates/tm4c123x">tm4c123x</a>クレートを取得します。</p>
<pre><code class="language-rust ignore">#![no_std]
#![no_main]

<span class="boring">// extern crate panic_halt; // panic handler
</span>extern crate panic_halt; // パニックハンドラ

use cortex_m_rt::entry;
use tm4c123x;

#[entry]
pub fn init() -&gt; (Delay, Leds) {
    let cp = cortex_m::Peripherals::take().unwrap();
    let p = tm4c123x::Peripherals::take().unwrap();

    let pwm = p.PWM0;
    pwm.ctl.write(|w| w.globalsync0().clear_bit());
<span class="boring">    // Mode = 1 =&gt; Count up/down mode
</span>    // モード1は カウントアップ/ダウンモード
    pwm._2_ctl.write(|w| w.enable().set_bit().mode().set_bit());
    pwm._2_gena.write(|w| w.actcmpau().zero().actcmpad().one());
<span class="boring">    // 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)
</span>    // 528サイクル（264カウントアップとカウントダウン）は、ビデオラインごとに4ループ（2112サイクル）
    pwm._2_load.write(|w| unsafe { w.load().bits(263) });
    pwm._2_cmpa.write(|w| unsafe { w.compa().bits(64) });
    pwm.enable.write(|w| w.pwm4en().set_bit());
}

</code></pre>
<!--
We've accessed the `PWM0` peripheral in exactly the same way as we accessed the `SYST` peripheral earlier, except we called `tm4c123x::Peripherals::take()`. As this crate was auto-generated using [svd2rust], the access functions for our register fields take a closure, rather than a numeric argument. While this looks like a lot of code, the Rust compiler can use it to perform a bunch of checks for us, but then generate machine-code which is pretty close to hand-written assembler! Where the auto-generated code isn't able to determine that all possible arguments to a particular accessor function are valid (for example, if the SVD defines the register as 32-bit but doesn't say if some of those 32-bit values have a special meaning), then the function is marked as `unsafe`. We can see this in the example above when setting the `load` and `compa` sub-fields using the `bits()` function.
-->
<p>先ほど<code>SYST</code>にアクセスした時と全く同じ方法で、<code>PWM0</code>ペリフェラルにアクセスします。違う点は、<code>tm4c123x::Peripherals::take()</code>を呼ぶことです。
このクレートは、<a href="https://crates.io/crates/svd2rust">svd2rust</a>を使って自動生成されたものです。レジスタフィールドのアクセス関数は、数値の引数ではなく、クロージャを取ります。
このコードは量が多いように見えますが、Rustコンパイラは一連のチェックを実行し、手書きのアセンブラに近いマシンコードを生成します。
自動生成されたコードが、特定のアクセサ関数への全引数が有効であることを判断できない場合、その関数は<code>unsafe</code>とマークされます。
例えば、SVDがレジスタを32ビットと定義しているが、それらの32ビット値の一部が特別な意味を持つかどうか、記述していない場合です。
上記の例では、<code>bits()</code>関数を使って<code>load</code>と<code>compa</code>サブフィールドを設定する時に、<code>unsafe</code>をマークしています。</p>
<!-- ### Reading -->
<h3><a class="header" href="#読み込み" id="読み込み">読み込み</a></h3>
<!--
The `read()` function returns an object which gives read-only access to the various sub-fields within this register, as defined by the manufacturer's SVD file for this chip. You can find all the functions available on special `R` return type for this particular register, in this particular peripheral, on this particular chip, in the [tm4c123x documentation][tm4c123x documentation R].
-->
<p><code>read()</code>関数は、メーカーのSVDファイルで定義されている通り、レジスタ内の様々なサブフィールドに対して、読み込み専用のアクセスオブジェクトを返します。
特定チップ上にある、特定ペリフェラルの、特定レジスタに対して、固有の返り値<code>R</code>型があり、このR型で使える全ての関数は、<a href="https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html">tm4c123xドキュメント</a>で見ることができます。</p>
<pre><code class="language-rust ignore">if pwm.ctl.read().globalsync0().is_set() {
<span class="boring">    // Do a thing
</span>    // 処理をする
}
</code></pre>
<!-- ### Writing -->
<h3><a class="header" href="#書き込み" id="書き込み">書き込み</a></h3>
<!--
The `write()` function takes a closure with a single argument. Typically we call this `w`. This argument then gives read-write access to the various sub-fields within this register, as defined by the manufacturer's SVD file for this chip. Again, you can find all the functions available on the 'w' for this particular register, in this particular peripheral, on this particular chip, in the [tm4c123x documentation][tm4c123x Documentation W]. Note that all of the sub-fields that we do not set will be set to a default value for us - any existing content in the register will be lost.
-->
<p><code>write()</code>関数は、単一引数のクロージャを取ります。通常は、この引数を<code>w</code>と呼びます。
この引数は、チップメーカーがSVDファイルで定義している通り、様々なレジスタのサブフィールドへの読み書きアクセスを許可します。
特定チップ上にある、特定ペリフェラルの、特定レジスタに対して、<code>w</code>型で使える全ての関数も、<a href="https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html">tm4c123xドキュメント</a>で見ることができます。
設定していない全てのサブフィールドは、デフォルト値に設定されます。レジスタの既存の内容は失われます。</p>
<pre><code class="language-rust ignore">pwm.ctl.write(|w| w.globalsync0().clear_bit());
</code></pre>
<!-- ### Modifying -->
<h3><a class="header" href="#修正" id="修正">修正</a></h3>
<!--
If we wish to change only one particular sub-field in this register and leave the other sub-fields unchanged, we can use the `modify` function. This function takes a closure with two arguments - one for reading and one for writing. Typically we call these `r` and `w` respectively. The `r` argument can be used to inspect the current contents of the register, and the `w` argument can be used to modify the register contents.
-->
<p>レジスタの特定のサブフィールドだけを変更して、残りのサブフィールドは変更したくない場合、<code>modify</code>関数を使えます。この関数は2引数のクロージャを取ります。
1つは読み込み用で、もう1つは書き込み用です。通常、これらの引数をそれぞれ、<code>r</code>と<code>w</code>と呼びます。
<code>r</code>引数は、レジスタの現在の内容を調べるために使用されます。そして、<code>w</code>引数は、レジスタの内容を修正するために使用されます。</p>
<pre><code class="language-rust ignore">pwm.ctl.modify(|r, w| w.globalsync0().clear_bit());
</code></pre>
<!--
The `modify` function really shows the power of closures here. In C, we'd have to read into some temporary value, modify the correct bits and then write the value back. This means there's considerable scope for error:
-->
<p><code>modify</code>関数は、クロージャの本領を発揮します。C言語では、一時変数に読み込み、正しいビットを修正してから、その値を書き戻す必要があります。
これは、エラーが発生するかなりの余地があることを示しています。</p>
<pre><code class="language-C">uint32_t temp = pwm0.ctl.read();
temp |= PWM0_CTL_GLOBALSYNC0;
pwm0.ctl.write(temp);
uint32_t temp2 = pwm0.enable.read();
temp2 |= PWM0_ENABLE_PWM4EN;
pwm0.enable.write(temp); // ああ！間違った変数です！
</code></pre>
<!--
[tm4c123x documentation R]: https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html
[tm4c123x documentation W]: https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html
-->
<!-- ## Using a HAL crate -->
<h2><a class="header" href="#halクレートの使用" id="halクレートの使用">HALクレートの使用</a></h2>
<!--
The HAL crate for a chip typically works by implementing a custom Trait for the raw structures exposed by the PAC. Often this trait will define a function called `constrain()` for single peripherals or `split()` for things like GPIO ports with multiple pins. This function will consume the underlying raw peripheral structure and return a new object with a higher-level API. This API may also do things like have the Serial port `new` function require a borrow on some `Clock` structure, which can only be generated by calling the function which configures the PLLs and sets up all the clock frequencies. In this way, it is statically impossible to create a Serial port object without first having configured the clock rates, or for the Serial port object to mis-convert the baud rate into clock ticks. Some crates even define special traits for the states each GPIO pin can be in, requiring the user to put a pin into the correct state (say, by selecting the appropriate Alternate Function Mode) before passing the pin into Peripheral. All with no run-time cost!
-->
<p>あるチップ用のHALクレートは、典型的には、PACによって公開されている生の構造体に対して、カスタムトレイトを実装することで機能しています。
大抵、このトレイトは、単独のペリフェラルには<code>constrain()</code>関数を定義し、複数ピンを利用するGPIOポートのようなものには<code>split()</code>関数を定義します。
この関数は、下層の生のペリフェラル構造体オブジェクトを消費し、より高レベルなAPIを備える新しいオブジェクトを返します。
このAPIは、シリアルポートの<code>new</code>関数が、<code>Clock</code>構造体オブジェクトの借用を必要とするようなことをするかもしれません。Clock構造体オブジェクトは、
PLLと全てのクロック周波数とを設定する関数呼び出しによってのみ、生成することが可能です。この方法では、最初にクロックレートを設定しないでシリアルポートオブジェクトを作成したり、
シリアルポートオブジェクトがボーレートをクロック数に誤って変換するようなことは、静的に起こり得ません。
一部のクレートでは、各GPIOが取り得る状態のための特別なトレイトを定義することさえあります。このトレイトは、ペリフェラルにピンを渡す前に、
ユーザがピンを正しい状態（例えば、適切なAlternate Functionモードを選択することによって）にすることを求めます。
これらは全て、ランタイムのコストを必要としません。</p>
<blockquote>
<p>訳注: Alternate Functionモードは、GPIOピンのモードの1つ</p>
</blockquote>
<!-- Let's see an example: -->
<p>例を見てみましょう。</p>
<pre><pre class="playground"><code class="language-rust">#![no_std]
#![no_main]

<span class="boring">// extern crate panic_halt; // panic handler
</span>extern crate panic_halt; // パニックハンドラ

use cortex_m_rt::entry;
use tm4c123x_hal as hal;
use tm4c123x_hal::prelude::*;
use tm4c123x_hal::serial::{NewlineMode, Serial};
use tm4c123x_hal::sysctl;

#[entry]
fn main() -&gt; ! {
    let p = hal::Peripherals::take().unwrap();
    let cp = hal::CorePeripherals::take().unwrap();

<span class="boring">    // Wrap up the SYSCTL struct into an object with a higher-layer API
</span>    // SYSCTL構造体をより高レイヤなAPIオブジェクトでラップします
    let mut sc = p.SYSCTL.constrain();
<span class="boring">    // Pick our oscillation settings
</span>    // オシレータの設定値を選択します
    sc.clock_setup.oscillator = sysctl::Oscillator::Main(
        sysctl::CrystalFrequency::_16mhz,
        sysctl::SystemClock::UsePll(sysctl::PllOutputFrequency::_80_00mhz),
    );
<span class="boring">    // Configure the PLL with those settings
</span>    // PLLをそれらの設定値で設定します
    let clocks = sc.clock_setup.freeze();

<span class="boring">    // Wrap up the GPIO_PORTA struct into an object with a higher-layer API.
</span><span class="boring">    // Note it needs to borrow `sc.power_control` so it can power up the GPIO
</span><span class="boring">    // peripheral automatically.
</span>    // GPIO_PORTA構造体をより高レイヤなAPIオブジェクトでラップします。
    // GPIOペリフェラルに自動的に電源を入れるために、
    // `sc.power_control`の借用が必要なことに留意して下さい。
    let mut porta = p.GPIO_PORTA.split(&amp;sc.power_control);

<span class="boring">    // Activate the UART.
</span>    // UARTを起動します。
    let uart = Serial::uart0(
        p.UART0,
<span class="boring">        // The transmit pin
</span>        // 送信ピン
        porta
            .pa1
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;mut porta.control),
<span class="boring">        // The receive pin
</span>        // 受信ピン
        porta
            .pa0
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;mut porta.control),
<span class="boring">        // No RTS or CTS required
</span>        // RTSとCTSは必要としません
        (),
        (),
<span class="boring">        // The baud rate
</span>        // ボーレート
        115200_u32.bps(),
<span class="boring">        // Output handling
</span>        // 出力制御
        NewlineMode::SwapLFtoCRLF,
<span class="boring">        // We need the clock rates to calculate the baud rate divisors
</span>        // ボーレートの除数を計算するためにクロックレートが必要です
        &amp;clocks,
<span class="boring">        // We need this to power up the UART peripheral
</span>        // UARTペリフェラルの電源を入れるために必要です
        &amp;sc.power_control,
    );

    loop {
        writeln!(uart, &quot;Hello, World!\r\n&quot;).unwrap();
    }
}
</code></pre></pre>
<!-- # Semihosting -->
<h1><a class="header" href="#セミホスティング" id="セミホスティング">セミホスティング</a></h1>
<!--
Semihosting is a mechanism that lets embedded devices do I/O on the host and is
mainly used to log messages to the host console. Semihosting requires a debug
session and pretty much nothing else (no extra wires!) so it's super convenient
to use. The downside is that it's super slow: each write operation can take
several milliseconds depending on the hardware debugger (e.g. ST-Link) you use.
-->
<p>セミホスティングは、組込みデバイスがホスト上でI/Oを行う仕組みです。主に、ホストのコンソールにログ出力するために使われます。
セミホスティングには、デバッグセッションが必要ですが、他には何も必要としません（追加の配線は不要です）。そのため、非常に便利です。
欠点は、非常に低速であることです。ハードウェアデバッガ（例えば、ST-Link）によっては、書き込み操作が数ミリ秒かかります。</p>
<!--
The [`cortex-m-semihosting`] crate provides an API to do semihosting operations
on Cortex-M devices. The program below is the semihosting version of "Hello,
world!":
-->
<p><a href="https://crates.io/crates/cortex-m-semihosting"><code>cortex-m-semihosting</code></a>クレートは、Cortex-Mデバイス上でセミホスティング操作をするためのAPIを提供します。
下のプログラムは、セミホスティングバージョンの「Hello, world!」です。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate panic_halt;

use cortex_m_rt::entry;
use cortex_m_semihosting::hprintln;

#[entry]
fn main() -&gt; ! {
    hprintln!(&quot;Hello, world!&quot;).unwrap();

    loop {}
}
</code></pre></pre>
<!--
If you run this program on hardware you'll see the "Hello, world!" message
within the OpenOCD logs.
-->
<p>このプログラムをハードウェア上で実行すると、OpenOCDのログに、「Hello world!」のメッセージが表示されます。</p>
<pre><code class="language-console">$ openocd
(..)
Hello, world!
(..)
</code></pre>
<!-- You do need to enable semihosting in OpenOCD from GDB first: -->
<p>最初に、GDBからOpenOCDのセミホスティングを有効化する必要があります。</p>
<pre><code class="language-console">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<!--
QEMU understands semihosting operations so the above program will also work with
`qemu-system-arm` without having to start a debug session. Note that you'll
need to pass the `-semihosting-config` flag to QEMU to enable semihosting
support; these flags are already included in the `.cargo/config` file of the
template.
-->
<p>QEMUはセミホスティング操作を理解しているため、上のプログラムは、デバッグセッションを開始していない<code>qemu-system-arm</code>でも動作します。
セミホスティングサポートを有効化するため、QEMUに<code>-semihosting-config</code>フラグを渡す必要があることに注意して下さい。
これらのフラグは、テンプレートの<code>.cargo/config</code>ファイルに既に含まれています。</p>
<pre><code class="language-console">$ # このプログラムは端末をブロックします
$ cargo run
     Running `qemu-system-arm (..)
Hello, world!
</code></pre>
<!--
There's also an `exit` semihosting operation that can be used to terminate the
QEMU process. Important: do **not** use `debug::exit` on hardware; this function
can corrupt your OpenOCD session and you will not be able to debug more programs
until you restart it.
-->
<p><code>exit</code>セミホスティング操作もあり、QEMUプロセスを終了するために使われます。
重要：ハードウェア上で<code>debug::exit</code>を<strong>使用しない</strong>で下さい。この関数は、OpenOCDセッションを破壊する可能性があり、
OpenOCDを再起動しない限り、それ以上のプログラムのデバッグができなくなります。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate panic_halt;

use cortex_m_rt::entry;
use cortex_m_semihosting::debug;

#[entry]
fn main() -&gt; ! {
    let roses = &quot;blue&quot;;

    if roses == &quot;red&quot; {
        debug::exit(debug::EXIT_SUCCESS);
    } else {
        debug::exit(debug::EXIT_FAILURE);
    }

    loop {}
}
</code></pre></pre>
<pre><code class="language-console">$ cargo run
     Running `qemu-system-arm (..)

$ echo $?
1
</code></pre>
<!--
One last tip: you can set the panicking behavior to `exit(EXIT_FAILURE)`. This
will let you write `no_std` run-pass tests that you can run on QEMU.
-->
<p>最後のヒント：パニック時の挙動を、<code>exit(EXIT_FAILURE)</code>に設定することができます。
これで、QEMU上で実行できる<code>no_std</code>ランパステストを書くことができます。</p>
<!--
For convenience, the `panic-semihosting` crate has an "exit" feature that when
enabled invokes `exit(EXIT_FAILURE)` after logging the panic message to the host
stderr.
-->
<p>利便性のために、<code>panic-semihosting</code>クレートは、「exit」フィーチャを持っています。
このフィーチャが有効化されていると、ホストの標準エラーにパニックメッセージをログ出力した後、<code>exit(EXIT_FAILURE)</code>を呼び出します。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate panic_semihosting; // features = [&quot;exit&quot;]

use cortex_m_rt::entry;
use cortex_m_semihosting::debug;

#[entry]
fn main() -&gt; ! {
    let roses = &quot;blue&quot;;

    assert_eq!(roses, &quot;red&quot;);

    loop {}
}
</code></pre></pre>
<pre><code class="language-console">$ cargo run
     Running `qemu-system-arm (..)
panicked at 'assertion failed: `(left == right)`
  left: `&quot;blue&quot;`,
 right: `&quot;red&quot;`', examples/hello.rs:15:5

$ echo $?
1
</code></pre>
<!-- # Panicking -->
<h1><a class="header" href="#パニック" id="パニック">パニック</a></h1>
<!--
Panicking is a core part of the Rust language. Built-in operations like indexing
are runtime checked for memory safety. When out of bounds indexing is attempted
this results in a panic.
-->
<p>パニックはRustのコア部分です。インデックス操作のような言語組込みの操作は、メモリ安全性をランタイム時に検査されます。
範囲外のインデックスにアクセスしようとすると、パニックが発生します。</p>
<!--
In the standard library panicking has a defined behavior: it unwinds the stack
of the panicking thread, unless the user opted for aborting the program on
panics.
-->
<p>標準ライブラリでは、パニックは定義された動作です。ユーザがパニック発生時にプログラムをアボートする選択をしない限り、
パニックを起こしたスレッドのスタックを巻き戻します。</p>
<!--
In non-standard programs, however, the panicking behavior is left undefined. A
behavior can be chosen by declaring a `#[panic_handler]` function. This function
must appear exactly *once* in the dependency graph of a program, and must have
the following signature: `fn(&PanicInfo) -> !`, where [`PanicInfo`] is a struct
containing information about the location of the panic.
-->
<p>しかし、非標準のプログラムでは、パニック時の挙動は、未定義のままです。<code>#[panic_handler]</code>関数を宣言することにより、
挙動を選択することができます。この関数は、プログラムの依存関係グラフに、<strong>1回だけ</strong>現れる必要があります。
そして、 <code>fn(&amp;PanicInfo) -&gt; !</code>のシグネチャを持つ必要があります。
ここで、<a href="https://doc.rust-lang.org/core/panic/struct.PanicInfo.html"><code>PanicInfo</code></a>は、パニックした位置情報を含む構造体です。</p>
<!--
Given that embedded systems range from user facing to safety critical (cannot
crash) there's no one size fits all panicking behavior but there are plenty of
commonly used behaviors. These common behaviors have been packaged into crates
that define the `#[panic_handler]` function. Some examples include:
-->
<p>組込みシステムは、ユーザとやり取りするものから、安全性が重要な（クラッシュできない）ものまであります。
そのため、全てのパニック時動作に対応できる唯一のものはありませんが、よく利用される挙動がたくさんあります。
これらの一般的な挙動が、<code>#[panic_handler]</code>関数を定義するクレートにまとめられています。
いくつか、例を挙げます。</p>
<!--
- [`panic-abort`]. A panic causes the abort instruction to be executed.
- [`panic-halt`]. A panic causes the program, or the current thread, to halt by
  entering an infinite loop.
- [`panic-itm`]. The panicking message is logged using the ITM, an ARM Cortex-M
  specific peripheral.
- [`panic-semihosting`]. The panicking message is logged to the host using the
  semihosting technique.
-->
<ul>
<li><a href="https://crates.io/crates/panic-abort"><code>panic-abort</code></a>。パニックが発生すると、アボート命令を実行します。</li>
<li><a href="https://crates.io/crates/panic-halt"><code>panic-halt</code></a>。パニックが発生すると、プログラム、または、現在のスレッドは、無限ループに入ることで停止します。</li>
<li><a href="https://crates.io/crates/panic-itm"><code>panic-itm</code></a>。パニック発生時のメッセージは、ARM Cortex-M固有のペリフェラルであるITMを使ってログ出力されます。</li>
<li><a href="https://crates.io/crates/panic-semihosting"><code>panic-semihosting</code></a>。パニック発生時のメッセージは、セミホスティングを使ってログ出力されます。</li>
</ul>
<!--
You may be able to find even more crates searching for the [`panic-handler`]
keyword on crates.io.
-->
<p>crates.ioで<a href="https://crates.io/keywords/panic-handler"><code>panic-handler</code></a>をキーワードに検索することで、さらにクレートを見つけることができます。</p>
<!--
A program can pick one of these behaviors simply by linking to the corresponding
crate. The fact that the panicking behavior is expressed in the source of
an application as a single line of code is not only useful as documentation but
can also be used to change the panicking behavior according to the compilation
profile. For example:
-->
<p>プログラムは、対応するクレートとリンクすることで、これらの挙動の中から1つを選びます。
パニック時の挙動がアプリケーションソースコードの中で単一行で表現されていることは、ドキュメントとして有用なだけでなく、
パニック時の挙動をコンパイル時のプロファイルで変更にする時にも利用できます。
例えば</p>
<pre><code class="language-rust ignore">#![no_main]
#![no_std]

<span class="boring">// dev profile: easier to debug panics; can put a breakpoint on `rust_begin_unwind`
</span>// 開発プロファイル：パニックのデバッグを容易にします。`rust_begin_unwind`にブレイクポイントを置くことを可能にします。
#[cfg(debug_assertions)]
extern crate panic_halt;

<span class="boring">// release profile: minimize the binary size of the application
</span>// リリースプロファイル：アプリケーションのバイナリサイズを最小化します。
#[cfg(not(debug_assertions))]
extern crate panic_abort;

// ..
</code></pre>
<!--
In this example the crate links to the `panic-halt` crate when built with the
dev profile (`cargo build`), but links to the `panic-abort` crate when built
with the release profile (`cargo build --release`).
-->
<p>この例では、開発プロファイルでビルド（<code>cargo build</code>）した時は、<code>panic-halt</code>クレートとリンクします。
しかし、リリースプロファイルでビルド（<code>cargo build --release</code>）した時は、<code>panic-abort</code>クレートとリンクします。</p>
<!-- ## An example -->
<h2><a class="header" href="#例" id="例">例</a></h2>
<!--
Here's an example that tries to index an array beyond its length. The operation
results in a panic.
-->
<p>配列の長さを超えてアクセスしようとする例を示します。この操作はパニックを引き起こします。</p>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate panic_semihosting;

use cortex_m_rt::entry;

#[entry]
fn main() -&gt; ! {
    let xs = [0, 1, 2];
    let i = xs.len() + 1;
<span class="boring">//    let _y = xs[i]; // out of bounds access
</span>    let _y = xs[i]; // 範囲外アクセス

    loop {}
}
</code></pre></pre>
<!--
This example chose the `panic-semihosting` behavior which prints the panic
message to the host console using semihosting.
-->
<p>この例では、<code>panic-semihosting</code>の挙動を選択しており、パニックメッセージは、
セミホスティングを使ってホストコンソールに出力されます。</p>
<pre><code class="language-console">$ cargo run
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
panicked at 'index out of bounds: the len is 3 but the index is 4', src/main.rs:12:13
</code></pre>
<!--
You can try changing the behavior to `panic-halt` and confirm that no message is
printed in that case.
-->
<p>挙動を<code>panic-halt</code>に変更し、その場合にメッセージが出力されないことを確認することができます。</p>
<!-- # Exceptions -->
<h1><a class="header" href="#例外" id="例外">例外</a></h1>
<!--
Exceptions, and interrupts, are a hardware mechanism by which the processor
handles asynchronous events and fatal errors (e.g. executing an invalid
instruction). Exceptions imply preemption and involve exception handlers,
subroutines executed in response to the signal that triggered the event.
-->
<p>例外と割り込みは、プロセッサが非同期イベントと致命的なエラー（例えば、不正な命令の実行）を扱うためのハードウェアの仕組みです。
例外はプリエンプションを意味し、例外ハンドラを呼び出します。例外ハンドラは、イベントを引き起こした信号に応答して実行されるサブルーチンです。</p>
<!--
The `cortex-m-rt` crate provides an [`exception`] attribute to declare exception
handlers.
-->
<p><code>cortex-m-rt</code>クレートは、例外ハンドラを宣言するために、<a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html"><code>exception</code></a>アトリビュートを提供しています。</p>
<pre><code class="language-rust ignore"><span class="boring">// Exception handler for the SysTick (System Timer) exception
</span>// SysTick（システムタイマ）例外のための例外ハンドラ
#[exception]
fn SysTick() {
    // ..
}
</code></pre>
<!--
Other than the `exception` attribute exception handlers look like plain
functions but there's one more difference: `exception` handlers can *not* be
called by software. Following the previous example, the statement `SysTick();`
would result in a compilation error.
-->
<p><code>exception</code>属性の他は、例外ハンドラは普通の関数のように見えます。しかし、もう1つ違いがあります。
<code>exception</code>ハンドラはソフトウェアから呼び出すことが<em>できません</em>。前述の例では、<code>SysTick();</code>というステートメントは、
コンパイルエラーになります。</p>
<!--
This behavior is pretty much intended and it's required to provide a feature:
`static mut` variables declared *inside* `exception` handlers are *safe* to use.
-->
<p>この動作は、非常に意図的なものです。
これは<code>exception</code>ハンドラ<em>内</em>で宣言された<code>static mut</code>変数の利用を<em>安全</em>にする、という機能を提供するためのものです。</p>
<pre><code class="language-rust ignore">#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;

<span class="boring">    // `COUNT` has type `&amp;mut u32` and it's safe to use
</span>    // `COUNT`は`&amp;mut u32`の型をもっており、その利用は安全です
    *COUNT += 1;
}
</code></pre>
<!--
As you may know, using `static mut` variables in a function makes it
*non-reentrant*. It's undefined behavior to call a non-reentrant function,
directly or indirectly, from more than one exception / interrupt handler or from
`main` and one or more exception / interrupt handlers.
-->
<p>ご存知かもしれませんが、<code>static mut</code>変数を関数内で使うことは、その関数を<em>再入不可能</em>にします。
直接的または間接的に、複数の例外・割り込みハンドラから、もしくは、<code>main</code>と1つ以上の例外・割り込みハンドラから、
再進入不可能な関数を呼び出すことは、未定義動作です。</p>
<!--
Safe Rust must never result in undefined behavior so non-reentrant functions
must be marked as `unsafe`. Yet I just told that `exception` handlers can safely
use `static mut` variables. How is this possible? This is possible because
`exception` handlers can *not* be called by software thus reentrancy is not
possible.
-->
<p>安全なRustは、決して未定義動作になりません。そのため、再入不可能な関数は、<code>unsafe</code>とマークされなければなりません。
それでも、<code>exception</code>ハンドラは<code>static mut</code>な変数を安全に使える、と述べました。これが可能なのは、どうしてでしょうか。
<code>exception</code>ハンドラはソフトウェアから呼び出すことが<em>できない</em>ため、再入する可能性はありません。だから、安全に使えるのです。</p>
<!-- ## A complete example -->
<h2><a class="header" href="#完全な例" id="完全な例">完全な例</a></h2>
<!--
Here's an example that uses the system timer to raise a `SysTick` exception
roughly every second. The `SysTick` exception handler keeps track of how many
times it has been called in the `COUNT` variable and then prints the value of
`COUNT` to the host console using semihosting.
-->
<p><code>SysTick</code>例外を大体1秒毎に発生させるシステムタイマの例を使います。
<code>SysTick</code>例外ハンドラは、呼び出された回数を<code>COUNT</code>変数に記録し、
セミホスティングを使ってホストコンソールに<code>COUNT</code>の値を出力します。</p>
<!--
> **NOTE**: You can run this example on any Cortex-M device; you can also run it
> on QEMU
-->
<blockquote>
<p><strong>注記</strong>：この例は、どのCortex-Mデバイスでも実行できます。QEMU上でも実行可能です。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#![deny(unsafe_code)]
#![no_main]
#![no_std]

extern crate panic_halt;

use core::fmt::Write;

use cortex_m::peripheral::syst::SystClkSource;
use cortex_m_rt::{entry, exception};
use cortex_m_semihosting::{
    debug,
    hio::{self, HStdout},
};

#[entry]
fn main() -&gt; ! {
    let p = cortex_m::Peripherals::take().unwrap();
    let mut syst = p.SYST;

<span class="boring">    // configures the system timer to trigger a SysTick exception every second
</span>    // 毎秒SysTick例外を起こすためのシステムタイマを設定します
    syst.set_clock_source(SystClkSource::Core);
<span class="boring">    // this is configured for the LM3S6965 which has a default CPU clock of 12 MHz
</span>    // デフォルトのCPUクロックが12MHzのLM3S6965向けの設定です
    syst.set_reload(12_000_000);
    syst.enable_counter();
    syst.enable_interrupt();

    loop {}
}

#[exception]
fn SysTick() {
    static mut COUNT: u32 = 0;
    static mut STDOUT: Option&lt;HStdout&gt; = None;

    *COUNT += 1;

<span class="boring">    // Lazy initialization
</span>    // 遅延初期化
    if STDOUT.is_none() {
        *STDOUT = hio::hstdout().ok();
    }

    if let Some(hstdout) = STDOUT.as_mut() {
        write!(hstdout, &quot;{}&quot;, *COUNT).ok();
    }

<span class="boring">    // IMPORTANT omit this `if` block if running on real hardware or your
</span><span class="boring">    // debugger will end in an inconsistent state
</span>    // 重要。実際のハードウェアで実行するときは`if`ブロックを削除して下さい。そうでなければ、
    // デバッガが不整合な状態に陥るでしょう。
    if *COUNT == 9 {
<span class="boring">        // This will terminate the QEMU process
</span>        // QEMUプロセスを終了します
        debug::exit(debug::EXIT_SUCCESS);
    }
}
</code></pre></pre>
<pre><code class="language-console">$ tail -n5 Cargo.toml
</code></pre>
<pre><code class="language-toml">[dependencies]
cortex-m = &quot;0.5.7&quot;
cortex-m-rt = &quot;0.6.3&quot;
panic-halt = &quot;0.2.0&quot;
cortex-m-semihosting = &quot;0.3.1&quot;
</code></pre>
<pre><code class="language-console">$ cargo run --release
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
123456789
</code></pre>
<!--
If you run this on the Discovery board you'll see the output on the OpenOCD
console. Also, the program will *not* stop when the count reaches 9.
-->
<p>Discoveryボードでこのコードを実行すると、OpenOCDコンソールに出力を確認できるでしょう。
プログラムは、カウントが9に到達しても停止<em>しません</em>。</p>
<!-- ## The default exception handler -->
<h2><a class="header" href="#デフォルト例外ハンドラ" id="デフォルト例外ハンドラ">デフォルト例外ハンドラ</a></h2>
<!--
What the `exception` attribute actually does is *override* the default exception
handler for a specific exception. If you don't override the handler for a
particular exception it will be handled by the `DefaultHandler` function, which
defaults to:
-->
<p><code>exception</code>アトリビュートが実際に行っていることは、特定の例外を処理するデフォルト例外ハンドラの<em>オーバーライド</em>です。
特定の例外について、ハンドラをオーバーライドしない場合、<code>DefaultHandler</code>関数がその例外を処理します。
DefaultHandler関数は下記の通りです。</p>
<pre><code class="language-rust ignore">fn DefaultHandler() {
    loop {}
}
</code></pre>
<!--
This function is provided by the `cortex-m-rt` crate and marked as
`#[no_mangle]` so you can put a breakpoint on "DefaultHandler" and catch
*unhandled* exceptions.
-->
<p>この関数は、<code>cortex-m-rt</code>クレートによって提供されており、<code>#[no_mangle]</code>とマークされています。
そのため、「DefaultHandler」にブレイクポイントを設定することができ、<em>未処理の</em>例外を捕捉することができます。</p>
<!-- It's possible to override this `DefaultHandler` using the `exception` attribute: -->
<p><code>exception</code>アトリビュートを使うことで、<code>DefaultHandler</code>をオーバーライドできます。</p>
<pre><code class="language-rust ignore">#[exception]
fn DefaultHandler(irqn: i16) {
<span class="boring">    // custom default handler
</span>    // カスタムデフォルトハンドラ
}
</code></pre>
<!--
The `irqn` argument indicates which exception is being serviced. A negative
value indicates that a Cortex-M exception is being serviced; and zero or a
positive value indicate that a device specific exception, AKA interrupt, is
being serviced.
-->
<p><code>irqn</code>引数は、どの例外が処理されているかを示します。負の値は、Cortex-Mの例外が処理されていることを意味します。
ゼロまたは正の値は、デバイス固有の例外、すなわち、割り込みが処理されていること、を示しています。</p>
<!-- ## The hard fault handler -->
<h2><a class="header" href="#ハードフォールトハンドラ" id="ハードフォールトハンドラ">ハードフォールトハンドラ</a></h2>
<!--
The `HardFault` exception is a bit special. This exception is fired when the
program enters an invalid state so its handler can *not* return as that could
result in undefined behavior. Also, the runtime crate does a bit of work before
the user defined `HardFault` handler is invoked to improve debuggability.
-->
<p><code>HardFault</code>例外は、少し特別です。この例外は、プログラムが不正な状態になった場合に発生します。
そのため、このハンドラはリターンすることができず、未定義動作を引き起こす可能性があります。
ランタイムクレートは、デバッグ性を向上するために、ユーザ定義の<code>HardFault</code>ハンドラが呼び出される前に、少し仕事をします。</p>
<!--
The result is that the `HardFault` handler must have the following signature:
`fn(&ExceptionFrame) -> !`. The argument of the handler is a pointer to
registers that were pushed into the stack by the exception. These registers are
a snapshot of the processor state at the moment the exception was triggered and
are useful to diagnose a hard fault.
-->
<p>その結果、<code>HardFault</code>ハンドラは、<code>fn(&amp;ExceptionFrame) -&gt; !</code>のシグネチャを持つ必要があります。
ハンドラの引数は、例外によってスタックにプッシュされたレジスタへのポインタです。
これらのレジスタは、例外が発生した瞬間のプロセッサステートのスナップショットで、ハードフォールトの原因を突き止めるのに便利です。</p>
<!--
Here's an example that performs an illegal operation: a read to a nonexistent
memory location.
-->
<p>不正な操作を行う例を示します。存在しないメモリ位置への読み込みです。</p>
<!--
> **NOTE**: This program won't work, i.e. it won't crash, on QEMU because
> `qemu-system-arm -machine lm3s6965evb` doesn't check memory loads and will
> happily return `0 `on reads to invalid memory.
-->
<blockquote>
<p><strong>注記</strong>：このプログラムは、QEMU上ではうまく動きません。つまり、クラッシュしません。
<code>qemu-system-arm -machine lm3s6965evb</code>はメモリの読み込みをチェックしないため、
無効なメモリを読み込むと、幸いにも、<code>0</code>を返します。</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">#![no_main]
#![no_std]

extern crate panic_halt;

use core::fmt::Write;
use core::ptr;

use cortex_m_rt::{entry, exception, ExceptionFrame};
use cortex_m_semihosting::hio;

#[entry]
fn main() -&gt; ! {
<span class="boring">    // read a nonexistent memory location
</span>    // 存在しないメモリ位置を読み込みます
    unsafe {
        ptr::read_volatile(0x3FFF_FFFE as *const u32);
    }

    loop {}
}

#[exception]
fn HardFault(ef: &amp;ExceptionFrame) -&gt; ! {
    if let Ok(mut hstdout) = hio::hstdout() {
        writeln!(hstdout, &quot;{:#?}&quot;, ef).ok();
    }

    loop {}
}
</code></pre></pre>
<!--
The `HardFault` handler prints the `ExceptionFrame` value. If you run this
you'll see something like this on the OpenOCD console.
-->
<p><code>HardFault</code>ハンドラは、<code>ExceptionFrame</code>の値を表示します。実行すると、
OpenOCDコンソールに次のような表示が見えるでしょう。</p>
<pre><code class="language-console">$ openocd
(..)
ExceptionFrame {
    r0: 0x3ffffffe,
    r1: 0x00f00000,
    r2: 0x20000000,
    r3: 0x00000000,
    r12: 0x00000000,
    lr: 0x080008f7,
    pc: 0x0800094a,
    xpsr: 0x61000000
}
</code></pre>
<!--
The `pc` value is the value of the Program Counter at the time of the exception
and it points to the instruction that triggered the exception.
-->
<p><code>pc</code>の値は、例外発生時のプログラムカウンタの値で、例外を引き起こした命令を指しています。</p>
<!-- If you look at the disassembly of the program: -->
<p>プログラムのディスアセンブル結果を見ます。</p>
<pre><code class="language-console">$ cargo objdump --bin app --release -- -d -no-show-raw-insn -print-imm-hex
(..)
ResetTrampoline:
 8000942:       movw    r0, #0xfffe
 8000946:       movt    r0, #0x3fff
 800094a:       ldr     r0, [r0]
 800094c:       b       #-0x4 &lt;ResetTrampoline+0xa&gt;
</code></pre>
<!--
You'll see that a load operation (`ldr r0, [r0]` ) caused the exception and that
the value of the register `r0` was `0x3fff_fffe` at that time. This value
matches the `r0` field of `ExceptionFrame`.
-->
<p>ロード命令（<code>ldr r0, [r0]</code>）が例外を発生させたことがわかります。そして、この時の<code>r0</code>レジスタの値は、
<code>0x3fff_fffe</code>です。この値は、<code>ExceptionFrame</code>の<code>r0</code>フィールドと一致します。</p>
<!-- # Interrupts -->
<h1><a class="header" href="#割り込み" id="割り込み">割り込み</a></h1>
<!--
Interrupts differ from exceptions in a variety of ways but their operation and
use is largely similar and they are also handled by the same interrupt
controller. Whereas exceptions are defined by the Cortex-M architecture,
interrupts are always vendor (and often even chip) specific implementations,
both in naming and functionality.
-->
<p>割り込みは様々な点で例外と違いますが、その動作と使用方法は、ほとんど同じで、同じ割り込みコントローラによって処理されます。
例外がCortex-Mアーキテクチャで定義されているのに対し、割り込みは、命名と機能との両方において、常にベンダ（もっと言うとチップ）固有の実装です。</p>
<!--
Interrupts do allow for a lot of flexibility which needs to be accounted for
when attempting to use them in an advanced way. We will not cover those uses in
this book, however it is a good idea to keep the following in mind:
-->
<p>割り込みは、高度な使い方をしようとする時に必要とされる様々な柔軟性を考慮に入れています。
本書では、そのような高度な使い方は対象外です。しかし、次の点に留意することをお勧めします。</p>
<!-- * Interrupts have programmable priorities which determine their handlers' execution order -->
<ul>
<li>割り込みは、ハンドラの実行順序を決めるプログラム可能な優先度を持ちます。</li>
</ul>
<!-- * Interrupts can nest and preempt, i.e. execution of an interrupt handler might be interrupted by another higher-priority interrupt -->
<ul>
<li>割り込みは、ネストとプリエンプションが可能です。つまり、割り込みハンドラの実行は、より優先度の高い割り込みに割り込まれる場合があります。</li>
</ul>
<!-- * In general the reason causing the interrupt to trigger needs to be cleared to prevent re-entering the interrupt handler endlessly -->
<ul>
<li>通常、割り込み要因は、割り込みハンドラが無限に再呼び出しされないようにするため、クリアされる必要があります。</li>
</ul>
<!--
The general initialization steps at runtime are always the same:
* Setup the peripheral(s) to generate interrupts requests at the desired occasions
* Set the desired priority of the interrupt handler in the interrupt controller
* Enable the interrupt handler in the interrupt controller
-->
<p>ランタイムでの一般的な初期化手順は、常に同じです。</p>
<ul>
<li>必要な時に割り込み要求を起こすように、ペリフェラルを設定します</li>
<li>割り込みコントローラで割り込みハンドラの優先度をセットします</li>
<li>割り込みコントローラで割り込みハンドラを有効化します</li>
</ul>
<!--
Similarly to exceptions, the `cortex-m-rt` crate provides an [`interrupt`]
attribute to declare interrupt handlers. The available interrupts (and
their position in the interrupt handler table) are usually automatically
generated via `svd2rust` from a SVD description.
-->
<p>例外と同様に、例外ハンドラを宣言するために、<code>cortex-m-rt</code>クレートは、<a href="https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html"><code>interrupt</code></a>属性を提供しています。
利用可能な割り込み（そして割り込みハンドラテーブルでの配置）は、通常、<code>svd2rust</code>を使ってSVDから自動生成されます。</p>
<pre><code class="language-rust ignore"><span class="boring">// Interrupt handler for the Timer2 interrupt
</span>// タイマ2割り込みの割り込みハンドラ
#[interrupt]
fn TIM2() {
    // ..
<span class="boring">    // Clear reason for the generated interrupt request
</span>    // 発生した割り込み要求の原因をクリアします
}
</code></pre>
<!--
Interrupt handlers look like plain functions (except for the lack of arguments)
similar to exception handlers. However they can not be called directly by other
parts of the firmware due to the special calling conventions. It is however
possible to generate interrupt requests in software to trigger a diversion to
to the interrupt handler.
-->
<p>割り込みハンドラは、通常の関数のように見え、例外ハンドラに似ています（引数がないことを除いて）。
しかし、割り込みハンドラは、特別な呼び出し規約のため、ファームウェアの他の部分から直接呼び出すことができません。
ソフトウェアで割り込み要求を起こし、割り込みハンドラへの転送を発生させることは可能です。</p>
<!--
Similar to exception handlers it is also possible to declare `static mut`
variables inside the interrupt handlers for *safe* state keeping.
-->
<p>例外ハンドラと同様に、割り込みハンドラ内で<code>static mut</code>変数を宣言し、状態を<em>安全</em>に保持することができます。</p>
<pre><code class="language-rust ignore">#[interrupt]
fn TIM2() {
    static mut COUNT: u32 = 0;

<span class="boring">    // `COUNT` has type `&amp;mut u32` and it's safe to use
</span>    // `COUNT`は`&amp;mut u32`の型を持っており、その使用は安全です
    *COUNT += 1;
}
</code></pre>
<!--
For a more detailed description about the mechanisms demonstrated here please
refer to the [exceptions section].
-->
<p>ここで示した仕組みの詳細については、<a href="start/./exceptions.html">例外セクション</a>を参照して下さい。</p>
<!-- [exceptions section]: ./exceptions.md -->
<h1><a class="header" href="#io" id="io">IO</a></h1>
<blockquote>
<p><strong>TODO</strong> Cover memory mapped I/O using registers.</p>
</blockquote>
<!-- # Peripherals -->
<h1><a class="header" href="#ペリフェラル" id="ペリフェラル">ペリフェラル</a></h1>
<!-- ## What are Peripherals? -->
<h2><a class="header" href="#ペリフェラルとは何か" id="ペリフェラルとは何か">ペリフェラルとは何か？</a></h2>
<!--
Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they contain sections of silicon which are used for interacting with systems outside of the microcontroller, as well as directly and indirectly interacting with their surroundings in the world via sensors, motor controllers, or human interfaces such as a display or keyboard. These components are collectively known as Peripherals.
-->
<p>ほとんどのマイクロコントローラはCPUやRAM、フラッシュメモリ以外のものを持っています。マイクロコントローラはシリコン上に専用のセクションを持っており、そのセクションは、マイクロコントローラの外のシステムとやり取りしたり、センサーやモーターコントローラ、またはディスプレイもしくはキーボードのようなヒューマンインタフェースによって世界中の周囲環境と直接的または間接的にやり取りするために使用されます。それらのコンポーネントはまとめてペリフェラルと呼ばれています。</p>
<!--
These peripherals are useful because they allow a developer to offload processing to them, avoiding having to handle everything in software. Similar to how a desktop developer would offload graphics processing to a video card, embedded developers can offload some tasks to peripherals allowing the CPU to spend its time doing something else important, or doing nothing in order to save power.
-->
<p>これらのペリフェラルは有用です。なぜならば、開発者はペリフェラルに処理をオフロードすることが可能になるため、全ての処理をソフトウェアで行う必要がなくなります。デスクトップ開発者がグラフィック処理をビデオカードにオフロードするのと同じように、組込み開発者は一部のタスクをペリフェラルにオフロードして、CPUの時間を他の重要なことに使ったり、電力を節約するために何もしないようにすることができます。</p>
<!--
If you look at the main circuit board in an old-fashioned home computer from the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so far removed from the embedded systems of today) you would expect to see:
-->
<p>1970年代か1980年代の旧式の家庭用コンピュータのメイン回路基板を見れば（実際に、旧式のデスクトップPCは今日の組込みシステムとさほど違いません）、次のものを目にするはずです。</p>
<!--
* A processor
* A RAM chip
* A ROM chip
* An I/O controller
-->
<ul>
<li>プロセッサ</li>
<li>RAMチップ</li>
<li>ROMチップ</li>
<li>I/Oコントローラ</li>
</ul>
<!--
The RAM chip, ROM chip and I/O controller (the peripheral in this system) would be joined to the processor through a series of parallel traces known as a 'bus'. This bus carries address information, which selects which device on the bus the processor wishes to communicate with, and a data bus which carries the actual data. In our embedded microcontrollers, the same principles apply - it's just that everything is packed on to a single piece of silicon.
-->
<p>RAMチップ、ROMチップ、I/Oコントローラ（このシステムのペリフェラル）は「バス」として知られる一連の並列な配線を通してプロセッサに接続されているでしょう。アドレスバスは、プロセッサがバス上のどのデバイスと通信したいかを選択するアドレス情報を運び、データバスは、実際のデータを運びます。組込みマイクロコントローラにおいても、同じ原理が適用されます。それは全てが１つのシリコン片に詰め込まれているということです。</p>
<!--
However, unlike graphics cards, which typically have a Software API like Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller with a hardware interface, which is mapped to a chunk of the memory.
-->
<p>しかしながら、VulkanやMetal、OpenGLなどのソフトウェアのAPIを通常持つグラフィックカードとは異なり、ペリフェラルはメモリチャンクにマッピングされたハードウェアインターフェースとしてマイクロコントローラに公開されています。</p>
<!-- ## Linear and Real Memory Space -->
<h2><a class="header" href="#線形な実メモリ空間" id="線形な実メモリ空間">線形な実メモリ空間</a></h2>
<!--
On a microcontroller, writing some data to some other arbitrary address, such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid action.
-->
<p>マイクロコントローラでは、<code>0x4000_0000</code>や<code>0x0000_0000</code>のような任意のアドレスにデータを書き込むことは、完全に正当な行為でしょう。</p>
<!--
On a desktop system, access to memory is tightly controlled by the MMU, or Memory Management Unit. This component has two major responsibilities: enforcing access permission to sections of memory (preventing one process from reading or modifying the memory of another process); and re-mapping segments of the physical memory to virtual memory ranges used in software. Microcontrollers do not typically have an MMU, and instead only use real physical addresses in software.
-->
<p>デスクトップシステムでは、メモリアクセスはMMU（メモリ管理ユニット）によって厳密に制御されています。このコンポーネントは２つの主な役割を持っています。メモリのセクションへのアクセス権限の強制（あるプロセスが別のプロセスのメモリを読み出したり変更したりできないようにする）、そして物理メモリのセグメントをソフトウェアで使用される仮想メモリ範囲に再マッピングすることです。マイクロコントローラは通常はMMUを持たず、代わりにソフトウェアで物理アドレスのみを使用します。</p>
<!--
Although 32 bit microcontrollers have a real and linear address space from `0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred kilobytes of that range for actual memory. This leaves a significant amount of address space remaining. In earlier chapters, we were talking about RAM being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. with a maximum address of 0xFFFF) then addresses `0x2000_0000` to `0x2000_FFFF` would correspond to our RAM. When we write to a variable which lives at address `0x2000_1234`, what happens internally is that some logic detects the upper portion of the address (0x2000 in this example) and then activates the RAM so that it can act upon the lower portion of the address (0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 KiB Flash ROM). Rather than ignore all remaining space between these two regions, Microcontroller designers instead mapped the interface for peripherals in certain memory locations. This ends up looking something like this:
-->
<p>32ビットマイクロコントローラは<code>0x0000_0000</code>から<code>0xFFFF_FFFF</code>の線形な実アドレス空間を持ちますが、それらは大抵の場合、実際のメモリのためにはその範囲の数百キロバイトしか使用しません。これにより、かなりの量のアドレス空間が残ります。前の章では、RAMが<code>0x2000_0000</code>のアドレスに配置されていることについて話しました。もしもRAMが64KiBの長さなら（すなわち、最大アドレスが0xFFFF）、<code>0x2000_0000</code>から<code>0x2000_FFFF</code>がRAMのアドレスに対応します。<code>0x2000_1234</code>のアドレスにある変数に書き込むと、内部ではアドレスの上位部分（この例では0x2000）を検出し、アドレスの下位部分（この例では0x1234）に作用できるようにRAMをアクティブにします。Cortex-Mにおいては、フラッシュROMも<code>0x0000_0000</code>から<code>0x0007_FFFF</code>のアドレスにマッピングされています（512KiBのフラッシュROMが載っている場合）。これら２つの領域の間に残るスペースを全て無視するのではなく、代わりにマイクロコントローラの設計者は特定のメモリ配置にペリフェラルのインターフェースをマッピングしました。これは次のようなものになります。</p>
<p><img src="peripherals/../assets/nrf52-memory-map.png" alt="" /></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Nordic nRF52832 Datasheet (pdf)</a></p>
<!-- ## Memory Mapped Peripherals -->
<h2><a class="header" href="#メモリマップドペリフェラル" id="メモリマップドペリフェラル">メモリマップド・ペリフェラル</a></h2>
<!--
Interaction with these peripherals is simple at a first glance - write the right data to the correct address. For example, sending a 32 bit word over a serial port could be as direct as writing that 32 bit word to a certain memory address. The Serial Port Peripheral would then take over and send out the data automatically.
-->
<p>一見すると、これらのペリフェラルとのやり取りは簡単です。正しいデータを正しいアドレスに書き込むだけです。例えば、32ビットワードをシリアルポート上で送信することは、32ビットワードを特定のメモリアドレスに書き込むことと同じくらい直接的になり得ます。シリアルポート・ペリフェラルは自動的にデータを引き受けて送信します。</p>
<!--
Configuration of these peripherals works similarly. Instead of calling a function to configure a peripheral, a chunk of memory is exposed which serves as the hardware API. Write `0x8000_0000` to a SPI Frequency Configuration Register, and the SPI port will send data at 8 Megabits per second. Write `0x0200_0000` to the same address, and the SPI port will send data at 125 Kilobits per second. These configuration registers look a little bit like this:
-->
<p>これらのペリフェラルの設定についても同じように動作します。ペリフェラルの設定をするための関数を呼ぶ代わりに、ハードウェアAPIとして機能するメモリチャンクが公開されます。<code>0x8000_0000</code>をSPI周波数の設定レジスタに書き込むと、SPIポートは8Mbpsでデータを送信するようになります。<code>0x0200_0000</code>を同じアドレスに書き込むと、SPIは125Kbpsでデータを送信するようになります。これらの設定レジスタをちょっとだけ見てみます。</p>
<p><img src="peripherals/../assets/nrf52-spi-frequency-register.png" alt="" /></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Nordic nRF52832 Datasheet (pdf)</a></p>
<!--
This interface is how interactions with the hardware are made, no matter what language is used, whether that language is Assembly, C, or Rust.
-->
<p>アセンブリ言語やC言語、Rustなど、どの言語が使われようとも、このインターフェースがどのように作用するかはハードウェアによって定められています。</p>
<!-- # A First Attempt -->
<h1><a class="header" href="#最初の試み" id="最初の試み">最初の試み</a></h1>
<!-- ## The Registers -->
<h2><a class="header" href="#レジスタ" id="レジスタ">レジスタ</a></h2>
<!--
Let's look at the 'SysTick' peripheral - a simple timer which comes with every Cortex-M processor core. Typically you'll be looking these up in the chip manufacturer's data sheet or *Technical Reference Manual*, but this example is common to all ARM Cortex-M cores, let's look in the [ARM reference manual]. We see there are four registers:
-->
<p><code>SysTick</code> ペリフェラルを見ていきましょう。 <code>SysTick</code> はCortex-Mプロセッサ・コアに搭載されているシンプルなタイマーです。
通常は、チップメーカーのデータシートや<em>テクニカルリファレンスマニュアル</em>でこれらのペリフェラルの情報を調べることができるのですが、この例においては全てのARM Cortex-Mコアで共通のものですので、今回は<a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/Babieigh.html">ARMリファレンスマニュアル</a>を見てみましょう。
そこには4つのレジスタが載っています。</p>
<!--
| Offset | Name        | Description                 | Width  |
|--------|-------------|-----------------------------|--------|
| 0x00   | SYST_CSR    | Control and Status Register | 32 bits|
| 0x04   | SYST_RVR    | Reload Value Register       | 32 bits|
| 0x08   | SYST_CVR    | Current Value Register      | 32 bits|
| 0x0C   | SYST_CALIB  | Calibration Value Register  | 32 bits|
-->
<table><thead><tr><th>オフセット</th><th>名前</th><th>説明</th><th>幅</th></tr></thead><tbody>
<tr><td>0x00</td><td>SYST_CSR</td><td>制御およびステータスレジスタ</td><td>32ビット</td></tr>
<tr><td>0x04</td><td>SYST_RVR</td><td>リロード値レジスタ</td><td>32ビット</td></tr>
<tr><td>0x08</td><td>SYST_CVR</td><td>現在値レジスタ</td><td>32ビット</td></tr>
<tr><td>0x0C</td><td>SYST_CALIB</td><td>キャリブレーション値レジスタ</td><td>32ビット</td></tr>
</tbody></table>
<!-- ## The C Approach -->
<h2><a class="header" href="#cアプローチ" id="cアプローチ">Cアプローチ</a></h2>
<!--
In Rust, we can represent a collection of registers in exactly the same way as we do in C - with a `struct`.
-->
<p>Rustでも、<code>struct</code>を使ってCと同じ方法でレジスタの集合を正確に表現することができます。</p>
<pre><code class="language-rust ignore">#[repr(C)]
struct SysTick {
    pub csr: u32,
    pub rvr: u32,
    pub cvr: u32,
    pub calib: u32,
}
</code></pre>
<!--
The qualifier `#[repr(C)]` tells the Rust compiler to lay this structure out like a C compiler would. That's very important, as Rust allows structure fields to be re-ordered, while C does not. You can imagine the debugging we'd have to do if these fields were silently re-arranged by the compiler! With this qualifier in place, we have our four 32-bit fields which correspond to the table above. But of course, this `struct` is of no use by itself - we need a variable.
-->
<p><code>#[repr(C)]</code>修飾子はRustコンパイラ対して、この構造体をCコンパイラと同じようにメモリにレイアウトするように指示します。
これはとても重要なことです。なぜならRustでは、Cにおいては行われない構造体のフィールドの並び替えが許されているためです。
コンパイラによって暗黙のうちに構造体のフィールドが並び替えられることにより、デバッグをするはめになることは想像できるでしょう！
この修飾子を置くことで、4つの32ビットの各フィールドは上記のテーブルに対応付けられます。
ただしもちろん、この<code>struct</code>はそれ自体では何の役にも立ちません。次のように変数として使う必要があります。</p>
<pre><code class="language-rust ignore">let systick = 0xE000_E010 as *mut SysTick;
let time = unsafe { (*systick).cvr };
</code></pre>
<!-- ## Volatile Accesses -->
<h2><a class="header" href="#volatileアクセス" id="volatileアクセス">volatileアクセス</a></h2>
<!--
Now, there are a couple of problems with the approach above.
-->
<p>上記のやり方には、いくつか問題があります。</p>
<!--
1. We have to use unsafe every time we want to access our Peripheral.
2. We've got no way of specifying which registers are read-only or read-write.
3. Any piece of code anywhere in your program could access the hardware
   through this structure.
4. Most importantly, it doesn't actually work...
-->
<ol>
<li>ペリフェラルにアクセスするためには毎回アンセーフを使わなくてはなりません。</li>
<li>どのレジスタが読み取り専用でどのレジスタが読み書き可能かを指定する方法がありません。</li>
<li>プログラム内のどのコードからでもこの構造体を通してハードウェアにアクセスできてしまいます。</li>
<li>最も大事なことは、このコードは実際には動作しないということです…</li>
</ol>
<!--
Now, the problem is that compilers are clever. If you make two writes to the same piece of RAM, one after the other, the compiler can notice this and just skip the first write entirely. In C, we can mark variables as `volatile` to ensure that every read or write occurs as intended. In Rust, we instead mark the *accesses* as volatile, not the variable.
-->
<p>ここで問題となるのは、コンパイラが賢いということです。
同じRAMに相次いで２回書き込むと、コンパイラはこれに気づき、最初の書き込みを完全にスキップします。
Cでは、全ての読み書きが意図した通りに行われることを保証するために、<code>volatile</code>型修飾子を変数につけることができます。
Rustでは、変数ではなく<em>アクセス</em>に対してvolatileをつけます。</p>
<pre><code class="language-rust ignore">let systick = unsafe { &amp;mut *(0xE000_E010 as *mut SysTick) };
let time = unsafe { core::ptr::read_volatile(&amp;mut systick.cvr) };
</code></pre>
<!--
So, we've fixed one of our four problems, but now we have even more `unsafe` code! Fortunately, there's a third party crate which can help - [`volatile_register`].
-->
<p>これで4つの問題のうち1つを直せました。しかし、さらに<code>unafe</code>なコードがあります！
幸いなことに、これに対処できるサードパーティ製のクレート<a href="https://crates.io/crates/volatile_register"><code>volatile_register</code></a>があります。</p>
<pre><code class="language-rust ignore">use volatile_register::{RW, RO};

#[repr(C)]
struct SysTick {
    pub csr: RW&lt;u32&gt;,
    pub rvr: RW&lt;u32&gt;,
    pub cvr: RW&lt;u32&gt;,
    pub calib: RO&lt;u32&gt;,
}

fn get_systick() -&gt; &amp;'static mut SysTick {
    unsafe { &amp;mut *(0xE000_E010 as *mut SysTick) }
}

fn get_time() -&gt; u32 {
    let systick = get_systick();
    systick.cvr.read()
}
</code></pre>
<!--
Now, the volatile accesses are performed automatically through the `read` and `write` methods. It's still `unsafe` to perform writes, but to be fair, hardware is a bunch of mutable state and there's no way for the compiler to know whether these writes are actually safe, so this is a good default position.
-->
<p>これで<code>read</code>と<code>write</code>メソッドを通してvolatileアクセスが自動的に行われるようになりました。
書き込みを実行するのはまだ<code>unsafe</code>です。しかし、公平を期するために言うと、ハードウェアは変更可能な状態の集まりであるため、それらへの書き込みが実際に安全なのかどうか、をコンパイラが知る方法はないのです。そのため、これは基本姿勢としては悪くないでしょう。</p>
<!-- ## The Rusty Wrapper -->
<h2><a class="header" href="#rustのラッパ" id="rustのラッパ">Rustのラッパ</a></h2>
<!--
We need to wrap this `struct` up into a higher-layer API that is safe for our users to call. As the driver author, we manually verify the unsafe code is correct, and then present a safe API for our users so they don't have to worry about it (provided they trust us to get it right!).
-->
<p>ユーザが安全に呼び出せるように、この<code>struct</code>を高レイヤーのAPIでラップする必要があります。
ドライバの作者として、アンセーフなコードが正しいことを手動で検証し、ユーザがそのドライバを使用する上で心配することがないように安全なAPIとして提供します。（ユーザは提供されたものが正しいと信頼しています！）</p>
<!--
One example might be:
-->
<p>一例を挙げます。</p>
<pre><code class="language-rust ignore">use volatile_register::{RW, RO};

pub struct SystemTimer {
    p: &amp;'static mut RegisterBlock
}

#[repr(C)]
struct RegisterBlock {
    pub csr: RW&lt;u32&gt;,
    pub rvr: RW&lt;u32&gt;,
    pub cvr: RW&lt;u32&gt;,
    pub calib: RO&lt;u32&gt;,
}

impl SystemTimer {
    pub fn new() -&gt; SystemTimer {
        SystemTimer {
            p: unsafe { &amp;mut *(0xE000_E010 as *mut RegisterBlock) }
        }
    }

    pub fn get_time(&amp;self) -&gt; u32 {
        self.p.cvr.read()
    }

    pub fn set_reload(&amp;mut self, reload_value: u32) {
        unsafe { self.p.rvr.write(reload_value) }
    }
}

pub fn example_usage() -&gt; String {
    let mut st = SystemTimer::new();
    st.set_reload(0x00FF_FFFF);
    format!(&quot;Time is now 0x{:08x}&quot;, st.get_time())
}
</code></pre>
<!--
Now, the problem with this approach is that the following code is perfectly acceptable to the compiler:
-->
<p>このやり方の問題は、次のコードがコンパイラに完全に受け入れられることです。</p>
<pre><code class="language-rust ignore">fn thread1() {
    let mut st = SystemTimer::new();
    st.set_reload(2000);
}

fn thread2() {
    let mut st = SystemTimer::new();
    st.set_reload(1000);
}
</code></pre>
<!--
Our `&mut self` argument to the `set_reload` function checks that there are no other references to *that* particular `SystemTimer` struct, but they don't stop the user creating a second `SystemTimer` which points to the exact same peripheral! Code written in this fashion will work if the author is diligent enough to spot all of these 'duplicate' driver instances, but once the code is spread out over multiple modules, drivers, developers, and days, it gets easier and easier to make these kinds of mistakes.
-->
<p><code>set_reload</code>関数に<code>&amp;mut self</code>引数を渡すことで、<em>その</em>インスタンスの<code>SystemTimer</code>構造体に対する他の参照がないことを確認しますが、全く同じペリフェラルを指す２つ目の<code>SystemTimer</code>構造体をユーザが作ることは止められません！
このように書かれたコードは、作者がこれらの「重複した」ドライバのインスタンスを全て見つけるのに十分に熱心であれば動作するでしょうが、一度コードが複数のモジュール、ドライバ、開発者、そして日に渡って分散すると、この種の間違いがどんどん入り込みやすくなっていきます。</p>
<!-- ## Mutable Global State -->
<h2><a class="header" href="#ミュータブルでグローバルな状態" id="ミュータブルでグローバルな状態">ミュータブルでグローバルな状態</a></h2>
<!--
Unfortunately, hardware is basically nothing but mutable global state, which can feel very frightening for a Rust developer. Hardware exists independently from the structures of the code we write, and can be modified at any time by the real world.
-->
<p>残念ながら、ハードウェアは基本的にミュータブルでグローバルな状態に他なりません。これはRustの開発者にとって非常に恐ろしいことです。
ハードウェアは書かれたコードの構造とは独立して存在しており、現実の世界からいつでも変更される可能性があります。</p>
<!-- ## What should our rules be? -->
<h2><a class="header" href="#何をルールとするべきか" id="何をルールとするべきか">何をルールとするべきか？</a></h2>
<!--
How can we reliably interact with these peripherals?
-->
<p>どうすればこれらのペリフェラルと確実にやり取りできるのでしょう？</p>
<!--
1. Always use `volatile` methods to read or write to peripheral memory, as it can change at any time
2. In software, we should be able to share any number of read-only accesses to these peripherals
3. If some software should have read-write access to a peripheral, it should hold the only reference to that peripheral
-->
<ol>
<li>いつ変化するかわからないペリフェラルメモリの読み書きには、常に<code>volatile</code>メソッドを使用してください</li>
<li>ソフトウェアでは、これらのペリフェラルへの読み取り専用アクセスをいくつでも共有できるでしょう</li>
<li>あるソフトウェアがあるペリフェラルに読み書きのアクセスをするならば、そのソフトウェアは、ペリフェラルへの唯一の参照を持つべきです</li>
</ol>
<!-- ## The Borrow Checker -->
<h2><a class="header" href="#借用チェッカ" id="借用チェッカ">借用チェッカ</a></h2>
<!--
The last two of these rules sound suspiciously similar to what the Borrow Checker does already!
-->
<p>さきほどのルールの最後の２つは、借用チェッカが行っていることに怪しいくらいよく似ています。</p>
<!--
Imagine if we could pass around ownership of these peripherals, or offer immutable or mutable references to them?
-->
<p>ペリフェラルの所有権を譲渡したり、ペリフェラルへのイミュータブルまたはミュータブルな参照を提供したりできるのか、を想像してみてください。</p>
<!--
Well, we can, but for the Borrow Checker, we need to have exactly one instance of each peripheral, so Rust can handle this correctly. Well, luckliy in the hardware, there is only one instance of any given peripheral, but how can we expose that in the structure of our code?
-->
<p>それは可能です。ただし、借用チェッカが正しくペリフェラルの所有権や参照を扱うためには、各ペリフェラルが持つインスタンスはただ１つにする必要があります。そうすれば、Rustはこれを正しく扱えます。
幸いなことにハードウェアにおいて、任意のペリフェラルのインスタンスは１つだけしかありません。しかし、どうすればそれをコードの構造として明確にできるでしょうか？</p>
<!-- # Singletons -->
<h1><a class="header" href="#シングルトン" id="シングルトン">シングルトン</a></h1>
<!--
> In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object.
>
> *Wikipedia: [Singleton Pattern]*
-->
<blockquote>
<p>ソフトウェア工学において、シングルトン・パターンはクラスのインスタンス化を１つのオブジェクトに制限するデザインパターンです。</p>
<p><em>Wikipedia: <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton Pattern</a></em></p>
</blockquote>
<!-- ## But why can't we just use global variable(s)? -->
<h2><a class="header" href="#なぜグローバル変数は使えないのか" id="なぜグローバル変数は使えないのか">なぜグローバル変数は使えないのか？</a></h2>
<!--
We could make everything a public static, like this
-->
<p>このように、全てをパブリックかつスタティックにすることができます。</p>
<pre><pre class="playground"><code class="language-rust">static mut THE_SERIAL_PORT: SerialPort = SerialPort;

fn main() {
    let _ = unsafe {
        THE_SERIAL_PORT.read_speed();
    }
}
</code></pre></pre>
<!--
But this has a few problems. It is a mutable global variable, and in Rust, these are always unsafe to interact with. These variables are also visible across your whole program, which means the borrow checker is unable to help you track references and ownership of these variables.
-->
<p>しかし、これにはいくつか問題があります。
これはミュータブルなグローバル変数であり、Rustにおいては、これらとやり取りするのは常にアンセーフです。
これらの変数はプログラムの全体を通して見えることになり、つまりそれは借用チェッカがこれらの変数の参照や所有権を追跡するのに役立たなくなることを意味します。</p>
<!-- ## How do we do this in Rust? -->
<h2><a class="header" href="#rustではどうするか" id="rustではどうするか">Rustではどうするか？</a></h2>
<!--
Instead of just making our peripheral a global variable, we might instead decide to make a global variable, in this case called `PERIPHERALS`, which contains an `Option<T>` for each of our peripherals.
-->
<p>単にペリフェラルをグローバル変数にする代わりに、各ペリフェラル毎に<code>Option&lt;T&gt;</code>を含む<code>PERIPHERALS</code>と呼ばれるグローバル変数を作ることにします。</p>
<pre><code class="language-rust ignore">struct Peripherals {
    serial: Option&lt;SerialPort&gt;,
}
impl Peripherals {
    fn take_serial(&amp;mut self) -&gt; SerialPort {
        let p = replace(&amp;mut self.serial, None);
        p.unwrap()
    }
}
static mut PERIPHERALS: Peripherals = Peripherals {
    serial: Some(SerialPort),
};
</code></pre>
<!--
This structure allows us to obtain a single instance of our peripheral. If we try to call `take_serial()` more than once, our code will panic!
-->
<p>この構造体によって、ペリフェラルの唯一のインスタンスが取得できるようになります。
もしも<code>take_serial()</code>を複数回呼び出そうとすれば、コードはパニックするでしょう。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let serial_1 = unsafe { PERIPHERALS.take_serial() };
<span class="boring">   // This panics!
</span>    // これはパニックします！
    // let serial_2 = unsafe { PERIPHERALS.take_serial() };
}
</code></pre></pre>
<!--
Although interacting with this structure is `unsafe`, once we have the `SerialPort` it contained, we no longer need to use `unsafe`, or the `PERIPHERALS` structure at all.
-->
<p>この構造体とのやり取りは<code>unsafe</code>にはなりますが、一度この構造体に含まれる<code>SerialPort</code>を取得してしまえばもう<code>unsafe</code>や<code>PERIPHERALS</code>構造体を使う必要は全くありません。</p>
<!--
This has a small runtime overhead because we must wrap the `SerialPort` structure in an option, and we'll need to call `take_serial()` once, however this small up-front cost allows us to leverage the borrow checker throughout the rest of our program.
-->
<p>この方法では、オプション型の中に<code>SerialPort</code>構造体をラップし、<code>take_serial()</code>を一度コールする必要があるため、実行時に小さなオーバーヘッドとなります。
しかし、この少々のコストを前払いすることで、残りのプログラムで借用チェッカを利用できるようになるのです。</p>
<!-- ## Existing library support -->
<h2><a class="header" href="#既存のライブラリによるサポート" id="既存のライブラリによるサポート">既存のライブラリによるサポート</a></h2>
<!-- Although we created our own `Peripherals` structure above, it is not necessary to do this for your code. the `cortex_m` crate contains a macro called `singleton!()` that will perform this action for you. -->
<p>上記のコードでは<code>Peripherals</code>構造体を作りましたが、あなたのコードでも同じようにする必要はありません。
<code>cortex_m</code>クレートはこれと同様のことをしてくれる<code>singleton!()</code>と呼ばれるマクロを含んでいます。</p>
<pre><pre class="playground"><code class="language-rust">#[macro_use(singleton)]
extern crate cortex_m;

fn main() {
<span class="boring">   // OK if `main` is executed only once,
</span>    // `main`が一度だけしか実行されなければOKです
    let x: &amp;'static mut bool =
        singleton!(: bool = false).unwrap();
}
</code></pre></pre>
<p><a href="https://docs.rs/cortex-m/latest/cortex_m/macro.singleton.html">cortex_m docs</a></p>
<!--
Additionally, if you use `cortex-m-rtfm`, the entire process of defining and obtaining these peripherals are abstracted for you, and you are instead handed a `Peripherals` structure that contains a non-`Option<T>` version of all of the items you define.
-->
<p>加えて、あなたが<code>cortex-m-rtfm</code>クレートを使うのなら、これらのペリフェラルを定義・取得するプロセス全体は抽象化され、代わりにあなたが定義した全てのアイテムが、<code>Option&lt;T&gt;</code>なしで含まれている<code>Peripherals</code>構造体を手渡されます。</p>
<pre><code class="language-rust ignore">// cortex-m-rtfm v0.3.x
app! {
    resources: {
        static RX: Rx&lt;USART1&gt;;
        static TX: Tx&lt;USART1&gt;;
    }
}
fn init(p: init::Peripherals) -&gt; init::LateResources {
<span class="boring">   // Note that this is now an owned value, not a reference
</span>    // これは所有された値であり、参照ではないことに注意してください
    let usart1: USART1 = p.device.USART1;
}
</code></pre>
<p><a href="https://blog.japaric.io/rtfm-v3/">japaric.io rtfm v3</a></p>
<!-- ## But why? -->
<h2><a class="header" href="#しかしなぜ" id="しかしなぜ">しかしなぜ？</a></h2>
<!--
But how do these Singletons make a noticeable difference in how our Rust code works?
-->
<p>しかし、これらのシングルトンがRustのコードの動作にどのような顕著な違いをもたらすのでしょうか？</p>
<pre><code class="language-rust ignore">impl SerialPort {
    const SER_PORT_SPEED_REG: *mut u32 = 0x4000_1000 as _;

    fn read_speed(
<span class="boring">       &amp;self // &lt;------ This is really, really important
</span>        &amp;self // &lt;------ これは本当に、本当に重要です。
    ) -&gt; u32 {
        unsafe {
            ptr::read_volatile(Self::SER_PORT_SPEED_REG)
        }
    }
}
</code></pre>
<!--
There are two important factors in play here:
-->
<p>ここには２つの重要な要素があります。</p>
<!--
* Because we are using a singleton, there is only one way or place to obtain a `SerialPort` structure
* To call the `read_speed()` method, we must have ownership or a reference to a `SerialPort` structure
-->
<ul>
<li>シングルトンを使用しているため、<code>SerialPort</code>構造体の取得手段や場所は１つだけになります。</li>
<li><code>read_speed()</code>メソッドを呼ぶためには、<code>SerialPort</code>構造体の所有権もしくは参照を持つ必要があります。</li>
</ul>
<!--
These two factors put together means that it is only possible to access the hardware if we have appropriately satisfied the borrow checker, meaning that at no point do we have multiple mutable references to the same hardware!
-->
<p>これらの２つの要素をまとめると、借用チェッカを適切に満たしている場合のみハードウェアにアクセスできることを意味します。つまり、同じハードウェアに対して複数のミュータブルな参照を持つことはありません。</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
<span class="boring">   // missing reference to `self`! Won't work.
</span>    // `self`への参照が見つかりません。これはうまく動きません。
    // SerialPort::read_speed();

    let serial_1 = unsafe { PERIPHERALS.take_serial() };

<span class="boring">   // you can only read what you have access to
</span>    // アクセスできるものだけ読み出すことができます。
    let _ = serial_1.read_speed();
}
</code></pre></pre>
<!-- ## Treat your hardware like data -->
<h2><a class="header" href="#ハードウェアをデータのように扱う" id="ハードウェアをデータのように扱う">ハードウェアをデータのように扱う</a></h2>
<!--
Additionally, because some references are mutable, and some are immutable, it becomes possible to see whether a function or method could potentially modify the state of the hardware. For example,
-->
<p>加えて、いくつかの参照はミュータブルで、またいくつかはイミュータブルなため、関数またはメソッドがハードウェアの状態を変更できるかどうかを確認することが可能になります。</p>
<!--
This is allowed to change hardware settings:
-->
<p>この関数はハードウェアの設定を変更できます。</p>
<pre><code class="language-rust ignore">fn setup_spi_port(
    spi: &amp;mut SpiPort,
    cs_pin: &amp;mut GpioPin
) -&gt; Result&lt;()&gt; {
    // ...
}
</code></pre>
<!--
This isn't:
-->
<p>このメソッドは変更できません。</p>
<pre><code class="language-rust ignore">fn read_button(gpio: &amp;GpioPin) -&gt; bool {
    // ...
}
</code></pre>
<!--
This allows us to enforce whether code should or should not make changes to hardware at **compile time**, rather than at runtime. As a note, this generally only works across one application, but for bare metal systems, our software will be compiled into a single application, so this is not usually a restriction.
-->
<p>これにより、実行時ではなく<strong>コンパイル時に</strong>コードがハードウェアを変更するかどうかを強制できます。
注意点としては、通常この強制はひとつのアプリケーション内でのみ機能します。ベアメタルシステムにおいては、ソフトウェアはひとつのアプリケーションにコンパイルされるため、これは一般的には制約にはなりません。</p>
<!-- # Static Guarantees -->
<h1><a class="header" href="#静的な保証" id="静的な保証">静的な保証</a></h1>
<!--
It's Rust's type system what prevents data races at compile time (see [`Send`]
and [`Sync`] traits). The type system can also be used to check other properties
at compile time; reducing the need for runtime checks in some cases.
-->
<p>コンパイル時にデータ競合を防ぐのは、Rustの型システムです（<a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code>Send</code></a>と<a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code>Sync</code></a>トレイトを参照）。
この型システムは、コンパイル時に他のプロパティをチェックするためにも使用できます。
その結果、実行時チェックの必要性を減らせる場合があります。</p>
<!--
When applied to embedded programs these *static checks* can be used, for
example, to enforce that configuration of I/O interfaces is done properly. For
instance, one can design an API where it is only possible to initialize a serial
interface by first configuring the pins that will be used by the interface.
-->
<p>組込みプログラムに適用する場合、これらの<em>静的なチェック</em>は、例えば、入出力インタフェースが正しく設定されていることを強制することができます。
例えば、使用されるピンを最初に設定することによってのみ、シリアルインタフェースを初期化できるようなAPI設計が可能です。</p>
<!--
One can also statically check that operations, like setting a pin low, can only
be performed on correctly configured peripherals. For example, trying to change
the output state of a pin configured in floating input mode would raise a
compile error.
-->
<p>正しく設定されたペリフェラルでのみ、ピンをローレベルにするというような操作ができることを、
静的にチェックすることも可能です。例えば、フローティング入力モードに設定されたピンの出力状態を変更しようとすると、
コンパイルエラーが発生します。</p>
<blockquote>
<p>訳注：フローティング入力モードは、ピンをハイインピーダンスの入力モードにしていることを意味しています。</p>
</blockquote>
<!--
And, as seen in the previous chapter, the concept of ownership can be applied
to peripherals to ensure that only certain parts of a program can modify a
peripheral. This *access control* makes software easier to reason about
compared to the alternative of treating peripherals as global mutable state.
-->
<!-- reasonは推論する、という意味で使われているようですが、ソフトウェアの推論、では意味が捉えにくいため、解析、と訳しました。 -->
<p>以前の章で見た通り、所有権の概念はペリフェラルにも適用できます。所有権は、プログラムの特定部分のみがペリフェラルを変更することを保証します。
この<em>アクセスコントロール</em>は、ペリフェラルをグローバルでミュータブルな状態として扱う代替案と比較して、
ソフトウェアの解析をより簡単にします。</p>
<!-- # Typestate Programming -->
<h1><a class="header" href="#型状態プログラミング" id="型状態プログラミング">型状態プログラミング</a></h1>
<!--
The concept of [typestates] describes the encoding of information about the current state of an object into the type of that object. Although this can sound a little arcane, if you have used the [Builder Pattern] in Rust, you have already started using Typestate Programming!
-->
<p><a href="https://en.wikipedia.org/wiki/Typestate_analysis">型状態</a>の概念は、オブジェクトの現在の状態に関する情報を、そのオブジェクトの型にエンコードすることを説明しています。
これは、少し難解に思えますが、Rustの<a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">ビルダーパターン</a>を使ったことがあるならば、既に型状態プログラミングを使い始めています。</p>
<!--
[typestates]: https://en.wikipedia.org/wiki/Typestate_analysis
[Builder Pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
-->
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Foo {
    inner: u32,
}

struct FooBuilder {
    a: u32,
    b: u32,
}

impl FooBuilder {
    pub fn new(starter: u32) -&gt; Self {
        Self {
            a: starter,
            b: starter,
        }
    }

    pub fn double_a(self) -&gt; Self {
        Self {
            a: self.a * 2,
            b: self.b,
        }
    }

    pub fn into_foo(self) -&gt; Foo {
        Foo {
            inner: self.a + self.b,
        }
    }
}

fn main() {
    let x = FooBuilder::new(10)
        .double_a()
        .into_foo();

    println!(&quot;{:#?}&quot;, x);
}
</code></pre></pre>
<!--
In this example, there is no direct way to create a `Foo` object. We must create a `FooBuilder`, and properly initialize it before we can obtain the `Foo` object we want.
-->
<p>この例では、<code>Foo</code>オブジェクトを直接作る方法はありません。必要な<code>Foo</code>オブジェクトを取得する前に、<code>FooBuilder</code>を作り、正しく初期化しなければなりません。</p>
<!-- This minimal example encodes two states: -->
<p>この最小限の例は、2つの状態をエンコードしています。</p>
<!--
* `FooBuilder`, which represents an "unconfigured", or "configuration in process" state
* `Foo`, which represents a "configured", or "ready to use" state.
-->
<ul>
<li><code>FooBuilder</code>は、「未設定」もしくは「設定中」の状態を表現します。</li>
<li><code>Foo</code>は、「設定済み」もしくは「使用準備完了」の状態を意味します。</li>
</ul>
<!-- ## Strong Types -->
<h2><a class="header" href="#強い型" id="強い型">強い型</a></h2>
<!--
Because Rust has a [Strong Type System], there is no easy way to magically create an instance of `Foo`, or to turn a `FooBuilder` into a `Foo` without calling the `into_foo()` method. Additionally, calling the `into_foo()` method consumes the original `FooBuilder` structure, meaning it can not be reused without the creation of a new instance.
-->
<p>Rustは<a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">強い型付けシステム</a>を持っています。<code>Foo</code>のインスタンスを魔法のように作成したり、
<code>into_foo()</code>メソッドを呼び出すことなしに<code>FooBuilder</code>から<code>Foo</code>に変換したりする、簡単な方法はありません。
さらに、<code>into_foo()</code>メソッドは、オリジナルの<code>FooBuilder</code>構造体を消費します。
これは、新しいインスタンスを作成しないと、再利用ができないことを意味します。</p>
<!-- [Strong Type System]: https://en.wikipedia.org/wiki/Strong_and_weak_typing -->
<!--
This allows us to represent the states of our system as types, and to include the necessary actions for state transitions into the methods that exchange one type for another. By creating a `FooBuilder`, and exchanging it for a `Foo` object, we have walked through the steps of a basic state machine.
-->
<p>このことにより、システムの状態を型として表現することが可能になります。
そして、状態遷移に必要なアクションを、ある型と別の型とを交換するメソッドに取り入れることができます。
<code>FooBuilder</code>を作成し、<code>Foo</code>オブジェクトに交換することで、基本的なステートマシンのステップを見てきました。</p>
<!-- # Peripherals as State Machines -->
<h1><a class="header" href="#ステートマシンとしてのペリフェラル" id="ステートマシンとしてのペリフェラル">ステートマシンとしてのペリフェラル</a></h1>
<!--
The peripherals of a microcontroller can be thought of as set of state machines. For example, the configuration of a simplified [GPIO pin] could be represented as the following tree of states:
-->
<p>マイクロコントローラのペリフェラルは、一連のステートマシンとして考えることができます。
例えば、簡略化された<a href="https://en.wikipedia.org/wiki/General-purpose_input/output">GPIOピン</a>の設定は、次の状態ツリーとして表すことができます。</p>
<!-- [GPIO pin]: https://en.wikipedia.org/wiki/General-purpose_input/output -->
<!--
* Disabled
* Enabled
    * Configured as Output
        * Output: High
        * Output: Low
    * Configured as Input
        * Input: High Resistance
        * Input: Pulled Low
        * Input: Pulled High
-->
<ul>
<li>無効</li>
<li>有効
<ul>
<li>出力として設定
<ul>
<li>出力：ハイ</li>
<li>出力：ロー</li>
</ul>
</li>
<li>入力として設定
<ul>
<li>入力：高抵抗（訳注：ハイインピーダンス）</li>
<li>入力：プルダウン</li>
<li>入力：プルアップ</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- If the peripheral starts in the `Disabled` mode, to move to the `Input: High Resistance` mode, we must perform the following steps: -->
<p>このペリフェラルが<code>無効</code>モードから始まるとすると、<code>入力：高抵抗</code>モードに移行するには、次のステップを踏みます。</p>
<!--
1. Disabled
2. Enabled
3. Configured as Input
4. Input: High Resistance
-->
<ol>
<li>無効</li>
<li>有効</li>
<li>入力として設定</li>
<li>入力：高抵抗</li>
</ol>
<!-- If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, we must perform the following steps: -->
<p><code>入力：高抵抗</code>から<code>入力：プルダウン</code>へと移る場合、次のステップを実行しなければなりません。</p>
<!--
1. Input: High Resistance
2. Input: Pulled Low
-->
<ol>
<li>入力：高抵抗</li>
<li>入力：プルダウン</li>
</ol>
<!-- Similarly, if we want to move a GPIO pin from configured as `Input: Pulled Low` to `Output: High`, we must perform the following steps: -->
<p>同じように、<code>入力：プルダウン</code>と設定されているGPIOピンを、<code>出力：ハイ</code>にするには、次のステップを実行しなければなりません。</p>
<!--
1. Input: Pulled Low
2. Configured as Input
3. Configured as Output
4. Output: High
-->
<ol>
<li>入力：プルダウン</li>
<li>入力として設定</li>
<li>出力として設定</li>
<li>出力：ハイ</li>
</ol>
<!-- ## Hardware Representation -->
<h2><a class="header" href="#ハードウェアの表現" id="ハードウェアの表現">ハードウェアの表現</a></h2>
<!--
Typically the states listed above are set by writing values to given registers mapped to a GPIO peripheral. Let's define an imaginary GPIO Configuration Register to illustrate this:
-->
<p>通常、上記の状態は、GPIOペリフェラルに割り当てられたレジスタに値を書き込むことで設定できます。
これを説明するために、架空のGPIO設定レジスタを定義しましょう。</p>
<!--
| Name         | Bit Number(s) | Value | Meaning   | Notes |
| ---:         | ------------: | ----: | ------:   | ----: |
| enable       | 0             | 0     | disabled  | Disables the GPIO |
|              |               | 1     | enabled   | Enables the GPIO |
| direction    | 1             | 0     | input     | Sets the direction to Input |
|              |               | 1     | output    | Sets the direction to Output |
| input_mode   | 2..3          | 00    | hi-z      | Sets the input as high resistance |
|              |               | 01    | pull-low  | Input pin is pulled low |
|              |               | 10    | pull-high | Input pin is pulled high |
|              |               | 11    | n/a       | Invalid state. Do not set |
| output_mode  | 4             | 0     | set-low   | Output pin is driven low |
|              |               | 1     | set-high  | Output pin is driven high |
| input_status | 5             | x     | in-val    | 0 if input is < 1.5v, 1 if input >= 1.5v |
-->
<table><thead><tr><th align="right">名前</th><th align="right">ビットフィールド</th><th align="right">値</th><th align="right">意味</th><th align="right">説明</th></tr></thead><tbody>
<tr><td align="right">有効</td><td align="right">0</td><td align="right">0</td><td align="right">無効</td><td align="right">GPIOを無効にする</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">有効</td><td align="right">GPIOを有効にする</td></tr>
<tr><td align="right">方向</td><td align="right">1</td><td align="right">0</td><td align="right">入力</td><td align="right">方向を入力に設定する</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">出力</td><td align="right">方向を出力に設定する</td></tr>
<tr><td align="right">入力モード</td><td align="right">2..3</td><td align="right">00</td><td align="right">hi-z</td><td align="right">入力を高抵抗に設定する</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">01</td><td align="right">プルダウン</td><td align="right">入力ピンはプルダウンになる</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">10</td><td align="right">プルアップ</td><td align="right">入力ピンはプルアップになる</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">11</td><td align="right">n/a</td><td align="right">無効な状態。設定しないこと。</td></tr>
<tr><td align="right">出力モード</td><td align="right">4</td><td align="right">0</td><td align="right">ロー</td><td align="right">出力ピンをローにする</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">ハイ</td><td align="right">出力ピンをハイにする</td></tr>
<tr><td align="right">入力状態</td><td align="right">5</td><td align="right">x</td><td align="right">入力値</td><td align="right">入力が1.5Vより低ければ0、1.5V以上であれば1</td></tr>
</tbody></table>
<!-- We _could_ expose the following structure in Rust to control this GPIO: -->
<p>このGPIOを制御するために、次のようなRustの構造体を公開することが <em>できます</em>。</p>
<pre><code class="language-rust ignore"><span class="boring">/// GPIO interface
</span>/// GPIOインタフェース
struct GpioConfig {
<span class="boring">    /// GPIO Configuration structure generated by svd2rust
</span>    /// svd2rustで生成されたGPIO設定構造体
    periph: GPIO_CONFIG,
}

impl Gpio {
    pub fn set_enable(&amp;mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&amp;mut self, is_output: bool) {
        self.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });
    }

    pub fn set_input_mode(&amp;mut self, variant: InputMode) {
        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });
    }

    pub fn set_output_mode(&amp;mut self, is_high: bool) {
        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });
    }

    pub fn get_input_status(&amp;self) -&gt; bool {
        self.periph.read().input_status().bit_is_set()
    }
}
</code></pre>
<!--
However, this would allow us to modify certain registers that do not make sense. For example, what happens if we set the `output_mode` field when our GPIO is configured as an input? 
-->
<p>しかし、この実装では、筋が通らないレジスタの修正が可能になってしまいます。例えば、GPIOを入力に設定している時に、<code>出力モード</code>を設定すると、どうなるのでしょう？</p>
<!--
In general, use of this structure would allow us to reach states not defined by our state machine above: e.g. an output that is pulled low, or an input that is set high. For some hardware, this may not matter. On other hardware, it could cause unexpected or undefined behavior!
-->
<p>通常、この構造体を利用すると、上のステートマシンで定義されていない状態に到達できてしまいます。
例えば、プルダウンの出力や、ハイに設定された入力、です。</p>
<!-- Although this interface is convenient to write, it doesn't enforce the design contracts set out by our hardware implementation. -->
<p>このインタフェースは書き込みには便利ですが、ハードウェア実装によって定められた設計の契約を強制しません。</p>
<!-- # Design Contracts -->
<h1><a class="header" href="#設計契約" id="設計契約">設計契約</a></h1>
<!-- In our last chapter, we wrote an interface that *didn't* enforce design contracts. Let's take another look at our imaginary GPIO configuration register: -->
<p>前回、設計契約を強制<em>しない</em>インタフェースを書きました。架空のGPIO設定レジスタをもう一度見てみましょう。</p>
<!--
| Name         | Bit Number(s) | Value | Meaning   | Notes |
| ---:         | ------------: | ----: | ------:   | ----: |
| enable       | 0             | 0     | disabled  | Disables the GPIO |
|              |               | 1     | enabled   | Enables the GPIO |
| direction    | 1             | 0     | input     | Sets the direction to Input |
|              |               | 1     | output    | Sets the direction to Output |
| input_mode   | 2..3          | 00    | hi-z      | Sets the input as high resistance |
|              |               | 01    | pull-low  | Input pin is pulled low |
|              |               | 10    | pull-high | Input pin is pulled high |
|              |               | 11    | n/a       | Invalid state. Do not set |
| output_mode  | 4             | 0     | set-low   | Output pin is driven low |
|              |               | 1     | set-high  | Output pin is driven high |
| input_status | 5             | x     | in-val    | 0 if input is < 1.5v, 1 if input >= 1.5v |
-->
<table><thead><tr><th align="right">名前</th><th align="right">ビットフィールド</th><th align="right">値</th><th align="right">意味</th><th align="right">説明</th></tr></thead><tbody>
<tr><td align="right">有効</td><td align="right">0</td><td align="right">0</td><td align="right">無効</td><td align="right">GPIOを無効にする</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">有効</td><td align="right">GPIOを有効にする</td></tr>
<tr><td align="right">方向</td><td align="right">1</td><td align="right">0</td><td align="right">入力</td><td align="right">方向を入力に設定する</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">出力</td><td align="right">方向を出力に設定する</td></tr>
<tr><td align="right">入力モード</td><td align="right">2..3</td><td align="right">00</td><td align="right">hi-z</td><td align="right">入力を高抵抗に設定する</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">01</td><td align="right">プルダウン</td><td align="right">入力ピンはプルダウンになる</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">10</td><td align="right">プルアップ</td><td align="right">入力ピンはプルアップになる</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">11</td><td align="right">n/a</td><td align="right">無効な状態。設定しないこと。</td></tr>
<tr><td align="right">出力モード</td><td align="right">4</td><td align="right">0</td><td align="right">ロー</td><td align="right">出力ピンをローにする</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">ハイ</td><td align="right">出力ピンをハイにする</td></tr>
<tr><td align="right">入力状態</td><td align="right">5</td><td align="right">x</td><td align="right">入力値</td><td align="right">入力が1.5Vより低ければ0、1.5V以上であれば1</td></tr>
</tbody></table>
<!-- If we instead checked the state before making use of the underlying hardware, enforcing our design contracts at runtime, we might write code that looks like this instead: -->
<p>ハードウェアを使う前に状態をチェックし、実行時に設計契約を強制すると、コードは次のように書くことができます。</p>
<pre><code class="language-rust ignore"><span class="boring">/// GPIO interface
</span>/// GPIOインタフェース
struct GpioConfig {
<span class="boring">    /// GPIO Configuration structure generated by svd2rust
</span>    /// svd2rustによって生成されたGPIO設定構造体
    periph: GPIO_CONFIG,
}

impl Gpio {
    pub fn set_enable(&amp;mut self, is_enabled: bool) {
        self.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    pub fn set_direction(&amp;mut self, is_output: bool) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
<span class="boring">            // Must be enabled to set direction
</span>            // 方向を設定するには、有効化されてなければなりません
            return Err(());
        }

        self.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });

        Ok(())
    }

    pub fn set_input_mode(&amp;mut self, variant: InputMode) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
<span class="boring">            // Must be enabled to set input mode
</span>            // 入力モードを設定するには、有効化されてなければなりません
            return Err(());
        }

        if self.periph.read().direction().bit_is_set() {
<span class="boring">            // Direction must be input
</span>            // 方向は入力でなければなりません
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });

        Ok(())
    }

    pub fn set_output_status(&amp;mut self, is_high: bool) -&gt; Result&lt;(), ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
<span class="boring">            // Must be enabled to set output status
</span>            // 出力状態を設定するためには、有効化されてなければなりません
            return Err(());
        }

        if self.periph.read().direction().bit_is_clear() {
<span class="boring">            // Direction must be output
</span>            // 方向は出力でなければなりません
            return Err(());
        }

        self.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });

        Ok(())
    }

    pub fn get_input_status(&amp;self) -&gt; Result&lt;bool, ()&gt; {
        if self.periph.read().enable().bit_is_clear() {
<span class="boring">            // Must be enabled to get status
</span>            // 状態を取得するには、有効化されてなければなりません
            return Err(());
        }

        if self.periph.read().direction().bit_is_set() {
<span class="boring">            // Direction must be input
</span>            // 方向は入力でなければなりません
            return Err(());
        }

        Ok(self.periph.read().input_status().bit_is_set())
    }
}
</code></pre>
<!--
Because we need to enforce the restrictions on the hardware, we end up doing a lot of runtime checking which wastes time and resources, and this code will be much less pleasant for the developer to use.
-->
<p>ハードウェアの制約を強制する必要があるため、時間とリソースを浪費する多くの実行時チェックを行うこととなり、開発者にとってこのコードは好ましくないです。</p>
<!-- ## Type States -->
<h2><a class="header" href="#型状態" id="型状態">型状態</a></h2>
<!-- But what if instead, we used Rust's type system to enforce the state transition rules? Take this example: -->
<p>しかし、代わりに、状態遷移の規則を強制するために、Rustの型システムを使うとどうなるでしょうか？この例を見て下さい。</p>
<pre><code class="language-rust ignore"><span class="boring">/// GPIO interface
</span>/// GPIOインタフェース
struct GpioConfig&lt;ENABLED, DIRECTION, MODE&gt; {
<span class="boring">    /// GPIO Configuration structure generated by svd2rust
</span>    /// svd2rustによって生成されたGPIO設定構造体
    periph: GPIO_CONFIG,
    enabled: ENABLED,
    direction: DIRECTION,
    mode: MODE,
}

<span class="boring">// Type states for MODE in GpioConfig
</span>// GpioConfigのMODEのための型状態
struct Disabled;
struct Enabled;
struct Output;
struct Input;
struct PulledLow;
struct PulledHigh;
struct HighZ;
struct DontCare;

<span class="boring">/// These functions may be used on any GPIO Pin
</span>/// これらの関数はどのGPIOピンにも使えます
impl&lt;EN, DIR, IN_MODE&gt; GpioConfig&lt;EN, DIR, IN_MODE&gt; {
    pub fn into_disabled(self) -&gt; GpioConfig&lt;Disabled, DontCare, DontCare&gt; {
        self.periph.modify(|_r, w| w.enable.disabled());
        GpioConfig {
            periph: self.periph,
            enabled: Disabled,
            direction: DontCare,
            mode: DontCare,
        }
    }

    pub fn into_enabled_input(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        self.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.input()
             .input_mode.high_z()
        });
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_enabled_output(self) -&gt; GpioConfig&lt;Enabled, Output, DontCare&gt; {
        self.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.output()
             .input_mode.set_high()
        });
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Output,
            mode: DontCare,
        }
    }
}

<span class="boring">/// This function may be used on an Output Pin
</span>/// この関数はOutputピンに使用できます
impl GpioConfig&lt;Enabled, Output, DontCare&gt; {
    pub fn set_bit(&amp;mut self, set_high: bool) {
        self.periph.modify(|_r, w| w.output_mode.set_bit(set_high));
    }
}

<span class="boring">/// These methods may be used on any enabled input GPIO
</span>/// これらのメソッドは、有効化された入力GPIOに使えます
impl&lt;IN_MODE&gt; GpioConfig&lt;Enabled, Input, IN_MODE&gt; {
    pub fn bit_is_set(&amp;self) -&gt; bool {
        self.periph.read().input_status.bit_is_set()
    }

    pub fn into_input_high_z(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        self.periph.modify(|_r, w| w.input_mode().high_z());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    pub fn into_input_pull_down(self) -&gt; GpioConfig&lt;Enabled, Input, PulledLow&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_low());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledLow,
        }
    }

    pub fn into_input_pull_up(self) -&gt; GpioConfig&lt;Enabled, Input, PulledHigh&gt; {
        self.periph.modify(|_r, w| w.input_mode().pull_high());
        GpioConfig {
            periph: self.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledHigh,
        }
    }
}
</code></pre>
<!-- Now let's see what the code using this would look like: -->
<p>それでは、これを使うコードがどのようになるか、見てみましょう。</p>
<pre><code class="language-rust ignore">/*
<span class="boring"> * Example 1: Unconfigured to High-Z input
</span> * 例1：未設定から高抵抗入力
 */
let pin: GpioConfig&lt;Disabled, _, _&gt; = get_gpio();

<span class="boring">// Can't do this, pin isn't enabled!
</span>// これはできません、ピンが有効になっていません！
// pin.into_input_pull_down();

<span class="boring">// Now turn the pin from unconfigured to a high-z input
</span>// 今度は、未設定から高抵抗入力に変えます
// 訳注：into_enabled_input()は入力モードを高抵抗にします
let input_pin = pin.into_enabled_input();

<span class="boring">// Read from the pin
</span>// ピンから値を読みます
let pin_state = input_pin.bit_is_set();

<span class="boring">// Can't do this, input pins don't have this interface!
</span>// これはできません、入力ピンはこのインタフェースを持っていません！
// input_pin.set_bit(true);

/*
<span class="boring"> * Example 2: High-Z input to Pulled Low input
</span> * 例2：高抵抗入力からプルダウン入力
 */
let pulled_low = input_pin.into_input_pull_down();
let pin_state = pulled_low.bit_is_set();

/*
<span class="boring"> * Example 3: Pulled Low input to Output, set high
</span> * 例3：プルダウン入力から出力、ハイを設定
 */
let output_pin = pulled_low.into_enabled_output();
output_pin.set_bit(false);

<span class="boring">// Can't do this, output pins don't have this interface!
</span>// これはできません、出力ピンはこのインタフェースを持っていません！
// output_pin.into_input_pull_down();
</code></pre>
<!--
This is definitely a convenient way to store the state of the pin, but why do it this way? Why is this better than storing the state as an `enum` inside of our `GpioConfig` structure?
-->
<p>これは間違いなく、ピンの状態を保存するのに便利な方法ですが、なぜこのようにするのでしょうか？
なぜ、<code>GpioConfig</code>構造体の中で、状態を<code>enum</code>として保存するより良い方法なのでしょうか？</p>
<!-- ## Compile Time Functional Safety -->
<h2><a class="header" href="#コンパイル時の機能の安全性" id="コンパイル時の機能の安全性">コンパイル時の機能の安全性</a></h2>
<!--
Because we are enforcing our design constraints entirely at compile time, this incurs no runtime cost. It is impossible to set an output mode when you have a pin in an input mode. Instead, you must walk through the states by converting it to an output pin, and then setting the output mode. Because of this, there is no runtime penalty due to checking the current state before executing a function.
-->
<!-- design constraintsは、文脈的にdesign contractsの誤植と考えたので、設計契約と訳しています -->
<p>コンパイル時に、設計契約を完全に強制しているため、実行時コストはかかりません。入力方向のピンに対して、出力モードを設定することは不可能です。
代わりに、そのピンを出力ピンに変換してから、出力モードを設定することで、状態を辿る必要があります。
このおかげで、関数実行前に現在の状態をチェックすることによる実行時ペナルティは、ありません。</p>
<!--
Also, because these states are enforced by the type system, there is no longer room for errors by consumers of this interface. If they try to perform an illegal state transition, the code will not compile!
-->
<p>型システムによってこれらの状態が強制されるため、このインタフェースの利用者によるエラーの余地はもはや残っていません。
もし利用者が不正な状態遷移をしようとすると、そのコードはコンパイルできません！</p>
<!-- # Zero Cost Abstractions -->
<h1><a class="header" href="#ゼロコスト抽象化" id="ゼロコスト抽象化">ゼロコスト抽象化</a></h1>
<!--
Type states are also an excellent example of Zero Cost Abstractions - the ability to move certain behaviors to compile time execution or analysis. These type states contain no actual data, and are instead used as markers. Since they contain no data, they have no actual representation in memory at runtime:
-->
<p>型状態はゼロコスト抽象化の優れた例でもあります。特定の動作を、コンパイル時の実行もしくは解析に移動する機能です。
これらの型状態は、実際のデータを含んでおらず、代わりにマーカとして使われています。
型状態はデータを含んでいないため、実行時、メモリ内に実際のデータはありません。</p>
<pre><code class="language-rust ignore">use core::mem::size_of;

let _ = size_of::&lt;Enabled&gt;();    // == 0
let _ = size_of::&lt;Input&gt;();      // == 0
let _ = size_of::&lt;PulledHigh&gt;(); // == 0
let _ = size_of::&lt;GpioConfig&lt;Enabled, Input, PulledHigh&gt;&gt;(); // == 0
</code></pre>
<!-- ## Zero Sized Types -->
<h2><a class="header" href="#ゼロサイズの型" id="ゼロサイズの型">ゼロサイズの型</a></h2>
<pre><code class="language-rust ignore">struct Enabled;
</code></pre>
<!--
Structures defined like this are called Zero Sized Types, as they contain no actual data. Although these types act "real" at compile time - you can copy them, move them, take references to them, etc., however the optimizer will completely strip them away.
-->
<p>上記のように定義された構造体をゼロサイズの型、と呼びます。これは、実際のデータを含んでいません。
これらの型は、コンパイル時には「実際に」機能します。例えば、コピーも、ムーブも、参照を取ることもできます。
しかし、最適化はこれらを完全に取り除きます。</p>
<!-- In this snippet of code: -->
<p>次のコードスニペットを見てください。</p>
<pre><code class="language-rust ignore">pub fn into_input_high_z(self) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
    self.periph.modify(|_r, w| w.input_mode().high_z());
    GpioConfig {
        periph: self.periph,
        enabled: Enabled,
        direction: Input,
        mode: HighZ,
    }
}
</code></pre>
<!--
The GpioConfig we return never exists at runtime. Calling this function will generally boil down to a single assembly instruction - storing a constant register value to a register location. This means that the type state interface we've developed is a zero cost abstraction - it uses no more CPU, RAM, or code space tracking the state of `GpioConfig`, and renders to the same machine code as a direct register access.
-->
<p>実行時、返り値のGpioConfigは、存在しません。この関数を呼び出すと、通常、1つのアセンブリ命令にまとめられます。
そのアセンブリ命令は、定数のレジスタ値を、レジスタの位置へ格納します。
これは、開発した型状態インタフェースが、ゼロコスト抽象化であることを意味します。
<code>GpioConfig</code>の状態を追跡するために、余分なCPU、RAM、コード領域を使用せず、直接レジスタアクセスするのと同じ機械語を表します。</p>
<!-- ## Nesting -->
<h2><a class="header" href="#ネスト" id="ネスト">ネスト</a></h2>
<!--
In general, these abstractions may be nested as deeply as you would like. As long as all components used are zero sized types, the whole structure will not exist at runtime.
-->
<p>通常、これらの抽象化は、望み通りの深さでネストされます。使用される全てのコンポーネントが、ゼロサイズの型である限り、実行時には、構造体全体が存在しません。</p>
<!--
For complex or deeply nested structures, it may be tedious to define all possible combinations of state. In these cases, macros may be used to generate all implementations.
-->
<p>複雑な構造体や深くネストした構造体については、全ての取り得る状態の組み合わせを定義することは、面倒です。
このような場合、全ての実装を生成するために、マクロが利用できます。</p>
<!-- # Portability -->
<h1><a class="header" href="#移植性" id="移植性">移植性</a></h1>
<!--
In embedded environments portability is a very important topic: Every vendor and even each family from a single manufacturer offers different peripherals and capabilities and similarly the ways to interact with the peripherals will vary.
-->
<p>組込み環境においては、移植性は非常に重要なトピックです。1つのメーカから、それぞれのベンダや各プロダクトファミリが、異なるペリフェラルや機能を提供します、
異なるペリフェラルでは、ペリフェラルとやり取りする方法も異なります。</p>
<!-- A common way to equalize such differences is via a layer called Hardware Abstraction layer or **HAL**. -->
<p>このような違いを吸収する一般的な方法は、ハードウェア抽象化レイヤまたは<strong>HAL</strong>と呼ばれるレイヤを導入することです。</p>
<!--
> Hardware abstractions are sets of routines in software that emulate some platform-specific details, giving programs direct access to the hardware resources.
>
> They often allow programmers to write device-independent, high performance applications by providing standard operating system (OS) calls to hardware.
>
> *Wikipedia: [Hardware Abstraction Layer]*
-->
<blockquote>
<p>ハードウェア抽象化は、プラットフォーム固有の細部をエミュレーションして、プログラムにハードウェアリソースへ直接アクセスする方法を提供する、ソフトウェアの一連のルーチンです。</p>
<p>それらのルーチンがハードウェアへのオペレーティングシステム（OS）コールを提供することで、プログラマは、デイバスに依存せず、高性能なアプリケーションを書くことができます。</p>
<p><em>Wikipedia: <a href="https://en.wikipedia.org/wiki/Hardware_abstraction">ハードウェア抽象化レイヤ</a></em></p>
</blockquote>
<!-- [Hardware Abstraction Layer]: https://en.wikipedia.org/wiki/Hardware_abstraction -->
<!--
Embedded systems are a bit special in this regard since we typically do not have operating systems and user installable software but firmware images which are compiled as a whole as well as a number of other constraints. So while the traditional approach as defined by Wikipedia could potentially work it is likely not the most productive approach to ensure portability.
-->
<p>組込みシステムは、通常オペレーティングシステムを使わず、ユーザがインストールできるソフトウェアもありません。
全体として1つにコンパイルされたファームウェアイメージであり、様々な制約を持つ、という点が特殊です。
そのため、Wikipediaで定義されている従来のアプローチでもうまく機能する可能性はありますが、移植性を確保するための最も有効なアプローチではない可能性があります。</p>
<!-- How do we do this in Rust? Enter **embedded-hal**... -->
<p>Rustではどうするのでしょうか？<strong>embedded-hal</strong>を見ていきましょう。</p>
<!-- ## What is embedded-hal? -->
<h2><a class="header" href="#embedded-halとは" id="embedded-halとは">embedded-halとは？</a></h2>
<!--
In a nutshell it is a set of traits which define implementation contracts between **HAL implementations**, **drivers** and **applications (or firmwares)**. Those contracts include both capabilities (i.e. if a trait is implemented for a certain type, the **HAL implementation** provides a certain capability) and methods (i.e. if you can construct a type implementing a trait it is guaranteed that you have the methods specified in the trait available).
-->
<p>一言で言えば、<strong>HAL実装</strong>、<strong>ドライバ</strong>、<strong>アプリケーションまたはファームウェア</strong>間の実装規約を定義するトレイトの集まりのことです。
それらの規約は、機能（ある型にトレイトが実装されていれば、<strong>HAL実装</strong>はそのトレイトの機能を提供します）とメソッド（あるトレイトを実装している型のオブジェクトを作成できれば、そのトレイトに含まれるメソッドが利用可能であることが保証されます）を含んでいます。</p>
<!-- A typical layering might look like this: -->
<p>典型的なレイヤ構造は、次のようになります。</p>
<p><img src="portability/../assets/rust_layers.svg" alt="" /></p>
<!--
Some of the defined traits in **embedded-hal** are:
* GPIO (input and output pins)
* Serial communication
* I2C
* SPI
* Timers/Countdowns
* Analog Digital Conversion
-->
<p><strong>embedded-hal</strong>で定義されているいくつかのトレイトを示します。</p>
<ul>
<li>GPIO（入出力ピン）</li>
<li>シリアル通信</li>
<li>I2C</li>
<li>SPI</li>
<li>タイマ/カウントダウン</li>
<li>アナログデジタル変換</li>
</ul>
<!--
The main reason for having the **embedded-hal** traits and crates implementing and using them is to keep complexity in check. If you consider that an application might have to implement the use of the peripheral in the hardware as well as the application and potentially drivers for additional hardware components, then it should be easy to see that the re-usability is very limited. Expressed mathematically, if **M** is the number of peripheral HAL implementations and **N** the number of drivers then if we were to reinvent the wheel for every application then we would end up with **M*N** implementations while by using the *API* provided by the **embedded-hal** traits will make the implementation complexity approach **M+N**. Of course there're additional benefits to be had, such as less trial-and-error due to a well-defined and ready-to-use APIs.
-->
<p><strong>embedded-hal</strong>トレイトと、それらを実装して使用するクレートを持つ主な理由は、複雑さを抑えることです。
アプリケーションがハードウェアのペリフェラルを使うコードだけでなく、追加するハードウェアコンポーネントのドライバを実装しなければならない場合を考えると、再利用性は非常に制限されます。
数学的に表現すると、<strong>M</strong>がペリフェラルHAL実装の数で、<strong>N</strong>がドライバの数とするならば、全てのアプリケーションで車輪の再発明を行うことになります。
その結果、<strong>M*N</strong>の実装が必要になります。
一方、<strong>embedded-hal</strong>トレイトで提供されるAPIを使うことで、実装の複雑さは<strong>M+N</strong>になるでしょう。
もちろん、明確に定義されたすぐに利用可能なAPIによって試行錯誤を減らすなど、他にも利点があります。</p>
<!-- ## Users of the embedded-hal -->
<h2><a class="header" href="#embedded-halのユーザ" id="embedded-halのユーザ">embedded-halのユーザ</a></h2>
<!-- As said above there are three main users of the HAL: -->
<p>上記のように、HALには主に3つのユーザがいます。</p>
<!-- ### HAL implementation -->
<h3><a class="header" href="#hal実装" id="hal実装">HAL実装</a></h3>
<!--
A HAL implementation provides the interfacing between the hardware and the users of the HAL traits. Typical implementations consist of three parts:
* One or more hardware specific types
* Functions to create and initialize such a type, often providing various configuration options (speed, operation mode, use pins, etc.)
* one or more `trait` `impl` of **embedded-hal** traits for that type
-->
<p>HAL実装は、ハードウェアとHALトレイトのユーザとの間のインタフェースを実装します。典型的な実装では、3つの部分から構成されます。</p>
<ul>
<li>1つ以上のハードウェア固有の型</li>
<li>そのような型のオブジェクトを作成し、初期化する関数。多くの場合、様々な設定オプションを提供しています（速度、動作モード、使用ピンなど）</li>
<li>1つ以上のその型に対する<strong>embedded-hal</strong>の<code>trait</code> <code>impl</code></li>
</ul>
<!--
Such a **HAL implementation** can come in various flavours:
* Via low-level hardware access, e.g. via registers
* Via operating system, e.g. by using the `sysfs` under Linux
* Via adapter, e.g. a mock of types for unit testing
* Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander
-->
<p>このような<strong>HAL実装</strong>は、様々な種類があります。</p>
<ul>
<li>低レベルのハードウェアアクセスによるもの、例えばレジスタ</li>
<li>オペレーティングシステムによるもの、例えばLinuxの<code>sysfs</code>の使用</li>
<li>アダプタによるもの、例えばユニットテストのための型のモック</li>
<li>ハードウェアアダプタ用のドライバによるもの、例えばI2CマルチプレクサやGPIOエキスパンダ</li>
</ul>
<!-- ### Driver -->
<h3><a class="header" href="#ドライバ" id="ドライバ">ドライバ</a></h3>
<!--
A driver implements a set of custom functionality for an internal or external component, connected to a peripheral implementing the embedded-hal traits. Typical examples for such drivers include various sensors (temperature, magnetometer, accelerometer, light), display devices (LED arrays, LCD displays) and actuators (motors, transmitters).
-->
<p>ドライバは、embedded-halトレイトを実装しているペリフェラルに接続されている、内部または外部コンポーネントに対するカスタム機能を実装します。
そのようなドライバの典型的な例は、様々なセンサ（温度、磁気、加速度、輝度）、ディスプレイデバイス（LEDアレイ、LCDディスプレイ）や、アクチュエータ（モータ、トランスミッタ）を含みます。</p>
<!--
A driver has to be initialized with an instance of type that implements a certain `trait` of the embedded-hal which is ensured via trait bound and provides its own type instance with a custom set of methods allowing to interact with the driven device.
-->
<p>ドライバは、embedded-halの特定のトレイトを実装する型のインスタンスと共に初期化する必要があります。
そのトレイトは、トレイト境界により保証され、駆動するデバイスとやり取りできるインスタンスをカスタムメソッドと共に提供します。</p>
<!-- ### Application -->
<h3><a class="header" href="#アプリケーション" id="アプリケーション">アプリケーション</a></h3>
<!--
The application binds the various parts together and ensures that the desired functionality is achieved. When porting between different systems, this is the part which requires the most adaptation efforts, since the application needs to correctly initialize the real hardware via the HAL implementation and the initialisation of different hardware differs, sometimes drastically so. Also the user choice often plays a big role, since components can be physically connected to different terminals, hardware buses sometimes need external hardware to match the configuration or there are different trade-offs to be made in the use of internal peripherals (e.g. multiple timers with different capabilities are available or peripherals conflict with others).
-->
<p>アプリケーションは、様々な部品を結合し、必要な機能が確実に実現できるようにします。
別システムに移植する際、アプリケーションは最も適合作業が求められる部分です。アプリケーションは、HAL実装を通じて、実際のハードウェアを初期化する必要があるからです。
異なるハードウェアの初期化は、極端に異なる場合があります。
ユーザの選択は、多くの場合、大きな影響があります。
コンポーネントが別の端子に物理的に接続されたり、ハードウェアバスが機器構成を満たすために外部ハードウェアを必要とする場合があったり、内部ペリフェラルを使えるようにするための異なるトレードオフがあったりします。例えば、異なる機能を持つ複数のタイマが利用可能であること、や、ペリフェラルが他のペリフェラルと競合すること、です。</p>
<!-- # Concurrency -->
<h1><a class="header" href="#並行性" id="並行性">並行性</a></h1>
<!--
Concurrency happens whenever different parts of your program might execute
at different times or out of order. In an embedded context, this includes:
-->
<p>プログラムの異なる部分が様々なタイミングで実行されたり、アウトオブオーダに実行されると、並行性が発生します。
組込みでは、次のものが該当します。</p>
<!--
* interrupt handlers, which run whenever the associated interrupt happens,
* various forms of multithreading, where your microprocessor regularly swaps
  between parts of your program,
* and in some systems, multiple-core microprocessors, where each core can be
  independently running a different part of your program at the same time.
-->
<ul>
<li>割り込みが発生するたびに実行される割り込みハンドラ</li>
<li>マイクロプロセッサがプログラムの一部を定期的にスワップする様々な形式のマルチスレッド</li>
<li>システムによっては、各コアがプログラムの異なる部分を同時に独立して実行できるマルチコアマイクロプロセッサ</li>
</ul>
<!--
Since many embedded programs need to deal with interrupts, concurrency will
usually come up sooner or later, and it's also where many subtle and difficult
bugs can occur. Luckily, Rust provides a number of abstractions and safety
guarantees to help us write correct code.
-->
<p>多くの組込みプログラムは割り込みを処理する必要があるため、早かれ遅かれ、並行性は発生します。
割り込みは、捉えにくく、難しいバグが数多く発生し得る場所でもあります。
幸運なことに、Rustは正しいコードを書く助けになる抽象化と安全性保証とを、いくつか提供しています。</p>
<!-- ## No Concurrency -->
<h2><a class="header" href="#並行性なし" id="並行性なし">並行性なし</a></h2>
<!--
The simplest concurrency for an embedded program is no concurrency: your
software consists of a single main loop which just keeps running, and there
are no interrupts at all. Sometimes this is perfectly suited to the problem
at hand! Typically your loop will read some inputs, perform some processing,
and write some outputs.
-->
<p>組込みプログラムの最も簡単な並行性は、並行性がないことです。ソフトウェアは1つの動作し続けるメインループからなり、割り込みも発生しません。
時には、これが手元の問題の最適解かもしれません。
通常、ループは何か入力を受け付け、何らかの処理を行い、何かを出力します。</p>
<pre><pre class="playground"><code class="language-rust">#[entry]
fn main() {
    let peripherals = setup_peripherals();
    loop {
        let inputs = read_inputs(&amp;peripherals);
        let outputs = process(inputs);
        write_outputs(&amp;peripherals, outputs);
    }
}
</code></pre></pre>
<!--
Since there's no concurrency, there's no need to worry about sharing data
between parts of your program or synchronising access to peripherals. If
you can get away with such a simple approach this can be a great solution.
-->
<p>並行性がないため、プログラム間でのデータ共有や、ペリフェラルへのアクセス同期に悩む必要はありません。
このような単純なアプローチに逃れることができるのであれば、素晴らしい解決策かもしれません。</p>
<!-- ## Global Mutable Data -->
<h2><a class="header" href="#グローバルでミュータブルなデータ" id="グローバルでミュータブルなデータ">グローバルでミュータブルなデータ</a></h2>
<!--
Unlike non-embedded Rust, we will not usually have the luxury of creating
heap allocations and passing references to that data into a newly-created
thread. Instead our interrupt handlers might be called at any time and must
know how to access whatever shared memory we are using. At the lowest level,
this means we must have _statically allocated_ mutable memory, which
both the interrupt handler and the main code can refer to.
-->
<p>組込みでないRustと異なり、通常、ヒープ領域を作成し、そのデータへの参照を新しく作成したスレッドに渡す、というような贅沢はできません。
代わりに、割り込みハンドラはいつでも呼び出される可能性があり、使用する共有メモリにアクセスする方法を知っていなければなりません。
最も低いレベルでは、 <em>静的に割り当てられた</em> ミュータブルなメモリを持つ必要があることを意味します。
このメモリは、割り込みハンドラとメインコードの両方が参照できます。</p>
<!--
In Rust, such [`static mut`] variables are always unsafe to read or write,
because without taking special care, you might trigger a race condition,
where your access to the variable is interrupted halfway through by an
interrupt which also accesses that variable.
-->
<p>Rustでは、このような<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code>static mut</code></a>変数への読み書きは、常にアンセーフです。
特別な注意を払わないと、レースコンディションを引き起こす可能性があります。
つまり、その変数へのアクセスが、さらにその変数にアクセスする割り込みによって、中断されるということです。</p>
<!--
For an example of how this behaviour can cause subtle errors in your code,
consider an embedded program which counts rising edges of some input signal
in each one-second period (a frequency counter):
-->
<p>この動作によって、コード内に分かりにくいエラーが発生する可能性があります。
例えば、1秒毎に入力信号の立ち上がりエッジをカウントする組込みプログラム（周波数カウンタ）を考えてみましょう。</p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
<span class="boring">            // DANGER - Not actually safe! Could cause data races.
</span>            // 危険。実際に安全ではありません。データ競合を引き起こす可能性があります。
            unsafe { COUNTER += 1 };
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}
</code></pre></pre>
<!--
Each second, the timer interrupt sets the counter back to 0. Meanwhile, the
main loop continually measures the signal, and incremements the counter when
it sees a change from low to high. We've had to use `unsafe` to access
`COUNTER`, as it's `static mut`, and that means we're promising the compiler
we won't cause any undefined behaviour. Can you spot the race condition? The
increment on `COUNTER` is _not_ guaranteed to be atomic — in fact, on most
embedded platforms, it will be split into a load, then the increment, then
a store. If the interrupt fired after the load but before the store, the
reset back to 0 would be ignored after the interrupt returns — and we would
count twice as many transitions for that period.
-->
<p>毎秒、タイマ割り込みはカウンタを0に戻します。同時に、メインループは信号を継続的に測定し、信号がローからハイに変わった時にカウンタをインクリメントします。
<code>static mut</code>な<code>COUNTER</code>にアクセスするためには、<code>unsafe</code>を使う必要があります。
これは、未定義動作を引き起こさないことを、コンパイラに約束するということです。
レースコンディションがどこにあるかわかりますか？
<code>COUNTER</code>のインクリメントは、アトミックであることが保証されて <em>いません</em> 。
実際、ほとんどの組込みプラットフォームにおいて、この操作は、ロードし、インクリメントし、ストアする、という動作に分割されます。
割り込みがロードの後からストアの前に発生した場合、0に戻すリセットは、割り込みから復帰した後に無視されます。
そして、その期間では、2倍の遷移をカウントすることになります。</p>
<!-- ## Critical Sections -->
<h2><a class="header" href="#クリティカルセクション" id="クリティカルセクション">クリティカルセクション</a></h2>
<!--
So, what can we do about data races? A simple approach is to use _critical
sections_, a context where interrupts are disabled. By wrapping the access to
`COUNTER` in `main` in a critical section, we can be sure the timer interrupt
will not fire until we're finished incrementing `COUNTER`:
-->
<p>それでは、データ競合についてどうすれば良いのでしょうか。
単純な方法は、割り込みが無効なコンテキストである <em>クリティカルセクション</em> を使うことです。
<code>main</code>中の<code>COUNTER</code>へのアクセスを、クリティカルセクションでラッピングします。
そうすることで、<code>COUNTER</code>のインクリメントが完了するまで、タイマ割り込みが発生しないようにできます。</p>
<pre><pre class="playground"><code class="language-rust">static mut COUNTER: u32 = 0;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
<span class="boring">            // New critical section ensures synchronised access to COUNTER
</span>            // 新しいクリティカルセクションは、COUNTERへの同期アクセスを保証します
            cortex_m::interrupt::free(|_| {
                unsafe { COUNTER += 1 };
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
    unsafe { COUNTER = 0; }
}
</code></pre></pre>
<!--
In this example we use `cortex_m::interrupt::free`, but other platforms will
have similar mechanisms for executing code in a critical section. This is also
the same as disabling interrupts, running some code, and then re-enabling
interrupts.
-->
<p>この例では<code>cortex_m::interrupt::free</code>を使いました。他のプラットフォームでもクリティカルセクションのコードを実行するための、類似の方法があります。
これは、割り込みを無効にして、コードを実行し、再び割り込みを有効にすることと同じです。</p>
<!--
Note we didn't need to put a critical section inside the timer interrupt,
for two reasons:
-->
<p>タイマ割り込み内クリティカルセクションを置く必要がないことに注意して下さい。これは次の2つの理由からです。</p>
<!--
  * Writing 0 to `COUNTER` can't be affected by a race since we don't read it
  * It will never be interrupted by the `main` thread anyway
-->
<ul>
<li>読み込みをしないため、<code>COUNTER</code>に0を書くことは、競合の影響を受けません</li>
<li>いずれにせよ、<code>main</code>スレッドによって割り込まれることはありえません</li>
</ul>
<!--
If `COUNTER` was being shared by multiple interrupt handlers that might
_preempt_ each other, then each one might require a critical section as well.
-->
<p><code>COUNTER</code>がお互いに <em>プリエンプション</em> する複数の割り込みハンドラから共有される場合、
それぞれにクリティカルセクションが必要になるでしょう。</p>
<!--
This solves our immediate problem, but we're still left writing a lot of
`unsafe` code which we need to carefully reason about, and we might be using
critical sections needlessly — which comes at a cost to overhead and interrupt
latency and jitter.
-->
<p>クリティカルセクションは、当面の問題を解決しますが、慎重に検討しなければならない<code>unsafe</code>なコードをまだたくさん書いています。
その結果、必要以上にクリティカルセクションを使用することになり、オーバーヘッドと割り込みレイテンシおよびジッタをもたらします。</p>
<!--
It's worth noting that while a critical section guarantees no interrupts will
fire, it does not provide an exclusivity guarantee on multi-core systems!  The
other core could be happily accessing the same memory as your core, even
without interrupts. You will need stronger synchronisation primitives if you
are using multiple cores.
-->
<p>注目すべき点は、クリティカルセクションでは、割り込みが発生しないことが保証されますが、
マルチコアシステムでは、排他性の保証は提供されないことです。
他のコアは、割り込みでなくても、とあるコアと同じメモリにアクセスできてしまいます。
マルチコアを使う場合、より強力な同期プリミティブが必要になります。</p>
<!-- ## Atomic Access -->
<h2><a class="header" href="#アトミックアクセス" id="アトミックアクセス">アトミックアクセス</a></h2>
<!--
On some platforms, atomic instructions are available, which provide guarantees
about read-modify-write operations. Specifically for Cortex-M, `thumbv6`
(Cortex-M0) does not provide atomic instructions, while `thumbv7` (Cortex-M3
and above) do. These instructions give an alternative to the heavy-handed
disabling of all interrupts: we can attempt the increment, it will succeed most
of the time, but if it was interrupted it will automatically retry the entire
increment operation. These atomic operations are safe even across multiple
cores.
-->
<p>プラットフォームによっては、アトミック命令が利用できます。アトミック命令は、リードモディファイライト操作の保証を提供します。
特にCortex-Mの場合、<code>thumbv6</code>（Cortex-M0）はアトミック命令を提供しませんが、<code>thumbv7</code>（Cortex-M3以上）は提供します。
これらの命令は、全ての割り込みを無効化する手荒な方法の代替手段を提供します。
インクリメントを試みる時、ほとんどの場合は成功しますが、割り込まれた場合はインクリメント操作全体を自動的にやり直します。
このようなアトミック操作は、複数のコアにまたがっても安全です。</p>
<pre><pre class="playground"><code class="language-rust">use core::sync::atomic::{AtomicUsize, Ordering};

static COUNTER: AtomicUsize = AtomicUsize::new(0);

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
<span class="boring">            // Use `fetch_add` to atomically add 1 to COUNTER
</span>            // 自動的にCOUNTERに1を加えるために`fetch_add`を使います
            COUNTER.fetch_add(1, Ordering::Relaxed);
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
<span class="boring">    // Use `store` to write 0 directly to COUNTER
</span>    // COUNTERに直接0を書くために`store`を使います
    COUNTER.store(0, Ordering::Relaxed)
}
</code></pre></pre>
<!--
This time `COUNTER` is a safe `static` variable. Thanks to the `AtomicUsize`
type `COUNTER` can be safely modified from both the interrupt handler and the
main thread without disabling interrupts. When possible, this is a better
solution — but it may not be supported on your platform.
-->
<p>ここで、<code>COUNTER</code>は安全な<code>static</code>変数です。<code>AtomicUsize</code>のおかげで<code>COUNTER</code>の型は、割り込みを無効化することなく、
割り込みハンドラとメインスレッドの両方から安全に修正できます。
可能であれば、これはより良い解決方法です。しかし、あなたのプラットフォームではサポートされていないかもしれません。</p>
<!--
A note on [`Ordering`]: this affects how the compiler and hardware may reorder
instructions, and also has consequences on cache visibility. Assuming that the
target is a single core platform `Relaxed` is sufficient and the most efficient
choice in this particular case. Stricter ordering will cause the compiler to
emit memory barriers around the atomic operations; depending on what you're
using atomics for you may or may not need this! The precise details of the
atomic model are complicated and best described elsewhere.
-->
<p><a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html"><code>Ordering</code></a>の注釈：これは、コンパイラとハードウェアがどのように命令の順番を入れ替えるか、に影響を与えます。
また、キャッシュの可視性にも影響します。ターゲットがシングルコアプラットフォームだと仮定すると、<code>Relaxed</code>で十分であり、このケースでは最も効率の良い選択です。
より厳密なオーダリングでは、コンパイラはアトミック操作の前後にメモリバリアを発行します。
使用するアトミック操作によって、必要かもしれませんし、必要でないかもしれません！
アトミックモデルの正確な詳細は複雑であり、他の文書内でしっかりと説明されています。</p>
<!-- For more details on atomics and ordering, see the [nomicon]. -->
<p>詳細は、<a href="https://doc.rust-lang.org/nomicon/atomics.html">ノミコン</a>のアトミックとオーダリングを参照して下さい。</p>
<!-- [nomicon]: https://doc.rust-lang.org/nomicon/atomics.html -->
<!-- ## Abstractions, Send, and Sync -->
<h2><a class="header" href="#抽象化sendとsync" id="抽象化sendとsync">抽象化、SendとSync</a></h2>
<!--
None of the above solutions are especially satisfactory. They require `unsafe`
blocks which must be very carefully checked and are not ergonomic. Surely we
can do better in Rust!
-->
<p>上記の解決方法のいずれも、これと言って満足いくものではありません。
どの解決方法も<code>unsafe</code>ブロックを必要とし、非常に注意深くチェックしなければならず、人間工学的ではありません。
Rustではもっとうまくやれるはずです！</p>
<!--
We can abstract our counter into a safe interface which can be safely used
anywhere else in our code. For this example we'll use the critical-section
counter, but you could do something very similar with atomics.
-->
<p>カウンタを、コード内のどこからでも安全に使えるインタフェースに抽象化することができます。
次の例では、クリティカルセクションカウンタを使いますが、アトミックと非常に良く似たことが実現できます。</p>
<pre><pre class="playground"><code class="language-rust">use core::cell::UnsafeCell;
use cortex_m::interrupt;

<span class="boring">// Our counter is just a wrapper around UnsafeCell&lt;u32&gt;, which is the heart
</span><span class="boring">// of interior mutability in Rust. By using interior mutability, we can have
</span><span class="boring">// COUNTER be `static` instead of `static mut`, but still able to mutate
</span><span class="boring">// its counter value.
</span>// カウンタはUnsafeCell&lt;u32&gt;の単なるラッパです。UnsafeCellはRustの内部可変性の重要要素です。
// 内部可変性を使用することで、COUNTERを`static mut`の代わりに`static`として持つことができます。
// しかし、依然として、カウンタの値は変更することができます。
struct CSCounter(UnsafeCell&lt;u32&gt;);

const CS_COUNTER_INIT: CSCounter = CSCounter(UnsafeCell::new(0));

impl CSCounter {
    pub fn reset(&amp;self, _cs: &amp;interrupt::CriticalSection) {
<span class="boring">        // By requiring a CriticalSection be passed in, we know we must
</span><span class="boring">        // be operating inside a CriticalSection, and so can confidently
</span><span class="boring">        // use this unsafe block (required to call UnsafeCell::get).
</span>        // クリティカルセクションを引数として要求することで、クリティカルセクション内で
        // 実行されなければならないことがわかります。そのため、このアンセーフブロックを
        // 自信を持って使用できます（UnsafeCell::getの呼び出しに必要です）。
        unsafe { *self.0.get() = 0 };
    }

    pub fn increment(&amp;self, _cs: &amp;interrupt::CriticalSection) {
        unsafe { *self.0.get() += 1 };
    }
}

<span class="boring">// Required to allow static CSCounter. See explanation below.
</span>// 静的なCSCounterを許可するために必要です。以下の説明を参照して下さい。
unsafe impl Sync for CSCounter {}

<span class="boring">// COUNTER is no longer `mut` as it uses interior mutability;
</span><span class="boring">// therefore it also no longer requires unsafe blocks to access.
</span>// 内部可変性を使用するため、COUNTERは、もはや`mut`ではありません。
// 従って、アクセスの際に、アンセーフなブロックも必要なくなりました。
static COUNTER: CSCounter = CS_COUNTER_INIT;

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
<span class="boring">            // No unsafe here!
</span>            // アンセーフはここでは必要ありません！
            interrupt::free(|cs| COUNTER.increment(cs));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
<span class="boring">    // We do need to enter a critical section here just to obtain a valid
</span><span class="boring">    // cs token, even though we know no other interrupt could pre-empt
</span><span class="boring">    // this one.
</span>    // 有効なcsトークンを得るため、ここでクリティカルセクションに入る必要があります。
    // 他の割り込みがプリエンプションを起こさないと分かっていても必要です。
    interrupt::free(|cs| COUNTER.reset(cs));

<span class="boring">    // We could use unsafe code to generate a fake CriticalSection if we
</span><span class="boring">    // really wanted to, avoiding the overhead:
</span><span class="boring">    // let cs = unsafe { interrupt::CriticalSection::new() };
</span>    // オーバーヘッドを避けるために、本当に必要であれば、偽のクリティカルセクションを生成する
    // アンセーフなコードを使うことができます。
    // let cs = unsafe { interrupt::CriticalSection::new() };
}
</code></pre></pre>
<!--
We've moved our `unsafe` code to inside our carefully-planned abstraction,
and now our appplication code does not contain any `unsafe` blocks.
-->
<p><code>unsafe</code>コードを慎重に検討された抽象の内側に移動しました。
そして、アプリケーションコードは、<code>unsafe</code>ブロックを含んでいません。</p>
<!--
This design requires the application pass a `CriticalSection` token in:
these tokens are only safely generated by `interrupt::free`, so by requiring
one be passed in, we ensure we are operating inside a critical section, without
having to actually do the lock ourselves. This guarantee is provided statically
by the compiler: there won't be any runtime overhead associated with `cs`.
If we had multiple counters, they could all be given the same `cs`, without
requiring multiple nested critical sections.
-->
<p>この設計は、アプリケーションが<code>CriticalSection</code>トークンを渡すことを要求します。
トークンは、<code>interrupt::free</code>によってのみ、安全に生成することができます。
そのため、このトークンが渡されることを要求することで、自分自身でロックを実際にかけることなしに、クリティカルセクション内で動作していることを保証します。
この保証は、静的にコンパイラによって提供されます。<code>cs</code>による実行時のオーバーヘッドはありません。
カウンタが複数ある場合、複数の入れ子になったクリティカルセクションなしに、同じ<code>cs</code>を与えることができます。</p>
<!--
This also brings up an important topic for concurrency in Rust: the
[`Send` and `Sync`] traits. To summarise the Rust book, a type is Send
when it can safely be moved to another thread, while it is Sync when
it can be safely shared between multiple threads. In an embedded context,
we consider interrupts to be executing in a separate thread to the application
code, so variables accessed by both an interrupt and the main code must be
Sync.
-->
<p>これは、Rustの並行性についても重要なトピックを提起します。<a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><code>Send</code>と<code>Sync</code></a>トレイトです。
the Rust bookを要約すると、安全に別のスレッドに移動できるとき、型はSendです。
一方、複数のスレッド間で安全に共有できるとき、型はSyncです。
組込みでは、割り込みがアプリケーションコードとは異なるスレッドで動作すると考えます。
そのため、割り込みとメインコードとの両方からアクセスされる変数は、Syncでなければなりません。</p>
<!-- [`Send` and `Sync`]: https://doc.rust-lang.org/nomicon/send-and-sync.html -->
<!--
For most types in Rust, both of these traits are automatically derived for you
by the compiler. However, because `CSCounter` contains an [`UnsafeCell`], it is
not Sync, and therefore we could not make a `static CSCounter`: `static`
variables _must_ be Sync, since they can be accessed by multiple threads.
-->
<p>Rustのほとんどの型では、コンパイラによってSendとSyncの両方のトレイトが自動的に継承されます。
しかし、<code>CSCounter</code>は<a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>を含んでいるため、Syncではありません。
従って、<code>static CSCounter</code>を作ることはできません。<code>static</code>変数は、複数のスレッドからアクセスされるため、Syncでなければなりません。</p>
<!--
To tell the compiler we have taken care that the `CSCounter` is in fact safe
to share between threads, we implement the Sync trait explicitly. As with the
previous use of critical sections, this is only safe on single-core platforms:
with multiple cores you would need to go to greater lengths to ensure safety.
-->
<p><code>CSCounter</code>が実はスレッド間で共有しても安全なように処理していることを、コンパイラに伝えるため、Syncトレイトを明示的に実装します。
これまでのクリティカルセクションの使用と同様に、シングルコアのプラットフォームでのみ安全です。
マルチコアのプラットフォームでは、安全性を確保するためにさらなる取り組みが必要です。</p>
<!-- ## Mutexes -->
<h2><a class="header" href="#ミューテックス" id="ミューテックス">ミューテックス</a></h2>
<!--
We've created a useful abstraction specific to our counter problem, but
there are many common abstractions used for concurrency.
-->
<p>カウンタの問題に特有の便利な抽象化を行いましたが、並行性のために利用されるいくつかの抽象化が存在します。</p>
<!--
One such _synchronisation primitive_ is a mutex, short for mutual exclusion.
These constructs ensure exclusive access to a variable, such as our counter. A
thread can attempt to _lock_ (or _acquire_) the mutex, and either succeeds
immediately, or blocks waiting for the lock to be acquired, or returns an error
that the mutex could not be locked. While that thread holds the lock, it is
granted access to the protected data. When the thread is done, it _unlocks_ (or
_releases_) the mutex, allowing another thread to lock it. In Rust, we would
usually implement the unlock using the [`Drop`] trait to ensure it is always
released when the mutex goes out of scope.
-->
<p>そのような <em>同期プリミティブ</em> の1つはミューテックス（mutex）です。mutexはmutual exclusionの略です。
ミューテックスは、私達のカウンタのような変数への排他アクセスを保証します。
あるスレッドは、ミューテックスの <em>ロック</em>（または <em>獲得</em>）を試みます。
すると、すぐに成功するか、ロックが獲得されるのを待ってブロックするか、ミューテックスをロックできなかったエラーを返します。
そのスレッドがロックを保持している間、保護されたデータへのアクセスが許可されます。
そのスレッドが実行を完了すると、ミューテックスを <em>アンロック</em>（または <em>解放</em>）することで、他のスレッドがミューテックスをロックできるようにします。
Rustでは、通常、アンロックを実装するために<a href="https://doc.rust-lang.org/core/ops/trait.Drop.html"><code>Drop</code></a>トレイトを使用します。
これは、ミューテックスがスコープの外に到達すると、常に解放されることを保証するためです。</p>
<!--
Using a mutex with interrupt handlers can be tricky: it is not normally
acceptable for the interrupt handler to block, and it would be especially
disastrous for it to block waiting for the main thread to release a lock,
since we would then _deadlock_ (the main thread will never release the lock
because execution stays in the interrupt handler). Deadlocking is not
considered unsafe: it is possible even in safe Rust.
-->
<p>割り込みハンドラでミューテックスを使用するのはトリッキーです。割り込みハンドラ内でブロックすることは、通常、好ましくありません。
割り込みハンドラ内で、メインスレッドがロックを解放するのを待ってブロックすると、特に悲惨です。
なぜならば。<em>デッドロック</em> になるからです。（割り込みハンドラ内に実行がとどまるため、メインスレッドがロックを解放することは決してありません）
デッドロックはアンセーフとは考えられていません。安全なRustでも発生する可能性があります。</p>
<!--
To avoid this behaviour entirely, we could implement a mutex which requires
a critical section to lock, just like our counter example. So long as the
critical section must last as long as the lock, we can be sure we have
exclusive access to the wrapped variable without even needing to track
the lock/unlock state of the mutex.
-->
<p>この動作を完全に避けるため、カウンタの例で示すように、ロックのためにクリティカルセクションを必要とするミューテックスを実装できます。
クリティカルセクションがロックしている間続く限り、ミューテックスのロック/アンロックの状態を追跡することなしに、
ラップされた変数に排他的にアクセスできます。</p>
<!--
This is in fact done for us in the `cortex_m` crate! We could have written
our counter using it:
-->
<p>これは実際に<code>cortex_m</code>クレートで行われています！
それを使ってカウンタを書くことができます。</p>
<pre><pre class="playground"><code class="language-rust">use core::cell::Cell;
use cortex_m::interrupt::Mutex;

static COUNTER: Mutex&lt;Cell&lt;u32&gt;&gt; = Mutex::new(Cell::new(0));

#[entry]
fn main() -&gt; ! {
    set_timer_1hz();
    let mut last_state = false;
    loop {
        let state = read_signal_level();
        if state &amp;&amp; !last_state {
            interrupt::free(|cs|
                COUNTER.borrow(cs).set(COUNTER.borrow(cs).get() + 1));
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
<span class="boring">    // We still need to enter a critical section here to satisfy the Mutex.
</span>    // ミューテックスを満たすために、ここでもクリティカルセクションに入る必要があります。
    interrupt::free(|cs| COUNTER.borrow(cs).set(0));
}
</code></pre></pre>
<!--
We're now using [`Cell`], which along with its sibling `RefCell` is used to
provide safe interior mutability. We've already seen `UnsafeCell` which is
the bottom layer of interior mutability in Rust: it allows you to obtain
multiple mutable references to its value, but only with unsafe code. A `Cell`
is like an `UnsafeCell` but it provides a safe interface: it only permits
taking a copy of the current value or replacing it, not taking a reference,
and since it is not Sync, it cannot be shared between threads. These
constraints mean it's safe to use, but we couldn't use it directly in a
`static` variable as a `static` must be Sync.
-->
<p>今回は<a href="https://doc.rust-lang.org/core/cell/struct.Cell.html"><code>Cell</code></a>を使っています。これは、<code>RefCell</code>の同類で安全な内部可変性を提供するために使用されます。
既に、<code>UnsafeCell</code>が、Rustの内部可変性の最下層であることを見てきました。
UnsafeCellは、値への複数のミュータブル参照の取得を可能としますが、アンセーフなコードでのみ使用できます。
<code>Cell</code>は<code>UnsafeCell</code>と似ていますが、安全なインタフェースを提供します。
Cellは参照を取得せず、現在値のコピーを取得するか、置き換えることだけを許可します。
CellはSyncでないため、スレッド間で共有できません。
これらの制約は安全に使えることを意味しますが、<code>static</code>変数として直接使用できません。<code>static</code>はSyncである必要があるからです。</p>
<!--
So why does the example above work? The `Mutex<T>` implements Sync for any
`T` which is Send — such as a `Cell`. It can do this safely because it only
gives access to its contents during a critical section. We're therefore able
to get a safe counter with no unsafe code at all!
-->
<p>では、なぜ上記の例はうまく動くのでしょうか？<code>Mutex&lt;T&gt;</code>は、<code>Cell</code>のようなSendな<code>T</code>に対してSyncを実装します。
このことが、Cellをstaticで使うことを安全にします。なぜなら、クリティカルセクションの間だけ、その中身へのアクセスを提供するからです。
従って、全くアンセーフなコードなしに、安全なカウンタを手に入れることができます。</p>
<!--
This is great for simple types like the `u32` of our counter, but what about
more complex types which are not Copy? An extremely common example in an
embedded context is a peripheral struct, which generally are not Copy.
For that we can turn to `RefCell`.
-->
<p>この方法は、カウンタの<code>u32</code>のような単純な型に適しています。しかし、もっと複雑なCopyでない型についてはどうでしょうか？
組込みにおいて非常に一般的な例は、ペリフェラル構造体です。これは、通常Copyではありません。
そのためには、<code>RefCell</code>に頼ることができます。</p>
<!-- ## Sharing Peripherals -->
<h2><a class="header" href="#ペリフェラルの共有" id="ペリフェラルの共有">ペリフェラルの共有</a></h2>
<!--
Device crates generated using `svd2rust` and similar abstractions provide
safe access to peripherals by enforcing that only one instance of the
peripheral struct can exist at a time. This ensures safety, but makes it
difficult to access a peripheral from both the main thread and an interrupt
handler.
-->
<p><code>svd2rust</code>および同様の抽象化を使って生成されるデバイスクレートは、ペリフェラルへの安全なアクセスを提供します。
これは、同時に1つのペリフェラル構造体インスタンスしか存在できないように強制することによって、もたらされます。
このことは、安全性を保証しますが、メインスレッドと割り込みハンドとの両方からペリフェラルにアクセスすることを難しくします。</p>
<!--
To safely share peripheral access, we can use the `Mutex` we saw before. We'll
also need to use [`RefCell`], which uses a runtime check to ensure only one
reference to a peripheral is given out at a time. This has more overhead than
the plain `Cell`, but since we are giving out references rather than copies,
we must be sure only one exists at a time.
-->
<!-- 最後の文章が自信ないです。 -->
<p>ペリフェラルアクセスを安全に共有するため、上で見たように<code>Mutex</code>を使うことができます。
また、<a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code>RefCell</code></a>も必要です。RefCellは、実行時チェックを使って、同時に1つのペリフェラルへの参照だけが渡されるようにします。
実行時チェックは、普通の<code>Cell</code>よりもオーバーヘッドが大きくなりますが、
コピーではなく参照を受け渡しするため、同時に存在するのが1つだけであることを確認する必要があります。</p>
<!--
Finally, we'll also have to account for somehow moving the peripheral into
the shared variable after it has been initialised in the main code. To do
this we can use the `Option` type, initialised to `None` and later set to
the instance of the peripheral.
-->
<p>最後に、メインコード内でペリフェラルを初期化した後、なんとかしてペリフェラルを共有変数に移動する方法が必要です。
これを実現するために、<code>Option</code>型を使います。<code>None</code>で初期化し、後でペリフェラルのインスタンスを設定します。</p>
<pre><pre class="playground"><code class="language-rust">use core::cell::RefCell;
use cortex_m::interrupt::{self, Mutex};
use stm32f4::stm32f405;

static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));

#[entry]
fn main() -&gt; ! {
<span class="boring">    // Obtain the peripheral singletons and configure it.
</span><span class="boring">    // This example is from an svd2rust-generated crate, but
</span><span class="boring">    // most embedded device crates will be similar.
</span>    // ペリフェラルのシングルトンを取得し、設定します。
    // この例は、svd2rustで生成されたクレートから持ってきたものですが、
    // ほとんどの組込みデバイスクレートは同様になります。
    let dp = stm32f405::Peripherals::take().unwrap();
    let gpioa = &amp;dp.GPIOA;

<span class="boring">    // Some sort of configuration function.
</span><span class="boring">    // Assume it sets PA0 to an input and PA1 to an output.
</span>    // 一連の設定をする関数です。
    // PA0を入力、PA1を出力に設定すると仮定して下さい。
    configure_gpio(gpioa);

<span class="boring">    // Store the GPIOA in the mutex, moving it.
</span>    // GPIOAをミューテックスに格納し、ムーブします。
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
<span class="boring">    // We can no longer use `gpioa` or `dp.GPIOA`, and instead have to
</span><span class="boring">    // access it via the mutex.
</span>    // もはや`gpioa`や`dp.GPIOA`は使いません。
    // 代わりに、ミューテックス経由でアクセスする必要があります。

<span class="boring">    // Be careful to enable the interrupt only after setting MY_GPIO:
</span><span class="boring">    // otherwise the interrupt might fire while it still contains None,
</span><span class="boring">    // and as-written (with `unwrap()`), it would panic.
</span>    // MY_GPIOを設定した後にのみ、割り込みを有効にするように注意して下さい。
    // そうしなければ、まだNoneが含まれている間に、割り込みが発生する可能性があります。
    // （`unwrap()`を使用して）書き込まれると、パニックになるでしょう。
    set_timer_1hz();
    let mut last_state = false;
    loop {
<span class="boring">        // We'll now read state as a digital input, via the mutex
</span>        // ミューテックス経由で、デジタル入力としての状態を読み込みます。
        let state = interrupt::free(|cs| {
            let gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        if state &amp;&amp; !last_state {
<span class="boring">            // Set PA1 high if we've seen a rising edge on PA0.
</span>            // PA0の立ち上がりエッジを検出した場合、PA1をハイに設定します。
            interrupt::free(|cs| {
                let gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

#[interrupt]
fn timer() {
<span class="boring">    // This time in the interrupt we'll just clear PA0.
</span>    // 今回は、割り込み内では単純にPA0をクリアするだけです。
    interrupt::free(|cs| {
<span class="boring">        // We can use `unwrap()` because we know the interrupt wasn't enabled
</span><span class="boring">        // until after MY_GPIO was set; otherwise we should handle the potential
</span><span class="boring">        // for a None value.
</span>        // `unwrap()`を使うことができます。割り込みはMY_GPIOが設定されるまで有効化されないことを
        // 知っているためです。そうでなければ、Noneを処理しなければならないでしょう。
        let gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}
</code></pre></pre>
<!-- That's quite a lot to take in, so let's break down the important lines. -->
<p>非常に多くのことを取り入れています。重要な部分を詳細に見ていきましょう。</p>
<pre><code class="language-rust ignore">static MY_GPIO: Mutex&lt;RefCell&lt;Option&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(None));
</code></pre>
<!--
Our shared variable is now a `Mutex` around a `RefCell` which contains an
`Option`. The `Mutex` ensures we only have access during a critical section,
and therefore makes the variable Sync, even though a plain `RefCell` would not
be Sync. The `RefCell` gives us interior mutability with references, which
we'll need to use our `GPIOA`. The `Option` lets us initialise this variable
to something empty, and only later actually move the variable in. We cannot
access the peripheral singleton statically, only at runtime, so this is
required.
-->
<p>ここでは、共有変数は<code>RefCell</code>を内部に含む<code>Mutex</code>です。さらに、RefCellは<code>Option</code>を含んでいます。
<code>Mutex</code>はクリティカルセクションの間だけ、アクセスできるようにします。
その結果、普通の<code>RefCell</code>はSyncでないにも関わらず、変数はSyncになります。
<code>RefCell</code>は、<code>GPIOA</code>を使うのに必要となる参照によって内部可変性を提供します。
<code>Option</code>を使用すると、この変数を空の値に初期化できます。後で実際に変数を移動します。
ペリフェラルのシングルトンには静的にアクセスすることはできません。実行時のみアクセスできるため、Optionが必要とされます。</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| MY_GPIO.borrow(cs).replace(Some(dp.GPIOA)));
</code></pre>
<!--
Inside a critical section we can call `borrow()` on the mutex, which gives us
a reference to the `RefCell`. We then call `replace()` to move our new value
into the `RefCell`.
-->
<p>クリティカルセクションの内部で、ミューテックスの<code>borrow()</code>を呼んでいます。borrow()は<code>RefCell</code>の参照を提供します。
その後、<code>replace()</code>を呼び出して、<code>RefCell</code>に新しい値をムーブします。</p>
<pre><code class="language-rust ignore">interrupt::free(|cs| {
    let gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});
</code></pre>
<!--
Finally we use `MY_GPIO` in a safe and concurrent fashion. The critical section
prevents the interrupt firing as usual, and lets us borrow the mutex.  The
`RefCell` then gives us an `&Option<GPIOA>`, and tracks how long it remains
borrowed - once that reference goes out of scope, the `RefCell` will be updated
to indicate it is no longer borrowed.
-->
<p>最後に、<code>MY_GPIO</code>を安全で並行なやり方で使います。
クリティカルセクションは、通常通り割り込みの発生を防ぎ、ミューテックスを借用できます。
<code>RefCell</code>は<code>&amp;Option&lt;GPIOA&gt;</code>を提供し、その借用がいつまで続くかを追跡します。
その参照がスコープ外になると、<code>RefCell</code>が借用されなくなったことを示すため、更新されます。</p>
<!--
Since we can't move the `GPIOA` out of the `&Option`, we need to convert it to
an `&Option<&GPIOA>` with `as_ref()`, which we can finally `unwrap()` to obtain
the `&GPIOA` which lets us modify the peripheral.
-->
<p><code>&amp;Option</code>の外に<code>GPIOA</code>をムーブすることはできないので、<code>as_ref()</code>を使って<code>&amp;Option&lt;&amp;GPIOA&gt;</code>に変換します。
そうすると、最終的に、<code>unwrap()</code>で<code>&amp;GPIOA</code>を取得できます。
&amp;GPIOAにより、ペリフェラルを修正することができます。</p>
<!--
Whew! This is safe, but it is also a little unwieldy. Is there anything else
we can do?
-->
<p>ヒューッ！これは安全ですが、少し大げさすぎて扱いにくいです。他に方法はないのでしょうか？</p>
<h2><a class="header" href="#rtfm" id="rtfm">RTFM</a></h2>
<!--
One alternative is the [RTFM framework], short for Real Time For the Masses. It
enforces static priorities and tracks accesses to `static mut` variables
("resources") to statically ensure that shared resources are always accessed
safely, without requiring the overhead of always entering critical sections and
using reference counting (as in `RefCell`). This has a number of advantages such
as guaranteeing no deadlocks and giving extremely low time and memory overhead.
-->
<p>代替手段の１つは、<a href="https://github.com/japaric/cortex-m-rtfm">RTFMフレームワーク</a>です。RTFMは、Real Time For the Massesの略です。
RTFMは、共有リソースが常に安全にアクセスされることを保証するために、静的な優先度を適用し、
<code>static mut</code>変数（「リソース」）へのアクセスを追跡します。
この方法は、（<code>RefCell</code>のように）常にクリティカルセクションに入り、参照カウントを使うというオーバーヘッドを必要としません。
デッドロックがないことを保証したり、時間とメモリのオーバーヘッドを極めて小さくするといった、多くの利点があります。</p>
<!-- [RTFM framework]: https://github.com/japaric/cortex-m-rtfm -->
<!--
The framework also includes other features like message passing, which reduces
the need for explicit shared state, and the ability to schedule tasks to run at
a given time, which can be used to implement periodic tasks. Check out [the
documentation] for more information!
-->
<p>このフレームワークは他の機能も含んでいます。例えば、メッセージパッシングは明示的な共有状態の必要性を減らします。
また、タスクを指定した時間に実行するスケジュールする機能もあります。これは、周期タスクの実装に使えます。
詳しくは<a href="https://japaric.github.io/cortex-m-rtfm/book/">ドキュメント</a>を参照して下さい。</p>
<!-- [the documentation]: https://japaric.github.io/cortex-m-rtfm/book/ -->
<!-- ## Real Time Operating Systems -->
<h2><a class="header" href="#リアルタイムオペレーティングシステム" id="リアルタイムオペレーティングシステム">リアルタイムオペレーティングシステム</a></h2>
<!--
Another common model for embedded concurrency is the real-time operating system
(RTOS). While currently less well explored in Rust, they are widely used in
traditional embedded development. Open source examples include [FreeRTOS] and
[ChibiOS]. These RTOSs provide support for running multiple application threads
which the CPU swaps between, either when the threads yield control (called
cooperative multitasking) or based on a regular timer or interrupts (preemptive
multitasking). The RTOS typically provide mutexes and other synchronisation
primitives, and often interoperate with hardware features such as DMA engines.
-->
<p>組込み向け並行性の異なる一般的なモデルとして、リアルタイムオペレーティングシステム（RTOS）があります。
現在、Rustではあまり検証されていませんが、従来の組込み開発では広く使用されています。
オープンソースの例として、<a href="https://freertos.org/">FreeRTOS</a>と<a href="http://chibios.org/">ChibiOS</a>があります。
これらのRTOSは、複数のアプリケーションスレッドを動作させる機能を提供しています。
スレッドが制御を明け渡す時（コオペレーティブマルチタスク）か、
周期タイマまたは割り込みに基づく時（プリエンプティブマルチタスク）に、CPUで実行するスレッドを切り替えます。
RTOSは、通常ミューテックスや他の同期プリミティブを提供します。また、DMAエンジンようなハードウェア機能を同時に使えることも多いです。</p>
<!--
At the time of writing there are not many Rust RTOS examples to point to,
but it's an interesting area so watch this space!
-->
<p>この本を書いている時点では、Rustで書かれたRTOSの例はそれほど多くありません。
しかし、興味深い分野ですので、この分野にご注目下さい！</p>
<!-- ## Multiple Cores -->
<h2><a class="header" href="#マルチコア" id="マルチコア">マルチコア</a></h2>
<!--
It is becoming more common to have two or more cores in embedded processors,
which adds an extra layer of complexity to concurrency. All the examples using
a critical section (including the `cortex_m::interrupt::Mutex`) assume the only
other execution thread is the interrupt thread, but on a multi-core system
that's no longer true. Instead, we'll need synchronisation primitives designed
for multiple cores (also called SMP, for symmetric multi-processing).
-->
<p>組込みプロセッサにおいても、2個以上のコアを持つことがより一般的になってきています。
このことは、並行性をさらに複雑にします。（<code>cortex_m::interrupt::Mutex</code>を含む）クリティカルセクションで使っている全ての例は、
他の実行スレッドは、割り込みスレッドだけであることを前提にしています。
しかし、マルチコアシステムにおいては、これは当てはまりません。
代わりに、マルチコア（SMP; symmetric multi-proccesingとも呼ばれます）向けに設計した同期プリミティブが必要になります。</p>
<!--
These typically use the atomic instructions we saw earlier, since the
processing system will ensure that atomicity is maintained over all cores.
-->
<p>通常、これまでに見たアトミック命令を使用します。
アトミック命令は、処理システムが全てのコア間でのアトミック性を維持してくれるためです。</p>
<!--
Covering these topics in detail is currently beyond the scope of this book,
but the general patterns are the same as for the single-core case.
-->
<p>これらのトピックを詳細に説明することは、この本のスコープ範囲外ですが、
一般的なパターンはシングルコアの場合と同じです。</p>
<!-- # Collections -->
<h1><a class="header" href="#コレクション" id="コレクション">コレクション</a></h1>
<!--
Eventually you'll want to use dynamic data structures (AKA collections) in your
program. `std` provides a set of common collections: [`Vec`], [`String`],
[`HashMap`], etc. All the collections implemented in `std` use a global dynamic
memory allocator (AKA the heap).
-->
<p>いずれは、プログラム内で動的なデータ構造（別名コレクション）を使いたいでしょう。
<code>std</code>は、<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a>や<a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>、<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>といった、一般的なコレクションを提供しています。
<code>std</code>で実装されている全てのコレクションは、グローバルな動的アロケータ（別名ヒープ）を使用します。</p>
<!--
As `core` is, by definition, free of memory allocations these implementations
are not available there, but they can be found in the *unstable* `alloc` crate
that's shipped with the compiler.
-->
<p><code>core</code>は、定義上、メモリアロケーションがないためコレクションの実装を使うことができません。
しかし、コンパイラと共に配布されている<em>安定化していない</em><code>alloc</code>クレートの中にコレクションの実装があります。</p>
<!--
If you need collections, a heap allocated implementation is not your only
option. You can also use *fixed capacity* collections; one such implementation
can be found in the [`heapless`] crate.
-->
<p>もしコレクションが必要であれば、ヒープに割り当てる実装だけが選択肢ではありません。
<em>サイズが固定された</em>コレクションを使うことができます。そのような実装は<a href="https://crates.io/crates/heapless"><code>heapless</code></a>クレートの中にあります。</p>
<!-- In this section, we'll explore and compare these two implementations. -->
<p>このセクションでは、コレクションの２つの実装を取り上げ、比較します。</p>
<!-- ## Using `alloc` -->
<h2><a class="header" href="#allocを使用" id="allocを使用"><code>alloc</code>を使用</a></h2>
<!--
The `alloc` crate is shipped with the standard Rust distribution. To import the
crate you can directly `use` it *without* declaring it as a dependency in your
`Cargo.toml` file.
-->
<p><code>alloc</code>クレートは、標準のRust配布物に同梱されています。このクレートをインポートするには、
<code>Cargo.toml</code>ファイルに依存関係を宣言<em>することなしに</em>直接<code>use</code>します。</p>
<pre><code class="language-rust ignore">#![feature(alloc)]

extern crate alloc;

use alloc::vec::Vec;
</code></pre>
<!--
To be able to use any collection you'll first need use the `global_allocator`
attribute to declare the global allocator your program will use. It's required
that the allocator you select implements the [`GlobalAlloc`] trait.
-->
<p>コレクションを使うには、まず最初に、プログラム中のグローバルアロケータを宣言する<code>global_allocator</code>アトリビュートを使う必要があります。
選択したアロケータが<a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code>GlobalAlloc</code></a>トレイトを実装することが求められます。</p>
<!--
For completeness and to keep this section as self-contained as possible we'll
implement a simple bump pointer allocator and use that as the global allocator.
However, we *strongly* suggest you use a battle tested allocator from crates.io
in your program instead of this allocator.
-->
<p>このセクションを可能な限り自己完結させるため、グローバルアロケータとして、単純にポインタを増加するだけのアロケータを実装します。
しかしながら、あなたのプログラムではこのアロケータでなく、crates.ioから歴戦のアロケータを使用することを<em>強く</em>お勧めします。</p>
<pre><code class="language-rust ignore"><span class="boring">// Bump pointer allocator implementation
</span>// ポインタを増加するだけのアロケータ実装

extern crate cortex_m;

use core::alloc::GlobalAlloc;
use core::ptr;

use cortex_m::interrupt;

<span class="boring">// Bump pointer allocator for *single* core systems
</span>// *シングル*コアシステム用のポインタを増加するだけのアロケータ
struct BumpPointerAlloc {
    head: UnsafeCell&lt;usize&gt;,
    end: usize,
}

unsafe impl Sync for BumpPointerAlloc {}

unsafe impl GlobalAlloc for BumpPointerAlloc {
    unsafe fn alloc(&amp;self, layout: Layout) -&gt; *mut u8 {
<span class="boring">        // `interrupt::free` is a critical section that makes our allocator safe
</span><span class="boring">        // to use from within interrupts
</span>        // `interrupt::free`は、割り込み内でアロケータを安全に使用するための
        // クリティカルセクションです。
        interrupt::free(|_| {
            let head = self.head.get();

            let align = layout.align();
            let res = *head % align;
            let start = if res == 0 { *head } else { *head + align - res };
            if start + align &gt; self.end {
<span class="boring">                // a null pointer signal an Out Of Memory condition
</span>                // ヌルポインタはメモリ不足の状態を知らせます
                ptr::null_mut()
            } else {
                *head = start + align;
                start as *mut u8
            }
        })
    }

    unsafe fn dealloc(&amp;self, _: *mut u8, _: Layout) {
<span class="boring">        // this allocator never deallocates memory
</span>        // このアロケータはメモリを解放しません
    }
}

<span class="boring">// Declaration of the global memory allocator
</span><span class="boring">// NOTE the user must ensure that the memory region `[0x2000_0100, 0x2000_0200]`
</span><span class="boring">// is not used by other parts of the program
</span>// グローバルメモリアロケータの宣言
// ユーザはメモリ領域の`[0x2000_0100, 0x2000_0200]`がプログラムの他の部分で使用されないことを
// 保証しなければなりません
#[global_allocator]
static HEAP: BumpPointerAlloc = BumpPointerAlloc {
    head: UnsafeCell::new(0x2000_0100),
    end: 0x2000_0200,
};
</code></pre>
<!--
Apart from selecting a global allocator the user will also have to define how
Out Of Memory (OOM) errors are handled using the *unstable*
`alloc_error_handler` attribute.
-->
<p>グローバルアロケータの選択とは別に、ユーザはメモリ不足（OOM）エラーの処理方法を、
<em>安定化していない</em><code>alloc_error_handler</code>アトリビュートを使って定義する必要があります。</p>
<pre><code class="language-rust ignore">#![feature(alloc_error_handler)]

use cortex_m::asm;

#[alloc_error_handler]
fn on_oom(_layout: Layout) -&gt; ! {
    asm::bkpt();

    loop {}
}
</code></pre>
<!-- Once all that is in place, the user can finally use the collections in `alloc`. -->
<p>全ての準備が整うと、ユーザはついに<code>alloc</code>のコレクションを使うことができます。</p>
<pre><pre class="playground"><code class="language-rust">#[entry]
fn main() -&gt; ! {
    let mut xs = Vec::new();

    xs.push(42);
    assert!(xs.pop(), Some(42));

    loop {
        // ..
    }
}
</code></pre></pre>
<!--
If you have used the collections in the `std` crate then these will be familiar
as they are exact same implementation.
-->
<p><code>std</code>クレートのコレクションを使ったことがあれば、実装が全く同じものであるため、これらのコレクションはお馴染みでしょう。</p>
<!-- ## Using `heapless` -->
<h2><a class="header" href="#heaplessの使用" id="heaplessの使用"><code>heapless</code>の使用</a></h2>
<!--
`heapless` requires no setup as its collections don't depend on a global memory
allocator. Just `use` its collections and proceed to instantiate them:
-->
<p><code>heapless</code>のコレクションはグローバルメモリアロケータに依存しないため、準備は不要です。
単にコレクションを<code>use</code>して、インスタンスを作成するだけです。</p>
<pre><pre class="playground"><code class="language-rust">extern crate heapless; // v0.4.x

use heapless::Vec;
use heapless::consts::*;

#[entry]
fn main() -&gt; ! {
    let mut xs: Vec&lt;_, U8&gt; = Vec::new();

    xs.push(42).unwrap();
    assert_eq!(xs.pop(), Some(42));
}
</code></pre></pre>
<!-- You'll note two differences between these collections and the ones in `alloc`. -->
<p><code>alloc</code>のコレクションとは違う点が2つあることに留意して下さい。</p>
<!--
First, you have to declare upfront the capacity of the collection. `heapless`
collections never reallocate and have fixed capacities; this capacity is part of
the type signature of the collection. In this case we have declared that `xs`
has a capacity of 8 elements that is the vector can, at most, hold 8 elements.
This is indicated by the `U8` (see [`typenum`]) in the type signature.
-->
<p>1つ目は、コレクションの容量を最初に宣言しなければならないことです。
<code>heapless</code>コレクションは、再割り当てが発生せず、固定の容量になります。この容量はコレクションの型シグネチャの一部になります。
上記の例では、<code>xs</code>は8要素の容量を持つように宣言しています。このベクタは最大で8つの要素を保持することができます。
型シグネチャの<code>U8</code>（<a href="https://crates.io/crates/typenum"><code>typenum</code></a>を参照）がこのことを表しています。</p>
<!--
Second, the `push` method, and many other methods, return a `Result`. Since the
`heapless` collections have fixed capacity all operations that insert elements
into the collection can potentially fail. The API reflects this problem by
returning a `Result` indicating whether the operation succeeded or not. In
contrast, `alloc` collections will reallocate themselves on the heap to increase
their capacity.
-->
<p>2つ目は、<code>push</code>メソッドおよび他の多くのメソッドが<code>Result</code>を返すことです。
<code>heapless</code>コレクションは固定の容量を持つため、コレクションに要素を挿入する全ての操作は、失敗する可能性があります。
APIは、操作が成功したかどうかを示すための<code>Result</code>を返すことで、この問題に対処しています。
一方、<code>alloc</code>コレクションは、ヒープ上で再割り当てするため、容量を増やすことができます。</p>
<!--
As of version v0.4.x all `heapless` collections store all their elements inline.
This means that an operation like `let x = heapless::Vec::new();` will allocate
the collection on the stack, but it's also possible to allocate the collection
on a `static` variable, or even on the heap (`Box<Vec<_, _>>`).
-->
<p>v0.4.x以降、全ての<code>heapless</code>コレクションは、全ての要素をインラインで格納しています。
つまり、 <code>let x = heapless::Vec::new();</code>のような操作は、スタック上にコレクションを割り当てます。
また、コレクションを<code>static</code>変数や、ヒープ上（<code>Box&lt;Vec&lt;_, _&gt;&gt;</code>）にさえ、に割り当てることが可能です。</p>
<!-- ## Trade-offs -->
<h2><a class="header" href="#トレードオフ" id="トレードオフ">トレードオフ</a></h2>
<!--
Keep these in mind when choosing between heap allocated, relocatable collections
and fixed capacity collections.
-->
<p>ヒープに割り当てられる再配置可能なコレクションと固定容量のコレクションとを選定する時は、次のことに留意して下さい。</p>
<!-- ### Out Of Memory and error handling -->
<h3><a class="header" href="#メモリ不足とエラー処理" id="メモリ不足とエラー処理">メモリ不足とエラー処理</a></h3>
<!--
With heap allocations Out Of Memory is always a possibility and can occur in
any place where a collection may need to grow: for example, all
`alloc::Vec.push` invocations can potentially generate an OOM condition. Thus
some operations can *implicitly* fail. Some `alloc` collections expose
`try_reserve` methods that let you check for potential OOM conditions when
growing the collection but you need be proactive about using them.
-->
<p>ヒープアロケーションでは、メモリ不足は常に発生する可能性があり、コレクションが拡大する場所であれば、どこでも発生する可能性があります。
例えば、全ての<code>alloc::Vec.push</code>呼び出しは、OOM状態を引き起こす可能性があります。
そのため、一部の操作は<em>暗黙的に</em>失敗する可能性があります。
一部の<code>alloc</code>コレクションは<code>try_reserve</code>メソッドを提供しています。
このメソッドにより、コレクションを拡大する時にOOM状態が発生するかどうかを確認できますが、先を見越して使用する必要があります。</p>
<!--
If you exclusively use `heapless` collections and you don't use a memory
allocator for anything else then an OOM condition is impossible. Instead, you'll
have to deal with collections running out of capacity on a case by case basis.
That is you'll have deal with *all* the `Result`s returned by methods like
`Vec.push`.
-->
<p><code>heapless</code>コレクションだけを使っていて、メモリアロケータを使用しないのであれば、OOM状態は発生しません。
その代わりに、コレクションの容量オーバーを個別に処理しなければなりません。
つまり、<code>Vec.push</code>のようなメソッドが返す全ての<code>Result</code>を処理することになります。</p>
<!--
OOM failures can be harder to debug than say `unwrap`-ing on all `Result`s
returned by `heapless::Vec.push` because the observed location of failure may
*not* match with the location of the cause of the problem. For example, even
`vec.reserve(1)` can trigger an OOM if the allocator is nearly exhausted because
some other collection was leaking memory (memory leaks are possible in safe
Rust).
-->
<p>OOM障害は、<code>heapless::Vec.push</code>が返す全ての<code>Result</code>を<code>unwrap</code>するより、デバッグが難しいでしょう。
なぜなら、障害が発生した場所は、問題の原因となる場所と一致<em>しない</em>可能性があるからです。
例えば、他のコレクションがメモリリークを起こしているせいでアロケータが枯渇しそうな場合、<code>vec.reserve(1)</code>がOOMを発生させる可能性があります
（メモリリークは安全なRustでも発生します）。</p>
<!-- ### Memory usage -->
<h3><a class="header" href="#メモリ使用量" id="メモリ使用量">メモリ使用量</a></h3>
<!--
Reasoning about memory usage of heap allocated collections is hard because the
capacity of long lived collections can change at runtime. Some operations may
implicitly reallocate the collection increasing its memory usage, and some
collections expose methods like `shrink_to_fit` that can potentially reduce the
memory used by the collection -- ultimately, it's up to the allocator to decide
whether to actually shrink the memory allocation or not. Additionally, the
allocator may have to deal with memory fragmentation which can increase the
*apparent* memory usage.
-->
<p>長期間使われるコレクションの容量は、実行時に変わる可能性があるため、ヒープ割り当てされたコレクションのメモリ使用量を推測することは難しいです。
一部の操作は、暗黙的にコレクションを再割り当てし、メモリ使用量が増加します。
一部のコレクションは、<code>shrink_to_fit</code>のようなメソッドを持っており、コレクションが使用しているメモリを減らすこともあります。
最終的に、実際にメモリアロケーションを縮小するかどうかは、アロケータ次第です。
さらに、アロケータは、メモリフラグメンテーションを扱う必要があります。このことは<em>見かけ上の</em>メモリ使用量を増やす可能性があります。</p>
<!--
On the other hand if you exclusively use fixed capacity collections, store
most of them in `static` variables and set a maximum size for the call stack
then the linker will detect if you try to use more memory than what's physically
available.
-->
<p>一方で、固定容量のコレクションだけを使用して、そのほとんどを<code>static</code>変数に格納し、コールスタックの最大サイズを設定すると、
リンカは、物理的に利用可能なメモリより大きな容量を使おうとしたかどうか検出します。</p>
<!--
Furthermore, fixed capacity collections allocated on the stack will be reported
by [`-Z emit-stack-sizes`] flag which means that tools that analyze stack usage
(like [`stack-sizes`]) will include them in their analysis.
-->
<p>その上、スタックに割り当てられた固定容量のコレクションは、<a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html"><code>-Z emit-stack-sizes</code></a>フラグによって報告されます。
このフラグは、（<a href="https://crates.io/crates/stack-sizes"><code>stack-sizes</code></a>のような）スタック使用量を解析するツールがスタック使用量を解析することを意味します。</p>
<!--
However, fixed capacity collections can *not* be shrunk which can result in
lower load factors (the ratio between the size of the collection and its
capacity) than what relocatable collections can achieve.
-->
<p>しかし、固定容量のコレクションは、縮小することが<em>できません</em>。
再配置可能なコレクションよりも負荷率（コレクションのサイズとその容量の比率）が低くなる可能性があります。</p>
<!-- ### Worst Case Execution Time (WCET) -->
<h3><a class="header" href="#最悪実行時間wcet-worst-case-execution-time" id="最悪実行時間wcet-worst-case-execution-time">最悪実行時間（WCET; Worst Case Execution Time）</a></h3>
<!--
If are building time sensitive applications or hard real time applications then
you care, maybe a lot, about the worst case execution time of the different
parts of your program.
-->
<p>時間制約のあるアプリケーションやハードリアルタイムアプリケーションを作成している場合、
プログラムの様々な部分で最悪実行時間が気になるでしょう。</p>
<!--
The `alloc` collections can reallocate so the WCET of operations that may grow
the collection will also include the time it takes to reallocate the collection,
which itself depends on the *runtime* capacity of the collection. This makes it
hard to determine the WCET of, for example, the `alloc::Vec.push` operation as
it depends on both the allocator being used and its runtime capacity.
-->
<p><code>alloc</code>コレクションは再割り当てする可能性があるため、コレクションが拡大する操作の最悪実行時間は、
コレクションが再割り当てされるのにかかる時間も含みます。
コレクションが再割り当てされるかどうかは、<em>実行時</em>のコレクションの容量に依存します。
このことは、<code>alloc::Vec.push</code>といった操作の最悪実行時間の決定を難しくします。
この操作の最悪実行時間は、使用するアロケータとコレクションの実行時容量との両方に依存するためです。</p>
<!--
On the other hand fixed capacity collections never reallocate so all operations
have a predictable execution time. For example, `heapless::Vec.push` executes in
constant time.
-->
<p>一方、固定容量のコレクションは再割り当てが発生しないため、全ての操作の実行時間が予測可能です。
例えば、<code>heapless::Vec.push</code>は定数時間で実行します。</p>
<!-- ### Ease of use -->
<h3><a class="header" href="#使いやすさ" id="使いやすさ">使いやすさ</a></h3>
<!--
`alloc` requires setting up a global allocator whereas `heapless` does not.
However, `heapless` requires you to pick the capacity of each collection that
you instantiate.
-->
<p><code>alloc</code>はグローバルアロケータの準備が必要ですが、<code>heapless</code>はそうではありません。
しかし、<code>heapless</code>は、インスタンスを作成する各コレクションの容量を指定する必要があります。</p>
<!--
The `alloc` API will be familiar to virtually every Rust developer. The
`heapless` API tries to closely mimic the `alloc` API but it will never be
exactly the same due to its explicit error handling -- some developers may feel
the explicit error handling is excessive or too cumbersome.
-->
<p><code>alloc</code> APIは、事実上、全てのRust開発者がなじみのあるものです。
<code>heapless</code> APIは、<code>alloc</code> APIに似せてはいますが、明示的なエラー処理のため、全く同じにはなりません。
一部の開発者はこの明示的なエラー処理を、度が過ぎていたり、面倒すぎる、と感じるかもしれません。</p>
<!-- # Tips for embedded C developers -->
<h1><a class="header" href="#組込みc開発者へのヒント" id="組込みc開発者へのヒント">組込みC開発者へのヒント</a></h1>
<!--
This chapter collects a variety of tips that might be useful to experienced
embedded C developers looking to start writing Rust. It will especially
highlight how things you might already be used to in C are different in Rust.
-->
<p>この章では、組込みC開発の経験者が、Rustを書き始める時に役に立つ様々なヒントをまとめます。
特に、既にC言語で慣れ親しんでいることが、Rustではどう違うのかを強調します。</p>
<!-- ## Preprocessor -->
<h2><a class="header" href="#プリプロセッサ" id="プリプロセッサ">プリプロセッサ</a></h2>
<!--
In embedded C it is very common to use the preprocessor for a varity of
purposes, such as:
-->
<p>組込みCでは、次のような様々な目的でプリプロセッサを使うことが一般的です。</p>
<!--
* Compile-time selection of code blocks with `#ifdef`
* Compile-time array sizes and computations
* Macros to simplify common patterns (to avoid function call overhead)
-->
<ul>
<li><code>#ifdef</code>を使ったコンパイル時のコードブロック選択</li>
<li>コンパイル時の配列サイズやコンパイル時計算</li>
<li>（関数呼び出しのオーバーヘッドを避けるための）共通パターンを簡単化するマクロ</li>
</ul>
<!--
In Rust there is no preprocessor, and so many of these use cases are addressed
differently. In the rest of this section we cover various alternatives to
using the preprocessor.
-->
<p>Rustにはプリプロセッサはありません。上記のユースケースは異なる方法で解決されます。
セクションの残りの部分では、プリプロセッサの様々な代替手段について説明します。</p>
<!-- ### Compile-Time Code Selection -->
<h3><a class="header" href="#コンパイル時コード選択" id="コンパイル時コード選択">コンパイル時コード選択</a></h3>
<!--
The closest match to `#ifdef ... #endif` in Rust are [Cargo features]. These
are a little more formal than the C preprocessor: all possible features are
explicitly listed per crate, and can only be either on or off. Features are
turned on when you list a crate as a dependency, and are additive: if any crate
in your dependency tree enables a feature for another crate, that feature will
be enabled for all users of that crate.
-->
<p><code>#ifdef ... #endif</code>に最も近いRustの機能は、<a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">Cargoフィーチャ</a>です。
Cargoフィーチャは、Cプリプロセッサよりももう少し秩序だったものです。
フィーチャの候補は、クレートごとに明示的にリスト化されており、オンまたはオフのいずれかになります。
依存関係としてクレートを記載すると、フィーチャが有効になります。またこのフィーチャは追加式です。
依存ツリー内の何らかのクレートが、別クレートのフィーチャを有効化した場合、そのフィーチャは、そのクレートを使う全てのユーザに対して有効化されます。</p>
<!-- [Cargo features]: https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section -->
<!--
For example, you might have a crate which provides a library of signal
processing primitives. Each one might take some extra time to compile or
declare some large table of constants which you'd like to avoid. You could
declare a Cargo feature for each component in your `Cargo.toml`:
-->
<p>例えば、信号処理プリミティブを提供するライブラリがあるとします。
それぞれが、大きな定数テーブルをコンパイルまたは宣言するのに余分な時間がかかるとすると、その時間を回避したいと思うでしょう。
<code>Cargo.toml</code>内で各コンポーネントのフィーチャを宣言することができます。</p>
<pre><code class="language-toml">[features]
FIR = []
IIR = []
</code></pre>
<!-- Then, in your code, use `#[cfg(feature="FIR")]` to control what is included. -->
<p>それから、コード内で、何をインクルードするか制御するために<code>#[cfg(feature=&quot;FIR&quot;)]</code>を使います。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">/// In your top-level lib.rs
</span>/// トップレベルのlib.rs内

#[cfg(feature=&quot;FIR&quot;)]
pub mod fir;

#[cfg(feature=&quot;IIR&quot;)]
pub mod iir;
<span class="boring">}
</span></code></pre></pre>
<!--
You can similarly include code blocks only if a feature is _not_ enabled, or if
any combination or features is or is not enabled.
-->
<p>同様に、フィーチャが有効になって <em>いない</em> 場合にだけコードブロックをインクルードすることができます。
また、フィーチャの組み合わせや、フィーチャが有効か無効かに関わらず、コードブロックをインクルードすることもできます。</p>
<!--
Additionally, Rust provides a number of automatically-set conditions you can
use, such as `target_arch` to select different code based on architecture. For
full details of the conditional compilation support, refer to the
[conditional compilation] chapter of the Rust reference.
-->
<p>さらに、Rustは、自動的に設定される数々の条件を提供します。例えば、アーキテクチャに基づいて異なるコードを選択する<code>target_arch</code>です。
条件コンパイルがサポートしている全ての詳細については、Rustリファレンスの<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">条件コンパイル</a>の章を参照して下さい。</p>
<!-- [conditional compilation]: https://doc.rust-lang.org/reference/conditional-compilation.html -->
<!--
The conditional compilation will only apply to the next statement or block. If
a block can not be used in the current scope then then `cfg` attribute will
need to be used multiple times.  It's worth noting that most of the time it is
better to simply include all the code and allow the compiler to remove dead
code when optimising: it's simpler for you and your users, and in general the
compiler will do a good job of removing unused code.
-->
<p>条件コンパイルは、次のステートメントまたはブロックにのみ適用されます。
現在のスコープ内でブロックが使えない場合、<code>cfg</code>アトリビュートは複数回必要になります。
ほとんどの場合、単純に全てのコードをインクルードして、コンパイラが最適化時にデッドコードを削除できるようにするほうが良いことに、注意すべきです。
これは、あなたにも、あなたのユーザにとってもより簡単です。そして、通常、コンパイラは使用されていないコードをうまく削除します。</p>
<!-- ### Compile-Time Sizes and Computation -->
<h3><a class="header" href="#コンパイル時サイズとコンパイル時計算" id="コンパイル時サイズとコンパイル時計算">コンパイル時サイズとコンパイル時計算</a></h3>
<!--
Rust supports `const fn`, functions which are guaranteed to be evaluable at
compile-time and can therefore be used where constants are required, such as
in the size of arrays. This can be used alongside features mentioned above,
for example:
-->
<p>Rustは<code>const fn</code>を提供しています。この関数はコンパイル時に評価されることが保証されているため、配列のサイズなど、定数が求められる場所で使用できます。
const fnは、上述したフィーチャと同時に使う事ができます。例を示します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const fn array_size() -&gt; usize {
    #[cfg(feature=&quot;use_more_ram&quot;)]
    { 1024 }
    #[cfg(not(feature=&quot;use_more_ram&quot;)]
    { 128 }
}

static BUF: [u32; array_size()] = [0u32; array_size()];
<span class="boring">}
</span></code></pre></pre>
<!--
These are new to stable Rust as of 1.31, so documentation is still sparse. The
functionality available to `const fn` is also very limited at the time of
writing; in future Rust releases it is expected to expand on what is permitted
in a `const fn`.
-->
<p>これらは、Rust 1.31以降の新しい機能であるため、ドキュメントはまだわずかしかありません。
執筆時点では、<code>const fn</code>で利用可能な機能は、非常に限られています。
将来のRustでは、<code>const fn</code>内で許可されることが拡張されていくでしょう。</p>
<!-- ### Macros -->
<h3><a class="header" href="#マクロ" id="マクロ">マクロ</a></h3>
<!--
Rust provides an extremely powerful [macro system]. While the C preprocessor
operates almost directly on the text of your source code, the Rust macro system
operates at a higher level. There are two varieties of Rust macro: _macros by
example_ and _procedural macros_. The former are simpler and most common; they
look like function calls and can expand to a complete expression, statement,
item, or pattern. Procedural macros are more complex but permit extremely
powerful additions to the Rust language: they can transform arbitrary Rust
syntax into new Rust syntax.
-->
<p>Rustは、極めて強力な<a href="https://doc.rust-lang.org/book/second-edition/appendix-04-macros.html">マクロシステム</a>を提供しています。
Cプリプロセッサがソースコードのテキストにほぼ直接作用するのに対して、Rustのマクロシステムはより上位レベルで作用します。
Rustのマクロは2種類あります。<em>例によるマクロ</em> と <em>手続きマクロ</em> です。
前者はより単純で最も一般的なものです。関数呼び出しのように見えて、完全な式やステートメント、アイテム、パターンに展開できます。
手続きマクロは、より複雑ですが、Rust言語に非常に強力な拡張を許可します。任意のRust構文を、新しいRust構文に変換することができます。</p>
<!-- [macro system]: https://doc.rust-lang.org/book/second-edition/appendix-04-macros.html -->
<!--
In general, where you might have used a C preprocessor macro, you probably want
to see if a macro-by-example can do the job instead. They can be defined in
your crate and easily used by your own crate or exported for other users. Be
aware that since they must expand to complete expressions, statements, items,
or patterns, some use cases of C preprocessor macros will not work, for example
a macro that expands to part of a variable name or an incomplete set of items
in a list.
-->
<p>通常、Cプリプロセッサマクロを使っていた場所に、例によるマクロで同じことができるかどうか、確認したいと思います。
マクロは、クレート内に定義でき、自身のクレート内で簡単に使ったり、他のユーザにエクスポートしたりできます。
マクロは、完全な式や、ステートメント、アイテム、パターンに展開されなければならないため、Cプリプロセッサマクロのいくつかのユースケースではうまく機能しません。
例えば、変数名や、リスト内の不完全なアイテムの一部に展開するようなマクロです。</p>
<!--
As with Cargo features, it is worth considering if you even need the macro. In
many cases a regular function is easier to understand and will be inlined to
the same code as a macro. The `#[inline]` and `#[inline(always)]` [attributes]
give you further control over this process, although care should be taken here
as well â€” the compiler will automatically inline functions from the same crate
where appropriate, so forcing it to do so inappropriately might actually lead
to decreased performance.
-->
<p>Cargoフィーチャと同様、本当にマクロが必要かどうか、は検討する価値があります。
多くの場合、通常の関数は理解しやすく、マクロと同様にインライン化されます。
<code>#[inline]</code>および<code>#[inline(always)]</code>の<a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">アトリビュート</a>を使用すると、このプロセスをさらに細かく制御できます。
ここでも注意が必要です。コンパイラは、適切な場合、関数を自動的にインライン化します。
そのため、不適切なインライン化を強制すると、パフォーマンスが低下する可能性があります。</p>
<!-- [attributes]: https://doc.rust-lang.org/reference/attributes.html#inline-attribute -->
<!--
Explaining the entire Rust macro system is out of scope for this tips page, so
you are encouraged to consult the Rust documentation for full details.
-->
<p>Rustのマクロシステムの全体を説明することは、このヒントページのスコープ範囲外です。
詳細については、Rustのドキュメントの参照をお勧めします。</p>
<!-- ## Build System -->
<h2><a class="header" href="#ビルドシステム" id="ビルドシステム">ビルドシステム</a></h2>
<!--
Most Rust crates are built using Cargo (although it is not required). This
takes care of many difficult problems with traditional build systems. However,
you may wish to customise the build process. Cargo provides [`build.rs`
scripts] for this purpose. They are Rust scripts which can interact with the
Cargo build system as required.
-->
<p>（必須ではありませんが）ほとんどのRustのクレートは、Cargoを使ってビルドされます。
Cargoは、従来のビルドシステムに関する多くの難しい問題の面倒を見ています。
しかし、ビルドプロセスをカスタマイズしたいと思うかもしれません。このため、Cargoは<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code>スクリプト</a>を提供しています。
build.rsスクリプトはRustで書かれたスクリプトで、必要に応じてCargoのビルドシステムとやり取りします。</p>
<!-- [`build.rs` scripts]: https://doc.rust-lang.org/cargo/reference/build-scripts.html -->
<!-- Common use cases for build scripts include: -->
<p>ビルドスクリプトの一般的なユースケースを示します。</p>
<!--
* provide build-time information, for example statically embedding the build
  date or Git commit hash into your executable
* generate linker scripts at build time depending on selected features or other
  logic
* change the Cargo build configuration
* add extra static libraries to link against
-->
<ul>
<li>ビルド時の情報を提供します。例えば、実行ファイルにビルド日時やGitのコミットハッシュを静的に埋め込みます。</li>
<li>選択されたフィーチャやその他のロジックに応じて、リンカスクリプトをビルド時に生成します。</li>
<li>Cargoのビルド設定を変更します。</li>
<li>リンクする静的ライブラリを追加します。</li>
</ul>
<!--
At present there is no support for post-build scripts, which you might
traditionally have used for tasks like automatic generation of binaries from
the build objects or printing build information.
-->
<p>現状、ビルド後に実行するスクリプトは提供されていません。
そのようなスクリプトは、従来では、ビルドしたオブジェクトからバイナリを自動的に生成したり、ビルド情報を表示したりするタスクに使われています。</p>
<!-- ### Cross-Compiling -->
<h3><a class="header" href="#クロスコンパイル-1" id="クロスコンパイル-1">クロスコンパイル</a></h3>
<!--
Using Cargo for your build system also simplifies cross-compiling. In most
cases it suffices to tell Cargo `--target thumbv6m-none-eabi` and find a
suitable executable in `target/thumbv6m-none-eabi/debug/myapp`.
-->
<p>Cargoをビルドシステムに使用するとクロスコンパイルも簡単になります。
多くの場合、Cargoに<code>--target thumbv6m-none-eabi</code>を伝えるだけで十分です。
そうすると、適切な実行ファイルが<code>target/thumbv6m-none-eabi/debug/myapp</code>に見つかります。</p>
<!--
For platforms not natively supported by Rust, you will need to build `libcore`
for that target yourself. On such platforms, [Xargo] can be used as a stand-in
for Cargo which automatically builds `libcore` for you.
-->
<p>Rustが本来サポートしていないプラットフォームの場合、ターゲットの<code>libcore</code>を自分自身でビルドする必要があります。
そのようなプラットフォームでは、<a href="https://github.com/japaric/xargo">Xargo</a>をCargoの代わりに使うことができ、自動的に<code>libcore</code>をビルドしてくれます。</p>
<!-- ## Iterators vs Array Access -->
<h2><a class="header" href="#イテレータ-vs-配列アクセス" id="イテレータ-vs-配列アクセス">イテレータ vs 配列アクセス</a></h2>
<!-- In C you are probably used to accessing arrays directly by their index: -->
<p>Cでは、おそらくインデックスによって直接配列にアクセスしているでしょう。</p>
<pre><code class="language-c">int16_t arr[16];
int i;
for(i=0; i&lt;sizeof(arr)/sizeof(arr[0]); i++) {
    process(arr[i]);
}
</code></pre>
<!--
In Rust this is an anti-pattern: indexed access can be slower (as it needs to
be bounds checked) and may prevent various compiler optimisations. This is an
important distinction and worth repeating: Rust will check for out-of-bounds
access on manual array indexing to guarantee memory safety, while C will
happily index outside the array.
-->
<p>Rustでは、これはアンチパターンです。インデックスによるアクセスは、低速（境界チェックが必要なため）で様々なコンパイラの最適化を妨げます。
これは重要な違いであり、繰り返す価値があります。
Rustは、メモリ安全性を保証するために、手動で配列のインデックスを指定する際、境界を越えたアクセスをチェックします。
一方、Cでは配列外のインデックスにアクセスできてしまいます。</p>
<!-- Instead, use iterators: -->
<p>代わりに、イテレータを使います。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [0u16; 16];
for element in arr.iter() {
    process(*element);
}
<span class="boring">}
</span></code></pre></pre>
<!--
Iterators provide a powerful array of functionality you would have to implement
manually in C, such as chaining, zipping, enumerating, finding the min or max,
summing, and more. Iterator methods can also be chained, giving very readable
data processing code.
-->
<!-- `chaining, zipping, enumerating`の適切な表現が考えつかないため、そのままにしてあります。 -->
<p>イテレータは、chaining、zipping、enumerating、最小値や最大値の検索、合計の算出など、Cでは手動で実装する必要がある強力な配列の機能を提供します。
イテレータのメソッドは、連鎖することができ、非常に読みやすいデータ処理のコードになります。</p>
<!-- See the [Iterators in the Book] and [Iterator documentation] for more details. -->
<p>詳細は<a href="https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html">the Bookのイテレータ</a>と<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">イテレータのドキュメント</a>を参照して下さい。</p>
<!--
[Iterators in the Book]: https://doc.rust-lang.org/book/second-edition/ch13-02-iterators.html
[Iterator documentation]: https://doc.rust-lang.org/core/iter/trait.Iterator.html
-->
<!-- ## References vs Pointers -->
<h2><a class="header" href="#参照-vs-ポインタ" id="参照-vs-ポインタ">参照 vs ポインタ</a></h2>
<!--
In Rust, pointers (called [_raw pointers_]) exist but are only used in specific
circumstances, as dereferencing them is always considered `unsafe` -- Rust
cannot provide its usual guarantees about what might be behind the pointer.
-->
<p>Rustでも、ポインタ（[<em>生ポインタ</em> と呼びます]）は存在しますが、限られた状況でしか使いません。
ポインタの参照外しは、常に<code>unsafe</code>と考えられるからです。
Rustは、ポインタの背後にあるかもしれないものについて、通常の保証を提供できません。</p>
<!-- [_raw pointers_]: https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer -->
<!--
In most cases, we instead use _references_, indicated by the `&` symbol, or
_mutable references_, indicated by `&mut`. References behave similarly to
pointers, in that they can be dereferenced to access the underlying values, but
they are a key part of Rust's ownership system: Rust will strictly enforce that
you may only have one mutable reference _or_ multiple non-mutable references to
the same value at any given time.
-->
<p>代わりに、ほとんどの場合、<code>&amp;</code>のシンボルで表現される <em>参照</em> もしくは <code>&amp;mut</code>で表現される <em>ミュータブルな参照</em> を使います。
参照は、ポインタと似た働きをします。つまり、裏にある値にアクセスするために参照外しができます。
しかし、参照は、Rustの所有権システムの重要な一部です。
Rustは、どんな時でも同じ値に対して、唯一のミュータブル参照を持つか、<em>あるいは</em>、複数のイミュータブル参照を持つか、を厳密に強制します。</p>
<!--
In practice this means you have to be more careful about whether you need
mutable access to data: where in C the default is mutable and you must be
explicit about `const`, in Rust the opposite is true.
-->
<p>実際のところ、データへのミュータブルアクセスが必要かどうか、をより慎重に検討する必要があることを意味します。
Cではデフォルトがミュータブルであり、明示的に<code>const</code>をつける必要があります。Rustではその反対です。</p>
<!--
One situation where you might still use raw pointers is interacting directly
with hardware (for example, writing a pointer to a buffer into a DMA peripheral
register), and they are also used under the hood for all peripheral access
crates to allow you to read and write memory-mapped registers.
-->
<p>生ポインタを使う可能性のある状況の1つは、直接ハードウェアとやり取りする時です（DMAペリフェラルのレジスタにバッファのポインタを書き込むなど）。
また、生ポインタは、メモリマップドレジスタの読み書きを可能にするために、ペリフェラルアクセスクレートの内部で使われています。</p>
<!-- ## Volatile Access -->
<h2><a class="header" href="#volatileアクセス-1" id="volatileアクセス-1">Volatileアクセス</a></h2>
<!--
In C, individual variables may be marked `volatile`, indicating to the compiler
that the value in the variable may change between accesses. Volatile variables
are commonly used in an embedded context for memory-mapped registers.
-->
<p>Cでは、個別の変数に<code>volatile</code>を付けることができます。
これは、変数の値がアクセスごとに変わるかもしれない、ということをコンパイラに伝えます。
組込みでは、Volatile変数はメモリマップドレジスタに広く使用されています。</p>
<!--
In Rust, instead of marking a variable as `volatile`, we use specific methods
to perform volatile access: [`core::ptr::read_volatile`] and
[`core::ptr::write_volatile`]. These methods take a `*const T` or a `*mut T`
(_raw pointers_, as discussed above) and perform a volatile read or write.
-->
<p>Rustでは、変数に<code>volatile</code>を付けるのではなく、volatileアクセスをするための特定のメソッドを使います。
<a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code>core::ptr::read_volatile</code></a>と<a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code>core::ptr::write_volatile</code></a>です。
これらのメソッドは、<code>*const T</code>か<code>*mut T</code>（上述の通り <em>生ポインタ</em> です）を受け取り、volatileな読み書きを行います。</p>
<!-- For example, in C you might write: -->
<p>例えば、Cでは次のように書きます。</p>
<pre><code class="language-c">volatile bool signalled = false;

void ISR() {
    // 割り込みが発生したというシグナル
    signalled = true;
}

void driver() {
    while(true) {
        // シグナルがあるまでスリープします
        while(!signalled) { WFI(); }
        // シグナルをリセットします
        signalled = false;
        // 割り込みを待っていた何らかのタスクを実行します
        run_task();
    }
}
</code></pre>
<!-- The equivalent in Rust would use volatile methods on each access: -->
<p>Rustで同じことをするには、各アクセスにvolatileメソッドを使用します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut SIGNALLED: bool = false;

#[interrupt]
fn ISR() {
<span class="boring">    // Signal that the interrupt has occurred
</span><span class="boring">    // (In real code, you should consider a higher level primitive,
</span><span class="boring">    //  such as an atomic type).
</span>    // 割り込みが発生したというシグナル
    // （実際のコードでは、アトミック型のような、より上位レベルのプリミティブを検討して下さい）
    unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, true) };
}

fn driver() {
    loop {
<span class="boring">        // Sleep until signalled
</span>        // シグナルがあるまでスリープします
        while unsafe { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
<span class="boring">        // Reset signalled indicator
</span>        // シグナルをリセットします
        unsafe { core::ptr::write_volatile(&amp;mut SIGNALLED, false) };
<span class="boring">        // Perform some task that was waiting for the interrupt
</span>        // 割り込みを待っていた何らかのタスクを実行します
        run_task();
    }
}
<span class="boring">}
</span></code></pre></pre>
<!--
A few things are worth noting in the code sample:
  * We can pass `&mut SIGNALLED` into the function requiring `*mut T`, since
    `&mut T` automatically converts to a `*mut T` (and the same for `*const T`)
  * We need `unsafe` blocks for the `read_volatile`/`write_volatile` methods,
    since they are `unsafe` functions. It is the programmer's responsibility
    to ensure safe use: see the methods' documentation for further details.
-->
<p>このコードサンプルには、いくつかの注目すべき点があります。</p>
<ul>
<li><code>*mut T</code>を要求する関数に、<code>&amp;mut SIGNALLED</code>を渡すことができます。
これは、<code>&amp;mut T</code>が<code>*mut T</code>に自動的に変換されるためです（<code>*const T</code>についても同じです）。</li>
<li><code>read_volatile</code>/<code>write_volatile</code>メソッドに<code>unsafe</code>ブロックが必要です。
これらの関数は<code>unsafe</code>だからです。安全な使用を保証することはプログラマの責任です。
詳細は、メソッドのドキュメントを参照して下さい。</li>
</ul>
<!--
It is rare to require these functions directly in your code, as they will
usually be taken care of for you by higher-level libraries. For memory mapped
peripherals, the peripheral access crates will implement volatile access
automatically, while for concurrency primitives there are better abstractions
available (see the [Concurrency chapter]).
-->
<p>これらの関数をコードに直接書くことは稀です。通常、より上位レベルのライブラリで面倒を見てくれます。
メモリマップドペリフェラルについては、ペリフェラルアクセスクレートがvolatileアクセスを自動的に実装します。
並行性プリミティブの場合、より優れた抽象化が利用できます（<a href="c-tips/../concurrency/index.html">並行性の章</a>を参照して下さい）。</p>
<!-- [Concurrency chapter]: ../concurrency/index.md -->
<!-- ## Packed and Aligned Types -->
<h2><a class="header" href="#パック型と整列型" id="パック型と整列型">パック型と整列型</a></h2>
<!--
In embedded C it is common to tell the compiler a variable must have a certain
alignment or a struct must be packed rather than aligned, usually to meet
specific hardware or protocol requirements.
-->
<p>組込みCでは、通常、特定のハードウェアやプロトコルの要件を満たすために、変数に特定のアライメントが必要なことや、
構造体が整列されているだけでなくパックされている必要があることを、コンパイラに指示することが一般的です。</p>
<!--
In Rust this is controlled by the `repr` attribute on a struct or union. The
default representation provides no guarantees of layout, so should not be used
for code that interoperates with hardware or C. The compiler may re-order
struct members or insert padding and the behaviour may change with future
versions of Rust.
-->
<p>Rustでは、これは構造体または共用体の<code>repr</code>アトリビュートによって制御されます。
デフォルトでは、レイアウトは保証されないため、ハードウェアやCとやり取りするコードでは使うべきではありません。
コンパイラは、構造体のメンバを並べ替えたり、パディングを挿入したりする可能性があります。この動作は将来のバージョンのRustで変更になる可能性があります。</p>
<pre><pre class="playground"><code class="language-rust">struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2
<span class="boring">// Note ordering has been changed to x, z, y to improve packing.
</span>// データの詰め方を改善するために、x, y, zの順序が入れ替わっていることに注目して下さい。
</code></pre></pre>
<!-- To ensure layouts that are interoperable with C, use `repr(C)`: -->
<p>Cと相互にやり取りできるレイアウトを保証するためには、<code>repr(C)</code>を使います。</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z);
}

// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64
<span class="boring">// Ordering is preserved and the layout will not change over time.
</span><span class="boring">// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.
</span>// 順序は維持され、レイアウトは時間が経っても変化しません。
// `z`は2バイトで整列されており、`y`と`z`の間には、1バイトのパディングが存在します。
</code></pre></pre>
<!-- To ensure a packed representation, use `repr(packed)`: -->
<p>パックされた表現を保証する場合、<code>repr(packed)</code>を使います。</p>
<pre><pre class="playground"><code class="language-rust">#[repr(packed)]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
<span class="boring">    // Unsafe is required to borrow a field of a packed struct.
</span>    // パックされた構造体のフィールドを借用するには、アンセーフが必要です。
    unsafe { println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z) };
}

// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493
<span class="boring">// No padding has been inserted between `y` and `z`, so now `z` is unaligned.
</span>// `y`と`z`の間にパディングは挿入されていません。そのため、`z`は整列されていません。
</code></pre></pre>
<!-- Note that using `repr(packed)` also sets the alignment of the type to `1`. -->
<p><code>repr(packed)</code>を使うと、型のアライメントも<code>1</code>に設定されることに注意して下さい。</p>
<!--
Finally, to specify a specific alignment, use `repr(align(n))`, where `n` is
the number of bytes to align to (and must be a power of two):
-->
<p>最後に、特定のアライメントを指定するために、<code>repr(align(n))</code>を使います。
ここで<code>n</code>は、整列するバイト数です（2の累乗である必要があります）。</p>
<pre><pre class="playground"><code class="language-rust">#[repr(C)]
#[repr(align(4096))]
struct Foo {
    x: u16,
    y: u8,
    z: u16,
}

fn main() {
    let v = Foo { x: 0, y: 0, z: 0 };
    let u = Foo { x: 0, y: 0, z: 0 };
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;v.x, &amp;v.y, &amp;v.z);
    println!(&quot;{:p} {:p} {:p}&quot;, &amp;u.x, &amp;u.y, &amp;u.z);
}

// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004
// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004
<span class="boring">// The two instances `u` and `v` have been placed on 4096-byte alignments,
</span><span class="boring">// evidenced by the `000` at the end of their addresses.
</span>// 2つのインスタンス`u`と`v`は4096バイトのアライメントで配置されます。
// インスタンスのアドレスの最後は`000`になっています。
</code></pre></pre>
<!--
Note we can combine `repr(C)` with `repr(align(n))` to obtain an aligned and
C-compatible layout. It is not permissible to combine `repr(align(n))` with
`repr(packed)`, since `repr(packed)` sets the alignment to `1`. It is also not
permissible for a `repr(packed)` type to contain a `repr(align(n))` type.
-->
<p>整列されていてCと互換性のあるレイアウトを取得するため、<code>repr(C)</code>と<code>repr(align(n))</code>とを組み合わせることができます。
<code>repr(align(n))</code>と<code>repr(packed)</code>とを組み合わせることはできません。<code>repr(packed)</code>はアライメントを<code>1</code>に設定するからです。
<code>repr(packed)</code>の型を<code>repr(align(n))</code>の型に含めることもできません。</p>
<!--
For further details on type layouts, refer to the [type layout] chapter of the
Rust Reference.
-->
<p>型レイアウトに関するさらなる詳細は、Rustリファレンスの<a href="https://doc.rust-lang.org/reference/type-layout.html">型レイアウト</a>の章を参照して下さい。</p>
<!-- [type layout]: https://doc.rust-lang.org/reference/type-layout.html -->
<!-- ## Other Resources -->
<h2><a class="header" href="#その他のリソース-1" id="その他のリソース-1">その他のリソース</a></h2>
<!--
* In this book:
    * [A little C with your Rust](../interoperability/c-with-rust.md)
    * [A little Rust with your C](../interoperability/rust-with-c.md)
* [The Rust Embedded FAQs](https://docs.rust-embedded.org/faq.html)
* [Rust Pointers for C Programmers](http://blahg.josefsipek.net/?p=580)
* [I used to use pointers - now what?](https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md)
-->
<ul>
<li>本書内
<ul>
<li><a href="c-tips/../interoperability/c-with-rust.html">Rustと少しのC</a></li>
<li><a href="c-tips/../interoperability/rust-with-c.html">Cと少しのRust</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">組込みRustよくある質問</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">CプログラマのためのRustのポインタ</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">昔はポインタを使っていました。今は？</a></li>
</ul>
<!-- # Interoperability -->
<h1><a class="header" href="#相互運用性" id="相互運用性">相互運用性</a></h1>
<!--
Interoperability between Rust and C code is always dependent
on transforming data between the two languages.
For this purposes there are two dedicated modules
in the `stdlib` called
[`std::ffi`](https://doc.rust-lang.org/std/ffi/index.html) and
[`std::os::raw`](https://doc.rust-lang.org/std/os/raw/index.html).
-->
<p>RustとCとの相互運用性は、常に2つの言語間のデータ変換に依存しています。
そこで、2つの専用モジュールが<code>stdlib</code>内にあります。
<a href="https://doc.rust-lang.org/std/ffi/index.html"><code>std::ffi</code></a>と
<a href="https://doc.rust-lang.org/std/os/raw/index.html"><code>std::os::raw</code></a>と呼ばれるものです。</p>
<!--
`std::os::raw` deals with low-level primitive types that can
be converted implicitly by the compiler
because the memory layout between Rust and C
is similar enough or the same.
-->
<p><code>std::os::raw</code>は、コンパイラによって暗黙的に変換される低レベルのプリミティブ型を扱います。
RustとCとの間で、これらのプリミティブ型のメモリレイアウトは十分似ているか、同じだからです。</p>
<!--
`std::ffi` provides some utility for converting more complex
types such as Strings, mapping both `&str` and `String`
to C-types that are easier and safer to handle.
-->
<p><code>std::ffi</code>は、文字列のようなより複雑な型を変換し、<code>&amp;str</code>と<code>String</code>の両方を、
より扱いやすく安全なCの型にマッピングするためのユーティリティを提供します。</p>
<!--
Neither of these modules are available in `core`, but you can find a `#![no_std]`
compatible version of `std::ffi::{CStr,CString}` in the [`cstr_core`] crate, and
most of the `std::os::raw` types in the [`cty`] crate.
-->
<p>これらの2つのモジュールは、どちらも<code>core</code>では利用できませんが、
<code>#![no_std]</code>互換バージョンの<code>std::ffi::{CStr,CString}</code>が、<a href="https://crates.io/crates/cstr_core"><code>cstr_core</code></a>クレートにあります。
そして、ほとんどの<code>std::os::raw</code>の型は、<a href="https://crates.io/crates/cty"><code>cty</code></a>クレートにあります。</p>
<!--
| Rust type  | Intermediate | C type       |
|------------|--------------|--------------|
| String     | CString      | *char        |
| &str       | CStr         | *const char  |
| ()         | c_void       | void         |
| u32 or u64 | c_uint       | unsigned int |
| etc        | ...          | ...          |
-->
<table><thead><tr><th>Rustの型</th><th>中間表現</th><th>Cの型</th></tr></thead><tbody>
<tr><td>String</td><td>CString</td><td>*char</td></tr>
<tr><td>&amp;str</td><td>CStr</td><td>*const char</td></tr>
<tr><td>()</td><td>c_void</td><td>void</td></tr>
<tr><td>u32 or u64</td><td>c_uint</td><td>unsigned int</td></tr>
<tr><td>他</td><td>...</td><td>...</td></tr>
</tbody></table>
<!--
As mentioned above, primitive types can be converted
by the compiler implicitly.
-->
<p>上述の通り、プリミティブ型は、コンパイラによって暗黙的に変換されます。</p>
<pre><code class="language-rust ignore">unsafe fn foo(num: u32) {
    let c_num: c_uint = num;
    let r_num: u32 = c_num;
}
</code></pre>
<!-- ## Interoperability with other build systems -->
<h2><a class="header" href="#他のビルドシステムとの相互運用性" id="他のビルドシステムとの相互運用性">他のビルドシステムとの相互運用性</a></h2>
<!--
A common requirement for including Rust in your embedded project is combining
Cargo with your existing build system, such as make or cmake.
-->
<p>組込みプロジェクトにRustを組み込むための共通の要件は、Cargoとmakeやcmakeのような既存のビルドシステムとを組み合わせることです。</p>
<!--
We are collecting examples and use cases for this on our issue tracker in
[issue #61].
-->
<p><a href="https://github.com/rust-embedded/book/issues/61">issue #61</a>でこれに関する事例とユースケースを集めています。</p>
<!-- ## Interoperability with RTOSs -->
<h2><a class="header" href="#rtosとの相互運用性" id="rtosとの相互運用性">RTOSとの相互運用性</a></h2>
<!--
Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in
progress; especially calling RTOS functions from Rust can be tricky.
-->
<p>RustをFreeRTOSやChibiOSといったRTOSに統合することは、まだ作業を進めている状態です。
特に、RTOSの関数をRustから呼び出すことはトリッキーです。</p>
<!--
We are collecting examples and use cases for this on our issue tracker in
[issue #62].
-->
<p><a href="https://github.com/rust-embedded/book/issues/62">issue #62</a>でこれに関する事例とユースケースを集めています。</p>
<!-- # A little C with your Rust -->
<h1><a class="header" href="#rustと少しのc" id="rustと少しのc">Rustと少しのC</a></h1>
<!-- Using C or C++ inside of a Rust project consists of two major parts: -->
<p>CまたはC++をRustプロジェクトの内部で使うには、主に2つの対応をします。</p>
<!--
- Wrapping the exposed C API for use with Rust
- Building your C or C++ code to be integrated with the Rust code
-->
<ul>
<li>公開されているCのAPIを、Rustで使えるようにラッピングする</li>
<li>CまたはC++のコードを、Rustのコードと一緒にビルドする</li>
</ul>
<!--
As C++ does not have a stable ABI for the Rust compiler to target, it is recommended to use the `C` ABI when combining Rust with C or C++.
-->
<p>C++は、Rustコンパイラがターゲットにできる安定したABIを持っていないため、CまたはC++とRustとを組み合わせるときは、<code>C</code>のABIを使うのがお勧めです。</p>
<!-- ## Defining the interface -->
<h2><a class="header" href="#インタフェースの定義" id="インタフェースの定義">インタフェースの定義</a></h2>
<!--
Before consuming C or C++ code from Rust, it is necessary to define (in Rust) what data types and function signatures exist in the linked code. In C or C++, you would include a header (`.h` or `.hpp`) file which defines this data. In Rust, it is necessary to either manually translate these definitions to Rust, or use a tool to generate these definitions.
-->
<p>RustからCまたはC++のコードを使う前に、リンクされるコードにどのようなデータ型や関数シグネチャが存在するかを、（Rustに）定義する必要があります。
CまたはC++では、このデータを定義したヘッダファイル（<code>.h</code>または<code>.hpp</code>）をインクルードします。
Rustでは、これらの定義を手動で変換するか、定義を自動生成するツールを使うか、のいずれかが必要です。</p>
<!-- First, we will cover manually translating these definitions from C/C++ to Rust. -->
<p>まずは、C/C++からRustに、定義を手動で変換する方法を説明します。</p>
<!-- ### Wrapping C functions and Datatypes -->
<h3><a class="header" href="#cの関数とデータ型のラッピング" id="cの関数とデータ型のラッピング">Cの関数とデータ型のラッピング</a></h3>
<!--
Typically, libraries written in C or C++ will provide a header file defining all types and functions used in public interfaces. An example file may look like this:
-->
<p>通常、CまたはC++で書かれたライブラリは、公開インタフェースで使用する全ての型と関数を定義するヘッダファイルを提供します。
ヘッダファイルの例は次の通りです。</p>
<pre><code class="language-C">/* File: cool.h */
typedef struct CoolStruct {
    int x;
    int y;
} CoolStruct;

void cool_function(int i, char c, CoolStruct* cs);
</code></pre>
<!-- When translated to Rust, this interface would look as such: -->
<p>Rustに変換すると、このインタフェースは次のようになります。</p>
<pre><code class="language-rust ignore">/* File: cool_bindings.rs */
#[repr(C)]
pub struct CoolStruct {
    pub x: cty::c_int,
    pub y: cty::c_int,
}

pub extern &quot;C&quot; fn cool_function(
    i: cty::c_int,
    c: cty::c_char,
    cs: *mut CoolStruct
);
</code></pre>
<!-- Let's take a look at this definition one piece at a time, to explain each of the parts. -->
<p>各部分の説明をするため、この定義を1つずつ見ていきましょう。</p>
<pre><code class="language-rust ignore">#[repr(C)]
pub struct CoolStruct { ... }
</code></pre>
<!--
By default, Rust does not guarantee order, padding, or the size of data included in a `struct`. In order to guarantee compatibility with C code, we include the `#[repr(C)]` attribute, which instructs the Rust compiler to always use the same rules C does for organizing data within a struct.
-->
<p>デフォルトでは、Rustは<code>struct</code>に含まれるデータの順序やパディング、サイズを保証しません。
Cのコードとの互換性を保証するために、<code>#[repr(C)]</code>アトリビュートを使います。
このアトリビュートにより、Rustコンパイラは、構造体のデータをCと同じルールで構成します。</p>
<pre><code class="language-rust ignore">pub x: cty::c_int,
pub y: cty::c_int,
</code></pre>
<!--
Due to the flexibility of how C or C++ defines an `int` or `char`, it is recommended to use primitive data types defined in `cty`, which will map types from C to types in Rust
-->
<p>CまたはC++が<code>int</code>や<code>char</code>を定義する方法は柔軟であるため、<code>cty</code>で定義されているプリミティブデータ型の使用をお勧めします。
ctyは、Cの型をRustの型にマップします。</p>
<pre><code class="language-rust ignore">pub extern &quot;C&quot; fn cool_function( ... );
</code></pre>
<!--
This statement defines the signature of a function that uses the C ABI, called `cool_function`. By defining the signature without defining the body of the function, the definition of this function will need to be provided elsewhere, or linked into the final library or binary from a static library.
-->
<p>このステートメントは、<code>cool_function</code>という名前の、CのABIを使った関数シグネチャを定義します。
関数本体の定義なしにシグネチャを定義することで、この関数の定義は別の場所で与えられるか、静的ライブラリから最終的なライブラリまたはバイナリにリンクされる必要があります。</p>
<pre><code class="language-rust ignore">    i: cty::c_int,
    c: cty::c_char,
    cs: *mut CoolStruct
</code></pre>
<!--
Similar to our datatype above, we define the datatypes of the function arguments using C-compatible definitions. We also retain the same argument names, for clarity.
-->
<p>上記のデータ型と同様に、Cと互換の定義を使って、関数の引数のデータ型を定義します。
わかりやすくするために、引数の名前は同じままにしてあります。</p>
<!--
We have one new type here, `*mut CoolStruct`. As C does not have a concept of Rust's references, which would look like this: `&mut CoolStruct`, we instead have a raw pointer. As dereferencing this pointer is `unsafe`, and the pointer may in fact be a `null` pointer, care must be taken to ensure the guarantees typical of Rust when interacting with C or C++ code.
-->
<p><code>*mut CoolStruct</code>という新しい型があります。Cは、<code>&amp;mut CoolStruct</code>のようなRustの参照という概念を持っていません。
代わりに、生ポインタを使います。
このポインタの参照外しは、<code>unsafe</code>です。また、このポインタは実際に<code>null</code>ポインタになる可能性があります。
CまたはC++のコードとやり取りする時には、Rustが通常行う保証を確実にするように気をつける必要があります。</p>
<!-- ### Automatically generating the interface -->
<h2><a class="header" href="#インタフェースの自動生成" id="インタフェースの自動生成">インタフェースの自動生成</a></h2>
<!--
Rather than manually generating these interfaces, which may be tedious and error prone, there is a tool called [bindgen] which will perform these conversions automatically. For instructions of the usage of [bindgen], please refer to the [bindgen user's manual], however the typical process consists of the following:
-->
<p>面倒であり間違いの元である手動のインタフェース生成ではなく、<a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a>と呼ばれるインタフェース変換を自動で行ってくれるツールがあります。
<a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a>の使用手順は、<a href="https://rust-lang.github.io/rust-bindgen/">bindgenユーザマニュアル</a>を参照して下さい。
<a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a>を使用するための一般的なプロセスは、次の通りです。</p>
<!--
1. Gather all C or C++ headers defining interfaces or datatypes you would like to use with Rust
2. Write a `bindings.h` file, which `#include "..."`'s each of the files you gathered in step one
3. Feed this `bindings.h` file, along with any compilation flags used to compile
  your code into `bindgen`. Tip: use `Builder.ctypes_prefix("cty")` /
  `--ctypes-prefix=cty` to make the generated code `#![no_std]` compatible.
4. `bindgen` will produce the generated Rust code to the output of the terminal window. This file may be piped to a file in your project, such as `bindings.rs`. You may use this file in your Rust project to interact with C/C++ code compiled and linked as an external library
-->
<ol>
<li>Rustで使いたいインタフェースやデータ型を定義している全てのCまたはC++ヘッダを集めます。</li>
<li>ステップ1で集めたヘッダファイルを<code>#include &quot;...&quot;</code>する<code>bindings.h</code>ファイルを書きます。</li>
<li><code>bindgen</code>にコンパイルフラグとコードと共に、<code>bindings.h</code>を与えます。
ヒント：<code>#![no_std]</code>互換なコードを生成するために、<code>Builder.ctypes_prefix(&quot;cty&quot;)</code>と<code>--ctypes-prefix=cty</code>を使って下さい。</li>
<li><code>bindgen</code>は、端末のウィンドウに生成したRustコードを出力します。これは、<code>bindings.rs</code>のようなプロジェクトのファイルにパイプすることができます。
外部ライブラリとしてコンパイル、リンクされたC/C++コードとやり取りするために、このファイルをRustプロジェクトで使用できます。</li>
</ol>
<!--
[bindgen]: https://github.com/rust-lang-nursery/rust-bindgen
[bindgen user's manual]: https://rust-lang.github.io/rust-bindgen/
-->
<!-- ## Building your C/C++ code -->
<h2><a class="header" href="#ccコードのビルド" id="ccコードのビルド">C/C++コードのビルド</a></h2>
<!--
As the Rust compiler does not directly know how to compile C or C++ code (or code from any other language, which presents a C interface), it is necessary to compile your non-Rust code ahead of time.
-->
<p>Rustコンパイラは、CまたはC++のコード（または、Cのインタフェースを提供する他の言語のコード）をコンパイルする方法を直接は知らないため、Rustでないコードは事前にコンパイルする必要があります。</p>
<!--
For embedded projects, this most commonly means compiling the C/C++ code to a static archive (such as `cool-library.a`), which can then be combined with your Rust code at the final linking step.
-->
<p>組込みプロジェクトでは、C/C++のコードを（<code>cool-library.a</code>のような）静的なアーカイブにコンパイルすることを意味します。
このアーカイブは、最終リンク時に、Rustのコードに組み込むことができます。</p>
<!--
If the library you would like to use is already distributed as a static archive, it is not necessary to rebuild your code. Just convert the provided interface header file as described above, and include the static archive at compile/link time.
-->
<p>使おうとしているライブラリが、既に静的なアーカイブとして配布されている場合、そのコードを再度ビルドする必要はありません。
提供されているインタフェースのヘッダファイルを、上述の方法で、単に変換するだけです。
そして、その静的なアーカイブをコンパイル/リンク時に組み込みます。</p>
<!--
If your code exists as a source project, it will be necessary to compile your C/C++ code to a static library, either by triggering your existing build system (such as `make`, `CMake`, etc.), or by porting the necessary compilation steps to use a tool called the `cc` crate. For both of these steps, it is necessary to use a `build.rs` script.
-->
<p>もしコードがソースファイルとして存在するのであれば、C/C++のコードを静的ライブラリとしてコンパイルする必要があります。
（<code>make</code>や<code>CMake</code>のような）ビルドシステムを使うか、必要なコンパイルステップを<code>cc</code>クレートを使って移植するか、いずれかの方法を取れます。
どちらの方法でも、<code>build.rs</code>スクリプトを使う必要があります。</p>
<!-- ### Rust `build.rs` build scripts -->
<h3><a class="header" href="#rustのbuildrsビルドスクリプト" id="rustのbuildrsビルドスクリプト">Rustの<code>build.rs</code>ビルドスクリプト</a></h3>
<!--
A `build.rs` script is a file written in Rust syntax, that is executed on your compilation machine, AFTER dependencies of your project have been built, but BEFORE your project is built.
-->
<p><code>build.rs</code>スクリプトは、Rustの構文で書かれたファイルです。
このスクリプトは、プロジェクトの依存をビルドした後、プロジェクトをビルドする前に、コンパイルを行っているコンピュータ上で実行されます。</p>
<!--
The full reference may be found [here](https://doc.rust-lang.org/cargo/reference/build-scripts.html). `build.rs` scripts are useful for generating code (such as via [bindgen]), calling out to external build systems such as `Make`, or directly compiling C/C++ through use of the `cc` crate
-->
<p>完全なリファレンスは<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">ここ</a>にあります。
<code>build.rs</code>スクリプトは、（<a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a>のようなツールを用いて）コードを生成したり、
<code>Make</code>のような外部ビルドシステムを呼び出したり、<code>cc</code>クレートを使ってC/C++を直接ビルドしたりするのに便利です。</p>
<!-- ### Triggering external build systems -->
<h3><a class="header" href="#外部ビルドシステムの使用" id="外部ビルドシステムの使用">外部ビルドシステムの使用</a></h3>
<!--
For projects with complex external projects or build systems, it may be easiest to use [`std::process::Command`] to "shell out" to your other build systems by traversing relative paths, calling a fixed command (such as `make library`), and then copying the resulting static library to the proper location in the `target` build directory.
-->
<!-- "shell out"を「シェルを呼び出す」としています。多分意図するところはあっているはずです。 -->
<p>複雑な外部プロジェクトや外部ビルドシステムを使うプロジェクトに関しては、[<code>std::process::Command</code>]を使って、他のビルドシステムに対して「シェルを呼び出す」のが最も簡単でしょう。
これにより、相対パスを渡り歩いたり、（<code>make library</code>のような）固定のコマンドを呼び出したり、その後、<code>target</code>ビルドディレクトリにある静的ライブラリをコピーしたりすることができます。</p>
<!--
While your crate may be targeting a `no_std` embedded platform, your `build.rs` executes only on machines compiling your crate. This means you may use any Rust crates which will run on your compilation host.
-->
<p>作っているクレートが<code>no_std</code>な組込みプラットフォームをターゲットにしていたとしても、<code>build.rs</code>はクレートをコンパイルしているコンピュータ上でのみ動作します。
そのため、コンパイルしているホスト上で動作する、あらゆるRustのクレートを使うことができます。</p>
<!-- ### Building C/C++ code with the `cc` crate -->
<h3><a class="header" href="#ccコードをccクレートでビルド" id="ccコードをccクレートでビルド">C/C++コードを<code>cc</code>クレートでビルド</a></h3>
<!--
For projects with limited dependencies or complexity, or for projects where it is difficult to modify the build system to produce a static library (rather than a final binary or executable), it may be easier to instead utilize the [`cc` crate], which provides an idiomatic Rust interface to the compiler provided by the host.
-->
<p>依存や複雑さが少ないプロジェクトや、（最終バイナリや実行ファイルではなく）静的ライブラリを作成するためにビルドシステムを修正するのが難しいプロジェクトであれば、
代わりに<a href="https://github.com/alexcrichton/cc-rs"><code>cc</code>クレート</a>を使う方が簡単でしょう。
ccクレートは、ホスト上のコンパイラへの、扱いやすいRustインタフェースを提供します。</p>
<!-- [`cc` crate]: https://github.com/alexcrichton/cc-rs -->
<!--
In the simplest case of compiling a single C file as a dependency to a static library, an example `build.rs` script using the [`cc` crate] would look like this:
-->
<p>単一のCファイルを静的ライブラリにコンパイルする最も単純な例では、<a href="https://github.com/alexcrichton/cc-rs"><code>cc</code>クレート</a>を使った<code>build.rs</code>スクリプトは次のようになります。</p>
<pre><pre class="playground"><code class="language-rust">extern crate cc;

fn main() {
    cc::Build::new()
        .file(&quot;foo.c&quot;)
        .compile(&quot;libfoo.a&quot;);
}
</code></pre></pre>
<!-- # A little Rust with your C -->
<h1><a class="header" href="#cと少しのrust" id="cと少しのrust">Cと少しのRust</a></h1>
<!-- Using Rust code inside a C or C++ project mostly consists of two parts. -->
<p>CまたはC++のプロジェクト内でRustのコードを使うためには、主に次の2つの対応をします。</p>
<!--
- Creating a C-friendly API in Rust
- Embedding your Rust project into an external build system
-->
<ul>
<li>Cが扱いやすいAPIをRustに作ります</li>
<li>外部ビルドシステムにRustプロジェクトを組み込みます</li>
</ul>
<!--
Apart from `cargo` and `meson`, most build systems don't have native Rust support.
So you're most likely best off just using `cargo` for compiling your crate and
any dependencies.
-->
<p><code>cargo</code>と<code>meson</code>は別として、ほとんどのビルドシステムはRustをサポートしていません。
そのため、自分のクレートとその依存関係をコンパイルするには、<code>cargo</code>を使うのが一番です。</p>
<!-- ## Setting up a project -->
<h2><a class="header" href="#プロジェクトの準備" id="プロジェクトの準備">プロジェクトの準備</a></h2>
<!-- Create a new `cargo` project as usual. -->
<p>いつもどおり、新しい<code>cargo</code>プロジェクトを作成します。</p>
<!--
There are flags to tell `cargo` to emit a systems library, instead of
its regular rust target.
This also allows you to set a different output name for your library,
if you want it to differ from the rest of your crate.
-->
<p>通常のRustのターゲットではなく、システムライブラリを出力するように、<code>cargo</code>に指示するフラグがあります。
クレートの残り部分と異なる名前を付けたい場合、ライブラリに対して、別の名前を設定することもできます。</p>
<pre><code class="language-toml">[lib]
name = &quot;your_crate&quot;
crate-type = [&quot;cdylib&quot;]      # 動的ライブラリを作ります
# crate-type = [&quot;staticlib&quot;] # 静的ライブラリを作ります
</code></pre>
<!-- ## Building a `C` API -->
<h2><a class="header" href="#c-apiの作成" id="c-apiの作成"><code>C</code> APIの作成</a></h2>
<!--
Because C++ has no stable ABI for the Rust compiler to target, we use `C` for
any interoperability between different languages. This is no exception when using Rust
inside of C and C++ code.
-->
<p>C++は、Rustコンパイラがターゲットにできる安定したABIを持っていないため、別言語との相互運用には、CのABIを使用します。
CとC++のコード内でRustを使うとき、このことに例外はありません。</p>
<h3><a class="header" href="#no_mangle" id="no_mangle"><code>#[no_mangle]</code></a></h3>
<!--
The Rust compiler mangles symbol names differently than native code linkers expect.
As such, any function that Rust exports to be used outside of Rust needs to be told
not to be mangled by the compiler.
-->
<p>Rustコンパイラは、シンボル名をネイティブコードリンカが期待するものとは異なるものにマングルします。
そのため、Rustの外にエクスポートするRustの関数は、マングルしないようにコンパイラに指示する必要があります。</p>
<h3><a class="header" href="#extern-c" id="extern-c"><code>extern &quot;C&quot;</code></a></h3>
<!--
By default, any function you write in Rust will use the
Rust ABI (which is also not stabilized).
Instead, when building outwards facing FFI APIs we need to
tell the compiler to use the system ABI.
-->
<p>デフォルトでは、Rustに書いたいずれの関数もRustのABI（これも安定化されていません）を使います。
代わりに、外に公開するFFI APIはシステムABIを使うように、コンパイラに指示する必要があります。</p>
<!--
Depending on your platform, you might want to target a specific ABI version, which are
documented [here](https://doc.rust-lang.org/reference/items/external-blocks.html).
-->
<p>プラットフォームによっては、特定のABIバージョンをターゲットにしたい場合があります。
ABIについては、<a href="https://doc.rust-lang.org/reference/items/external-blocks.html">ここ</a>にドキュメントがあります。</p>
<hr />
<!--
Putting these parts together, you get a function that looks roughly like this.
-->
<p>これらの部品をまとめると、おおよそ次のような関数になります。</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn rust_function() {

}
</code></pre>
<!--
Just as when using `C` code in your Rust project you now need to transform data
from and to a form that the rest of the application will understand.
-->
<p>Rustプロジェクトで<code>C</code>コードを使った時と同様に、異なる言語間で理解できるデータ型に変換する必要があります。</p>
<!-- ## Linking and greater project context. -->
<h2><a class="header" href="#リンクとより大きなプロジェクトの状況" id="リンクとより大きなプロジェクトの状況">リンクとより大きなプロジェクトの状況</a></h2>
<!--
So then, that's one half of the problem solved.
How do you use this now?
-->
<p>ここまでで、問題の半分は解決しました。
これをどうやって使うのでしょうか？</p>
<!-- **This very much depends on your project and/or build system** -->
<p><strong>それは、プロジェクトやビルドシステムに強く依存します。</strong></p>
<!--
`cargo` will create a `my_lib.so`/`my_lib.dll` or `my_lib.a` file,
depending on your platform and settings. This library can simply be linked
by your build system.
-->
<p><code>cargo</code>は、プラットフォームと設定に依存して、<code>my_lib.so</code>、<code>my_lib.dll</code>または<code>my_lib.a</code>ファイルを作成します。
このライブラリは、そのプラットフォームのビルドシステムによって簡単にリンクすることができます。</p>
<!--
However, calling a Rust function from C requires a header file to declare
the function signatures.
-->
<p>しかし、CからRustを呼ぶためには、関数シグネチャを宣言するためのヘッダファイルが必要です。</p>
<!-- Every function in your Rust-ffi API needs to have a corresponding header function. -->
<p>Rust-ffi APIの関数全てが、対応する関数ヘッダを持つ必要があります。</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern &quot;C&quot; fn rust_function() {}
</code></pre>
<!-- would then become -->
<p>上記は、次のようになるでしょう。</p>
<pre><code class="language-C">void rust_function();
</code></pre>
<!-- etc. -->
<p>などなど。</p>
<!--
There is a tool to automate this process,
called [cbindgen] which analyses your Rust code
and then generates headers for your C and C++ projects from it.
-->
<p>このプロセスを自動化する<a href="https://github.com/eqrion/cbindgen">cbindgen</a>というツールがあります。
このツールは、Rustのコードを解析して、CとC++プロジェクトのためのヘッダを生成します。</p>
<!--
At this point, using the Rust functions from C
is as simple as including the header and calling them!
-->
<p>この時点で、CからRustの関数を使うには、単にヘッダをインクルードして、それを呼び出すだけです！</p>
<pre><code class="language-C">#include &quot;my-rust-project.h&quot;
rust_function();
</code></pre>
<!-- # Unsorted topics -->
<h1><a class="header" href="#未分類のトピック" id="未分類のトピック">未分類のトピック</a></h1>
<!-- # Optimizations: the speed size tradeoff -->
<h1><a class="header" href="#最適化速度とサイズのトレードオフ" id="最適化速度とサイズのトレードオフ">最適化：速度とサイズのトレードオフ</a></h1>
<!--
Everyone wants their program to be super fast and super small but it's usually
not possible to have maximize both characteristics. This section discusses the
different optimization levels that `rustc` provides and how the affect the
execution time and binary size of a program.
-->
<p>誰もがプログラムを超高速で超小さくしたいと願いますが、両方の特性を最大化することはできません。
このセクションは、<code>rustc</code>が提供する異なる最適化レベルについて、どのようにプログラムの実行時間とバイナリサイズに影響するかを説明します。</p>
<!-- ## No optimizations -->
<h2><a class="header" href="#最適化なし" id="最適化なし">最適化なし</a></h2>
<!--
This is the default. When you call `cargo build` you use the development (AKA
`dev`) profile. This profile is optimized for debugging so it enables debug
information and does *not* enable any optimizations, i.e. it uses `-C opt-level
= 0`.
-->
<p>これはデフォルトです。<code>cargo build</code>を実行する場合、開発（別名<code>dev</code>）プロファイルを使います。
このプロファイルはデバッグに最適化されています。そのため、デバッグ情報が有効化されており、最適化は一切有効化されて<em>いません</em>。
つまり、<code>-C opt-level = 0</code>を使用します。</p>
<!--
At least for bare metal development, debuginfo is zero cost in the sense that it
won't occupy space in Flash / ROM so we actually recommend that you enable
debuginfo in the release profile -- it is disabled by default. That will let you
use breakpoints when debugging release builds.
-->
<p>少なくともベアメタルの開発では、デバッグ情報はある意味ゼロコストです。
デバッグ情報は、Flash/ROMの容量を使いません。そのため、リリースプロファイルで、デフォルトで無効化されているデバッグ情報を有効化することをお勧めします。
これにより、リリースビルドをデバッグする時、ブレイクポイントを使うことができます。</p>
<pre><code class="language-toml">[profile.release]
# シンボルは素晴らしく、Flashのサイズを増やしません
debug = true
</code></pre>
<!--
No optimizations is great for debugging because stepping through the code feels
like you are executing the program statement by statement, plus you can `print`
stack variables and function arguments in GDB. When the code is optimized trying
to print variables results in `$0 = <value optimized out>` being printed.
-->
<p>最適化しないことはデバッグでは重要です。コードをステップ実行する時、プログラムをステートメントごとに実行しているように感じられるからです。
さらに、スタックの変数や関数の引数をGDBで<code>print</code>することができます。
コードが最適化されると、変数を表示しようとしても、<code>$0 = &lt;value optimized out&gt;</code>と表示されます。</p>
<!--
The biggest downside of the `dev` profile is that the resulting binary will be
huge and slow. The size is usually more of a problem because unoptimized
binaries can occupy dozens of KiB of Flash, which your target device may not
have -- the result: your unoptimized binary doesn't fit in your device!
-->
<p><code>dev</code>プロファイルの最大の欠点は、バイナリが大きく、遅いことです。
バイナリサイズは通常、より問題となります。最適化されていないバイナリは数十KiBもFlashを専有するからです。
ターゲットデバイスは、数十KiBものFlashを持っていないかもしれず、最適化されていないバイナリは、デバイス内に納まりません。</p>
<!-- Can we have smaller debugger friendly binaries? Yes, there's a trick. -->
<p>デバッガで扱いやすい、小さなバイナリを作ることができるのでしょうか？できます。良いやり方があります。</p>
<!-- ### Optimizing dependencies -->
<h3><a class="header" href="#依存関係の最適化" id="依存関係の最適化">依存関係の最適化</a></h3>
<!--
> **WARNING** This section uses an unstable feature and it was last tested on
> 2018-09-18. Things may have changed since then!
-->
<blockquote>
<p><strong>注意</strong> このセクションは、2018-9-18に最後にテストされた安定化していないフィーチャを使います。
それ以降、状況が変わっているかもしれません！</p>
</blockquote>
<!--
On nightly, there's a Cargo feature named [`profile-overrides`] that lets you
override the optimization level of dependencies. You can use that feature to
optimize all dependencies for size while keeping the top crate unoptimized and
debugger friendly.
-->
<p>nightlyでは、<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-overrides"><code>profile-overrides</code></a>と呼ばれるCargoフィーチャがあります。これは、依存関係の最適化レベルをオーバーライドします。
このフィーチャを使って、全ての依存クレートのサイズを最適化しながら、トップクレートを最適化しないでデバッガで扱いやすくすることができます。。</p>
<!-- Here's an example: -->
<p>例を示します。</p>
<pre><code class="language-toml"># Cargo.toml
cargo-features = [&quot;profile-overrides&quot;] # +

[package]
name = &quot;app&quot;
# ..

[profile.dev.overrides.&quot;*&quot;] # +
opt-level = &quot;z&quot; # +
</code></pre>
<!-- Without the override: -->
<p>オーバーライドなしでは、次の通りです。</p>
<pre><code class="language-console">$ cargo size --bin app -- -A
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 9060   0x8000400
.rodata               1708   0x8002780
.data                    0  0x20000000
.bss                     4  0x20000000
</code></pre>
<!-- With the override: -->
<p>オーバーライドをすると、以下のようになります。</p>
<pre><code class="language-console">$ cargo size --bin app -- -A
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 3490   0x8000400
.rodata               1100   0x80011c0
.data                    0  0x20000000
.bss                     4  0x20000000
</code></pre>
<!--
That's a 6 KiB reduction in Flash usage without any loss in the debuggability of
the top crate. If you step into a dependency then you'll start seeing those
`<value optimized out>` messages again but it's usually the case that you want
to debug the top crate and not the dependencies. And if you *do* need to debug a
dependency then you can use the `profile-overrides` feature to exclude a
particular dependency from being optimized. See example below:
-->
<p>トップクレートのデバッグ性を失うことなしに、Flash使用量を6KiB減らしています。
依存クレートの中に足を踏み入れると、<code>&lt;value optimized out&gt;</code>のメッセージを目にするでしょう。
しかし、依存クレートではなく、トップクレートをデバッグしたい場合がほとんどでしょう。
依存クレートをデバッグする必要が<em>ある</em>場合、特定の依存クレートを最適化から除外するために、<code>profile-overrides</code>フィーチャを使えます。
例えば、以下のようになります。</p>
<pre><code class="language-toml"># ..

# `cortex-m-rt`クレートは最適化しません
[profile.dev.overrides.cortex-m-rt] # +
opt-level = 0 # +

# しかし、他の依存クレートは最適化します
[profile.dev.overrides.&quot;*&quot;]
codegen-units = 1 # better optimizations
opt-level = &quot;z&quot;
</code></pre>
<!-- Now the top crate and `cortex-m-rt` are debugger friendly! -->
<p>これで、トップクレートと<code>cortex-m-rt</code>クレートはデバッガで扱いやすくなります！</p>
<!-- ## Optimize for speed -->
<h2><a class="header" href="#速度の最適化" id="速度の最適化">速度の最適化</a></h2>
<!--
As of 2018-09-18 `rustc` supports three "optimize for speed" levels: `opt-level
= 1`, `2` and `3`. When you run `cargo build --release` you are using the release
profile which defaults to `opt-level = 3`.
-->
<p>2018-09-18の<code>rustc</code>は、3つの「速度最適化」を提供しています。<code>opt-level = 1</code>、<code>2</code>と<code>3</code>です。
<code>cargo build --release</code>を実行した時、デフォルトでは<code>opt-level = 3</code>のリリースプロファイルを使います。</p>
<!--
Both `opt-level = 2` and `3` optimize for speed at the expense of binary size,
but level `3` does more vectorization and inlining than level `2`. In
particular, you'll see that at `opt-level` equal or greater than `2` LLVM will
unroll loops. Loop unrolling has a rather high cost in terms of Flash / ROM
(e.g. from 26 bytes to 194 for a zero this array loop) but can also halve the
execution time given the right conditions (e.g. number of iterations is big
enough).
-->
<p><code>opt-level = 2</code>と<code>3</code>は、バイナリサイズを犠牲にして、速度を最適化します。レベル<code>3</code>はレベル<code>2</code>より、ベクトル化とインライン化を行います。
特に、<code>opt-level</code>が<code>2</code>以上の場合、LLVMがループを展開するのがわかるでしょう。
ループ展開は、Flash/ROMの観点からはよりコストが高いです（例えば、配列のループをゼロにする場合、26バイトから194バイトまで増加します）。
しかし、適切な条件では、実行時間が半分になります（例えば、イテレーションの回数が十分大きい場合）。</p>
<!--
Currently there's no way to disable loop unrolling in `opt-level = 2` and `3` so
if you can't afford its cost you should optimize your program for size.
-->
<p>現在、<code>opt-level = 2</code>と<code>3</code>でループ展開を無効化する方法はありません。
ループ展開のコストを払うことができない場合、プログラムサイズの最適化をするべきです。</p>
<!-- ## Optimize for size -->
<h2><a class="header" href="#サイズの最適化" id="サイズの最適化">サイズの最適化</a></h2>
<!--
As of 2018-09-18 `rustc` supports two "optimize for size" levels: `opt-level =
"s"` and `"z"`. These names were inherited from clang / LLVM and are not too
descriptive but `"z"` is meant to give the idea that it produces smaller
binaries than `"s"`.
-->
<p>2018-09-18の<code>rustc</code>は、2つの<code>サイズ最適化</code>を提供しています。<code>opt-level = &quot;s&quot;</code>と<code>&quot;z&quot;</code>です。
これらの名前は、clang / LLVMから受け継いでおり、意味がわかりにくいです。
<code>&quot;z&quot;</code>は、<code>&quot;s&quot;</code>より小さなバイナリを作る意図を意味します。</p>
<!--
If you want your release binaries to be optimized for size then change the
`profile.release.opt-level` setting in `Cargo.toml` as shown below.
-->
<p>リリースバイナリのサイズを最適化したい場合、<code>Cargo.toml</code>の<code>profile.release.opt-level</code>設定を下記の通り変更します。</p>
<pre><code class="language-toml">[profile.release]
# または&quot;z&quot;
opt-level = &quot;s&quot;
</code></pre>
<!--
These two optimization levels greatly reduce LLVM's inline threshold, a metric
used to decide whether to inline a function or not. One of Rust principles are
zero cost abstractions; these abstractions tend to use a lot of newtypes and
small functions to hold invariants (e.g. functions that borrow an inner value
like `deref`, `as_ref`) so a low inline threshold can make LLVM miss
optimization opportunities (e.g. eliminate dead branches, inline calls to
closures).
-->
<p>これらの2つの最適化レベルは、LLVMのインラインしきい値を大幅に減らします。
インラインしきい値は、関数をインライン化するか否かを決めるために使われる基準値です。
Rustの原則の1つは、ゼロコスト抽象化です。
これらの抽象化は、不変条件を保持するため、多くの新しい型と小さな関数を使う傾向にあります
（例えば、<code>deref</code>や<code>as_ref</code>のような内部の値を借用するための関数）。
そのため、インラインしきい値を低くすると、LLVMが最適化の機会を失います
（例えば、不要な分岐を削除したり、クロージャをインライン呼び出しにする、など）。</p>
<!--
When optimizing for size you may want to try increasing the inline threshold to
see if that has any effect on the binary size. The recommended way to change the
inline threshold is to append the `-C inline-threshold` flag to the other
rustflags in `.cargo/config`.
-->
<p>サイズの最適化を行っている時、バイナリサイズに影響があるかどうかを見るために、インラインしきい値を増やしたいかもしれません。
インラインしきい値を変更するお勧めの方法は、<code>.cargo/config</code>内のrustflagsに<code>-C inline-threshold</code>フラグを追加することです。</p>
<pre><code class="language-toml"># .cargo/config
# cortex-m-quickstartテンプレートを使っていることを想定しています
[target.'cfg(all(target_arch = &quot;arm&quot;, target_os = &quot;none&quot;))']
rustflags = [
  # ..
  &quot;-C&quot;, &quot;inline-threshold=123&quot;, # +
]
</code></pre>
<!--
What value to use? [As of 1.29.0 these are the inline thresholds that the
different optimization levels use][inline-threshold]:
-->
<p>この値は何に使われるのでしょうか？
<a href="https://github.com/rust-lang/rust/blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122">1.29.0では、下記の値は、異なる最適化レベルで使われるインラインしきい値です</a></p>
<!-- [inline-threshold]: https://github.com/rust-lang/rust/blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122 -->
<!--
- `opt-level = 3` uses 275
- `opt-level = 2` uses 225
- `opt-level = "s"` uses 75
- `opt-level = "z"` uses 25
-->
<ul>
<li><code>opt-level = 3</code>は275を使います</li>
<li><code>opt-level = 2</code>は225を使います</li>
<li><code>opt-level = &quot;s&quot;</code>は75を使います</li>
<li><code>opt-level = &quot;z&quot;</code>は25を使います</li>
</ul>
<!-- You should try `225` and `275` when optimizing for size. -->
<p>サイズの最適化をするときは、<code>225</code>と<code>275</code>を試してみるべきです。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
